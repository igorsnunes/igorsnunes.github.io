<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/cpu/ppc/vm/ppc.ad</title>
<body id="SUNWwebrev">
<pre>
   1 //
   2 // Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3 // Copyright (c) 2012, 2016 SAP SE. All rights reserved.
   4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5 //
   6 // This code is free software; you can redistribute it and/or modify it
   7 // under the terms of the GNU General Public License version 2 only, as
   8 // published by the Free Software Foundation.
   9 //
  10 // This code is distributed in the hope that it will be useful, but WITHOUT
  11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13 // version 2 for more details (a copy is included in the LICENSE file that
  14 // accompanied this code).
  15 //
  16 // You should have received a copy of the GNU General Public License version
  17 // 2 along with this work; if not, write to the Free Software Foundation,
  18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19 //
  20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21 // or visit www.oracle.com if you need additional information or have any
  22 // questions.
  23 //
  24 //
  25 
  26 //
  27 // PPC64 Architecture Description File
  28 //
  29 
  30 //----------REGISTER DEFINITION BLOCK------------------------------------------
  31 // This information is used by the matcher and the register allocator to
  32 // describe individual registers and classes of registers within the target
  33 // architecture.
  34 register %{
  35 //----------Architecture Description Register Definitions----------------------
  36 // General Registers
  37 // "reg_def"  name (register save type, C convention save type,
  38 //                  ideal register type, encoding);
  39 //
  40 // Register Save Types:
  41 //
  42 //   NS  = No-Save:     The register allocator assumes that these registers
  43 //                      can be used without saving upon entry to the method, &amp;
  44 //                      that they do not need to be saved at call sites.
  45 //
  46 //   SOC = Save-On-Call: The register allocator assumes that these registers
  47 //                      can be used without saving upon entry to the method,
  48 //                      but that they must be saved at call sites.
  49 //                      These are called "volatiles" on ppc.
  50 //
  51 //   SOE = Save-On-Entry: The register allocator assumes that these registers
  52 //                      must be saved before using them upon entry to the
  53 //                      method, but they do not need to be saved at call
  54 //                      sites.
  55 //                      These are called "nonvolatiles" on ppc.
  56 //
  57 //   AS  = Always-Save:   The register allocator assumes that these registers
  58 //                      must be saved before using them upon entry to the
  59 //                      method, &amp; that they must be saved at call sites.
  60 //
  61 // Ideal Register Type is used to determine how to save &amp; restore a
  62 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
  63 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
  64 //
  65 // The encoding number is the actual bit-pattern placed into the opcodes.
  66 //
  67 // PPC64 register definitions, based on the 64-bit PowerPC ELF ABI
  68 // Supplement Version 1.7 as of 2003-10-29.
  69 //
  70 // For each 64-bit register we must define two registers: the register
  71 // itself, e.g. R3, and a corresponding virtual other (32-bit-)'half',
  72 // e.g. R3_H, which is needed by the allocator, but is not used
  73 // for stores, loads, etc.
  74 
  75 // ----------------------------
  76 // Integer/Long Registers
  77 // ----------------------------
  78 
  79   // PPC64 has 32 64-bit integer registers.
  80 
  81   // types: v = volatile, nv = non-volatile, s = system
  82   reg_def R0   ( SOC, SOC, Op_RegI,  0, R0-&gt;as_VMReg()         );  // v   used in prologs
  83   reg_def R0_H ( SOC, SOC, Op_RegI, 99, R0-&gt;as_VMReg()-&gt;next() );
  84   reg_def R1   ( NS,  NS,  Op_RegI,  1, R1-&gt;as_VMReg()         );  // s   SP
  85   reg_def R1_H ( NS,  NS,  Op_RegI, 99, R1-&gt;as_VMReg()-&gt;next() );
  86   reg_def R2   ( SOC, SOC, Op_RegI,  2, R2-&gt;as_VMReg()         );  // v   TOC
  87   reg_def R2_H ( SOC, SOC, Op_RegI, 99, R2-&gt;as_VMReg()-&gt;next() );
  88   reg_def R3   ( SOC, SOC, Op_RegI,  3, R3-&gt;as_VMReg()         );  // v   iarg1 &amp; iret
  89   reg_def R3_H ( SOC, SOC, Op_RegI, 99, R3-&gt;as_VMReg()-&gt;next() );
  90   reg_def R4   ( SOC, SOC, Op_RegI,  4, R4-&gt;as_VMReg()         );  //     iarg2
  91   reg_def R4_H ( SOC, SOC, Op_RegI, 99, R4-&gt;as_VMReg()-&gt;next() );
  92   reg_def R5   ( SOC, SOC, Op_RegI,  5, R5-&gt;as_VMReg()         );  // v   iarg3
  93   reg_def R5_H ( SOC, SOC, Op_RegI, 99, R5-&gt;as_VMReg()-&gt;next() );
  94   reg_def R6   ( SOC, SOC, Op_RegI,  6, R6-&gt;as_VMReg()         );  // v   iarg4
  95   reg_def R6_H ( SOC, SOC, Op_RegI, 99, R6-&gt;as_VMReg()-&gt;next() );
  96   reg_def R7   ( SOC, SOC, Op_RegI,  7, R7-&gt;as_VMReg()         );  // v   iarg5
  97   reg_def R7_H ( SOC, SOC, Op_RegI, 99, R7-&gt;as_VMReg()-&gt;next() );
  98   reg_def R8   ( SOC, SOC, Op_RegI,  8, R8-&gt;as_VMReg()         );  // v   iarg6
  99   reg_def R8_H ( SOC, SOC, Op_RegI, 99, R8-&gt;as_VMReg()-&gt;next() );
 100   reg_def R9   ( SOC, SOC, Op_RegI,  9, R9-&gt;as_VMReg()         );  // v   iarg7
 101   reg_def R9_H ( SOC, SOC, Op_RegI, 99, R9-&gt;as_VMReg()-&gt;next() );
 102   reg_def R10  ( SOC, SOC, Op_RegI, 10, R10-&gt;as_VMReg()        );  // v   iarg8
 103   reg_def R10_H( SOC, SOC, Op_RegI, 99, R10-&gt;as_VMReg()-&gt;next());
 104   reg_def R11  ( SOC, SOC, Op_RegI, 11, R11-&gt;as_VMReg()        );  // v   ENV / scratch
 105   reg_def R11_H( SOC, SOC, Op_RegI, 99, R11-&gt;as_VMReg()-&gt;next());
 106   reg_def R12  ( SOC, SOC, Op_RegI, 12, R12-&gt;as_VMReg()        );  // v   scratch
 107   reg_def R12_H( SOC, SOC, Op_RegI, 99, R12-&gt;as_VMReg()-&gt;next());
 108   reg_def R13  ( NS,  NS,  Op_RegI, 13, R13-&gt;as_VMReg()        );  // s   system thread id
 109   reg_def R13_H( NS,  NS,  Op_RegI, 99, R13-&gt;as_VMReg()-&gt;next());
 110   reg_def R14  ( SOC, SOE, Op_RegI, 14, R14-&gt;as_VMReg()        );  // nv
 111   reg_def R14_H( SOC, SOE, Op_RegI, 99, R14-&gt;as_VMReg()-&gt;next());
 112   reg_def R15  ( SOC, SOE, Op_RegI, 15, R15-&gt;as_VMReg()        );  // nv
 113   reg_def R15_H( SOC, SOE, Op_RegI, 99, R15-&gt;as_VMReg()-&gt;next());
 114   reg_def R16  ( SOC, SOE, Op_RegI, 16, R16-&gt;as_VMReg()        );  // nv
 115   reg_def R16_H( SOC, SOE, Op_RegI, 99, R16-&gt;as_VMReg()-&gt;next());
 116   reg_def R17  ( SOC, SOE, Op_RegI, 17, R17-&gt;as_VMReg()        );  // nv
 117   reg_def R17_H( SOC, SOE, Op_RegI, 99, R17-&gt;as_VMReg()-&gt;next());
 118   reg_def R18  ( SOC, SOE, Op_RegI, 18, R18-&gt;as_VMReg()        );  // nv
 119   reg_def R18_H( SOC, SOE, Op_RegI, 99, R18-&gt;as_VMReg()-&gt;next());
 120   reg_def R19  ( SOC, SOE, Op_RegI, 19, R19-&gt;as_VMReg()        );  // nv
 121   reg_def R19_H( SOC, SOE, Op_RegI, 99, R19-&gt;as_VMReg()-&gt;next());
 122   reg_def R20  ( SOC, SOE, Op_RegI, 20, R20-&gt;as_VMReg()        );  // nv
 123   reg_def R20_H( SOC, SOE, Op_RegI, 99, R20-&gt;as_VMReg()-&gt;next());
 124   reg_def R21  ( SOC, SOE, Op_RegI, 21, R21-&gt;as_VMReg()        );  // nv
 125   reg_def R21_H( SOC, SOE, Op_RegI, 99, R21-&gt;as_VMReg()-&gt;next());
 126   reg_def R22  ( SOC, SOE, Op_RegI, 22, R22-&gt;as_VMReg()        );  // nv
 127   reg_def R22_H( SOC, SOE, Op_RegI, 99, R22-&gt;as_VMReg()-&gt;next());
 128   reg_def R23  ( SOC, SOE, Op_RegI, 23, R23-&gt;as_VMReg()        );  // nv
 129   reg_def R23_H( SOC, SOE, Op_RegI, 99, R23-&gt;as_VMReg()-&gt;next());
 130   reg_def R24  ( SOC, SOE, Op_RegI, 24, R24-&gt;as_VMReg()        );  // nv
 131   reg_def R24_H( SOC, SOE, Op_RegI, 99, R24-&gt;as_VMReg()-&gt;next());
 132   reg_def R25  ( SOC, SOE, Op_RegI, 25, R25-&gt;as_VMReg()        );  // nv
 133   reg_def R25_H( SOC, SOE, Op_RegI, 99, R25-&gt;as_VMReg()-&gt;next());
 134   reg_def R26  ( SOC, SOE, Op_RegI, 26, R26-&gt;as_VMReg()        );  // nv
 135   reg_def R26_H( SOC, SOE, Op_RegI, 99, R26-&gt;as_VMReg()-&gt;next());
 136   reg_def R27  ( SOC, SOE, Op_RegI, 27, R27-&gt;as_VMReg()        );  // nv
 137   reg_def R27_H( SOC, SOE, Op_RegI, 99, R27-&gt;as_VMReg()-&gt;next());
 138   reg_def R28  ( SOC, SOE, Op_RegI, 28, R28-&gt;as_VMReg()        );  // nv
 139   reg_def R28_H( SOC, SOE, Op_RegI, 99, R28-&gt;as_VMReg()-&gt;next());
 140   reg_def R29  ( SOC, SOE, Op_RegI, 29, R29-&gt;as_VMReg()        );  // nv
 141   reg_def R29_H( SOC, SOE, Op_RegI, 99, R29-&gt;as_VMReg()-&gt;next());
 142   reg_def R30  ( SOC, SOE, Op_RegI, 30, R30-&gt;as_VMReg()        );  // nv
 143   reg_def R30_H( SOC, SOE, Op_RegI, 99, R30-&gt;as_VMReg()-&gt;next());
 144   reg_def R31  ( SOC, SOE, Op_RegI, 31, R31-&gt;as_VMReg()        );  // nv
 145   reg_def R31_H( SOC, SOE, Op_RegI, 99, R31-&gt;as_VMReg()-&gt;next());
 146 
 147 
 148 // ----------------------------
 149 // Float/Double Registers
 150 // ----------------------------
 151 
 152   // Double Registers
 153   // The rules of ADL require that double registers be defined in pairs.
 154   // Each pair must be two 32-bit values, but not necessarily a pair of
 155   // single float registers. In each pair, ADLC-assigned register numbers
 156   // must be adjacent, with the lower number even. Finally, when the
 157   // CPU stores such a register pair to memory, the word associated with
 158   // the lower ADLC-assigned number must be stored to the lower address.
 159 
 160   // PPC64 has 32 64-bit floating-point registers. Each can store a single
 161   // or double precision floating-point value.
 162 
 163   // types: v = volatile, nv = non-volatile, s = system
 164   reg_def F0   ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg()         );  // v   scratch
 165   reg_def F0_H ( SOC, SOC, Op_RegF, 99, F0-&gt;as_VMReg()-&gt;next() );
 166   reg_def F1   ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg()         );  // v   farg1 &amp; fret
 167   reg_def F1_H ( SOC, SOC, Op_RegF, 99, F1-&gt;as_VMReg()-&gt;next() );
 168   reg_def F2   ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg()         );  // v   farg2
 169   reg_def F2_H ( SOC, SOC, Op_RegF, 99, F2-&gt;as_VMReg()-&gt;next() );
 170   reg_def F3   ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg()         );  // v   farg3
 171   reg_def F3_H ( SOC, SOC, Op_RegF, 99, F3-&gt;as_VMReg()-&gt;next() );
 172   reg_def F4   ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg()         );  // v   farg4
 173   reg_def F4_H ( SOC, SOC, Op_RegF, 99, F4-&gt;as_VMReg()-&gt;next() );
 174   reg_def F5   ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg()         );  // v   farg5
 175   reg_def F5_H ( SOC, SOC, Op_RegF, 99, F5-&gt;as_VMReg()-&gt;next() );
 176   reg_def F6   ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg()         );  // v   farg6
 177   reg_def F6_H ( SOC, SOC, Op_RegF, 99, F6-&gt;as_VMReg()-&gt;next() );
 178   reg_def F7   ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg()         );  // v   farg7
 179   reg_def F7_H ( SOC, SOC, Op_RegF, 99, F7-&gt;as_VMReg()-&gt;next() );
 180   reg_def F8   ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg()         );  // v   farg8
 181   reg_def F8_H ( SOC, SOC, Op_RegF, 99, F8-&gt;as_VMReg()-&gt;next() );
 182   reg_def F9   ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg()         );  // v   farg9
 183   reg_def F9_H ( SOC, SOC, Op_RegF, 99, F9-&gt;as_VMReg()-&gt;next() );
 184   reg_def F10  ( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg()        );  // v   farg10
 185   reg_def F10_H( SOC, SOC, Op_RegF, 99, F10-&gt;as_VMReg()-&gt;next());
 186   reg_def F11  ( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg()        );  // v   farg11
 187   reg_def F11_H( SOC, SOC, Op_RegF, 99, F11-&gt;as_VMReg()-&gt;next());
 188   reg_def F12  ( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg()        );  // v   farg12
 189   reg_def F12_H( SOC, SOC, Op_RegF, 99, F12-&gt;as_VMReg()-&gt;next());
 190   reg_def F13  ( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg()        );  // v   farg13
 191   reg_def F13_H( SOC, SOC, Op_RegF, 99, F13-&gt;as_VMReg()-&gt;next());
 192   reg_def F14  ( SOC, SOE, Op_RegF, 14, F14-&gt;as_VMReg()        );  // nv
 193   reg_def F14_H( SOC, SOE, Op_RegF, 99, F14-&gt;as_VMReg()-&gt;next());
 194   reg_def F15  ( SOC, SOE, Op_RegF, 15, F15-&gt;as_VMReg()        );  // nv
 195   reg_def F15_H( SOC, SOE, Op_RegF, 99, F15-&gt;as_VMReg()-&gt;next());
 196   reg_def F16  ( SOC, SOE, Op_RegF, 16, F16-&gt;as_VMReg()        );  // nv
 197   reg_def F16_H( SOC, SOE, Op_RegF, 99, F16-&gt;as_VMReg()-&gt;next());
 198   reg_def F17  ( SOC, SOE, Op_RegF, 17, F17-&gt;as_VMReg()        );  // nv
 199   reg_def F17_H( SOC, SOE, Op_RegF, 99, F17-&gt;as_VMReg()-&gt;next());
 200   reg_def F18  ( SOC, SOE, Op_RegF, 18, F18-&gt;as_VMReg()        );  // nv
 201   reg_def F18_H( SOC, SOE, Op_RegF, 99, F18-&gt;as_VMReg()-&gt;next());
 202   reg_def F19  ( SOC, SOE, Op_RegF, 19, F19-&gt;as_VMReg()        );  // nv
 203   reg_def F19_H( SOC, SOE, Op_RegF, 99, F19-&gt;as_VMReg()-&gt;next());
 204   reg_def F20  ( SOC, SOE, Op_RegF, 20, F20-&gt;as_VMReg()        );  // nv
 205   reg_def F20_H( SOC, SOE, Op_RegF, 99, F20-&gt;as_VMReg()-&gt;next());
 206   reg_def F21  ( SOC, SOE, Op_RegF, 21, F21-&gt;as_VMReg()        );  // nv
 207   reg_def F21_H( SOC, SOE, Op_RegF, 99, F21-&gt;as_VMReg()-&gt;next());
 208   reg_def F22  ( SOC, SOE, Op_RegF, 22, F22-&gt;as_VMReg()        );  // nv
 209   reg_def F22_H( SOC, SOE, Op_RegF, 99, F22-&gt;as_VMReg()-&gt;next());
 210   reg_def F23  ( SOC, SOE, Op_RegF, 23, F23-&gt;as_VMReg()        );  // nv
 211   reg_def F23_H( SOC, SOE, Op_RegF, 99, F23-&gt;as_VMReg()-&gt;next());
 212   reg_def F24  ( SOC, SOE, Op_RegF, 24, F24-&gt;as_VMReg()        );  // nv
 213   reg_def F24_H( SOC, SOE, Op_RegF, 99, F24-&gt;as_VMReg()-&gt;next());
 214   reg_def F25  ( SOC, SOE, Op_RegF, 25, F25-&gt;as_VMReg()        );  // nv
 215   reg_def F25_H( SOC, SOE, Op_RegF, 99, F25-&gt;as_VMReg()-&gt;next());
 216   reg_def F26  ( SOC, SOE, Op_RegF, 26, F26-&gt;as_VMReg()        );  // nv
 217   reg_def F26_H( SOC, SOE, Op_RegF, 99, F26-&gt;as_VMReg()-&gt;next());
 218   reg_def F27  ( SOC, SOE, Op_RegF, 27, F27-&gt;as_VMReg()        );  // nv
 219   reg_def F27_H( SOC, SOE, Op_RegF, 99, F27-&gt;as_VMReg()-&gt;next());
 220   reg_def F28  ( SOC, SOE, Op_RegF, 28, F28-&gt;as_VMReg()        );  // nv
 221   reg_def F28_H( SOC, SOE, Op_RegF, 99, F28-&gt;as_VMReg()-&gt;next());
 222   reg_def F29  ( SOC, SOE, Op_RegF, 29, F29-&gt;as_VMReg()        );  // nv
 223   reg_def F29_H( SOC, SOE, Op_RegF, 99, F29-&gt;as_VMReg()-&gt;next());
 224   reg_def F30  ( SOC, SOE, Op_RegF, 30, F30-&gt;as_VMReg()        );  // nv
 225   reg_def F30_H( SOC, SOE, Op_RegF, 99, F30-&gt;as_VMReg()-&gt;next());
 226   reg_def F31  ( SOC, SOE, Op_RegF, 31, F31-&gt;as_VMReg()        );  // nv
 227   reg_def F31_H( SOC, SOE, Op_RegF, 99, F31-&gt;as_VMReg()-&gt;next());
 228 
 229 // ----------------------------
 230 // Special Registers
 231 // ----------------------------
 232 
 233 // Condition Codes Flag Registers
 234 
 235   // PPC64 has 8 condition code "registers" which are all contained
 236   // in the CR register.
 237 
 238   // types: v = volatile, nv = non-volatile, s = system
 239   reg_def CCR0(SOC, SOC, Op_RegFlags, 0, CCR0-&gt;as_VMReg());  // v
 240   reg_def CCR1(SOC, SOC, Op_RegFlags, 1, CCR1-&gt;as_VMReg());  // v
 241   reg_def CCR2(SOC, SOC, Op_RegFlags, 2, CCR2-&gt;as_VMReg());  // nv
 242   reg_def CCR3(SOC, SOC, Op_RegFlags, 3, CCR3-&gt;as_VMReg());  // nv
 243   reg_def CCR4(SOC, SOC, Op_RegFlags, 4, CCR4-&gt;as_VMReg());  // nv
 244   reg_def CCR5(SOC, SOC, Op_RegFlags, 5, CCR5-&gt;as_VMReg());  // v
 245   reg_def CCR6(SOC, SOC, Op_RegFlags, 6, CCR6-&gt;as_VMReg());  // v
 246   reg_def CCR7(SOC, SOC, Op_RegFlags, 7, CCR7-&gt;as_VMReg());  // v
 247 
 248   // Special registers of PPC64
 249 
 250   reg_def SR_XER(    SOC, SOC, Op_RegP, 0, SR_XER-&gt;as_VMReg());     // v
 251   reg_def SR_LR(     SOC, SOC, Op_RegP, 1, SR_LR-&gt;as_VMReg());      // v
 252   reg_def SR_CTR(    SOC, SOC, Op_RegP, 2, SR_CTR-&gt;as_VMReg());     // v
 253   reg_def SR_VRSAVE( SOC, SOC, Op_RegP, 3, SR_VRSAVE-&gt;as_VMReg());  // v
 254   reg_def SR_SPEFSCR(SOC, SOC, Op_RegP, 4, SR_SPEFSCR-&gt;as_VMReg()); // v
 255   reg_def SR_PPR(    SOC, SOC, Op_RegP, 5, SR_PPR-&gt;as_VMReg());     // v
 256 
 257 
 258 // ----------------------------
 259 // Specify priority of register selection within phases of register
 260 // allocation. Highest priority is first. A useful heuristic is to
 261 // give registers a low priority when they are required by machine
 262 // instructions, like EAX and EDX on I486, and choose no-save registers
 263 // before save-on-call, &amp; save-on-call before save-on-entry. Registers
 264 // which participate in fixed calling sequences should come last.
 265 // Registers which are used as pairs must fall on an even boundary.
 266 
 267 // It's worth about 1% on SPEC geomean to get this right.
 268 
 269 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
 270 // in adGlobals_ppc.hpp which defines the &lt;register&gt;_num values, e.g.
 271 // R3_num. Therefore, R3_num may not be (and in reality is not)
 272 // the same as R3-&gt;encoding()! Furthermore, we cannot make any
 273 // assumptions on ordering, e.g. R3_num may be less than R2_num.
 274 // Additionally, the function
 275 //   static enum RC rc_class(OptoReg::Name reg )
 276 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
 277 // and its current implementation relies on chunk0 and chunk1 having a
 278 // size of 64 each.
 279 
 280 // If you change this allocation class, please have a look at the
 281 // default values for the parameters RoundRobinIntegerRegIntervalStart
 282 // and RoundRobinFloatRegIntervalStart
 283 
 284 alloc_class chunk0 (
 285   // Chunk0 contains *all* 64 integer registers halves.
 286 
 287   // "non-volatile" registers
 288   R14, R14_H,
 289   R15, R15_H,
 290   R17, R17_H,
 291   R18, R18_H,
 292   R19, R19_H,
 293   R20, R20_H,
 294   R21, R21_H,
 295   R22, R22_H,
 296   R23, R23_H,
 297   R24, R24_H,
 298   R25, R25_H,
 299   R26, R26_H,
 300   R27, R27_H,
 301   R28, R28_H,
 302   R29, R29_H,
 303   R30, R30_H,
 304   R31, R31_H,
 305 
 306   // scratch/special registers
 307   R11, R11_H,
 308   R12, R12_H,
 309 
 310   // argument registers
 311   R10, R10_H,
 312   R9,  R9_H,
 313   R8,  R8_H,
 314   R7,  R7_H,
 315   R6,  R6_H,
 316   R5,  R5_H,
 317   R4,  R4_H,
 318   R3,  R3_H,
 319 
 320   // special registers, not available for allocation
 321   R16, R16_H,     // R16_thread
 322   R13, R13_H,     // system thread id
 323   R2,  R2_H,      // may be used for TOC
 324   R1,  R1_H,      // SP
 325   R0,  R0_H       // R0 (scratch)
 326 );
 327 
 328 // If you change this allocation class, please have a look at the
 329 // default values for the parameters RoundRobinIntegerRegIntervalStart
 330 // and RoundRobinFloatRegIntervalStart
 331 
 332 alloc_class chunk1 (
 333   // Chunk1 contains *all* 64 floating-point registers halves.
 334 
 335   // scratch register
 336   F0,  F0_H,
 337 
 338   // argument registers
 339   F13, F13_H,
 340   F12, F12_H,
 341   F11, F11_H,
 342   F10, F10_H,
 343   F9,  F9_H,
 344   F8,  F8_H,
 345   F7,  F7_H,
 346   F6,  F6_H,
 347   F5,  F5_H,
 348   F4,  F4_H,
 349   F3,  F3_H,
 350   F2,  F2_H,
 351   F1,  F1_H,
 352 
 353   // non-volatile registers
 354   F14, F14_H,
 355   F15, F15_H,
 356   F16, F16_H,
 357   F17, F17_H,
 358   F18, F18_H,
 359   F19, F19_H,
 360   F20, F20_H,
 361   F21, F21_H,
 362   F22, F22_H,
 363   F23, F23_H,
 364   F24, F24_H,
 365   F25, F25_H,
 366   F26, F26_H,
 367   F27, F27_H,
 368   F28, F28_H,
 369   F29, F29_H,
 370   F30, F30_H,
 371   F31, F31_H
 372 );
 373 
 374 alloc_class chunk2 (
 375   // Chunk2 contains *all* 8 condition code registers.
 376 
 377   CCR0,
 378   CCR1,
 379   CCR2,
 380   CCR3,
 381   CCR4,
 382   CCR5,
 383   CCR6,
 384   CCR7
 385 );
 386 
 387 alloc_class chunk3 (
 388   // special registers
 389   // These registers are not allocated, but used for nodes generated by postalloc expand.
 390   SR_XER,
 391   SR_LR,
 392   SR_CTR,
 393   SR_VRSAVE,
 394   SR_SPEFSCR,
 395   SR_PPR
 396 );
 397 
 398 //-------Architecture Description Register Classes-----------------------
 399 
 400 // Several register classes are automatically defined based upon
 401 // information in this architecture description.
 402 
 403 // 1) reg_class inline_cache_reg           ( as defined in frame section )
 404 // 2) reg_class compiler_method_oop_reg    ( as defined in frame section )
 405 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
 406 // 3) reg_class stack_slots( /* one chunk of stack-based "registers" */ )
 407 //
 408 
 409 // ----------------------------
 410 // 32 Bit Register Classes
 411 // ----------------------------
 412 
 413 // We specify registers twice, once as read/write, and once read-only.
 414 // We use the read-only registers for source operands. With this, we
 415 // can include preset read only registers in this class, as a hard-coded
 416 // '0'-register. (We used to simulate this on ppc.)
 417 
 418 // 32 bit registers that can be read and written i.e. these registers
 419 // can be dest (or src) of normal instructions.
 420 reg_class bits32_reg_rw(
 421 /*R0*/              // R0
 422 /*R1*/              // SP
 423   R2,               // TOC
 424   R3,
 425   R4,
 426   R5,
 427   R6,
 428   R7,
 429   R8,
 430   R9,
 431   R10,
 432   R11,
 433   R12,
 434 /*R13*/             // system thread id
 435   R14,
 436   R15,
 437 /*R16*/             // R16_thread
 438   R17,
 439   R18,
 440   R19,
 441   R20,
 442   R21,
 443   R22,
 444   R23,
 445   R24,
 446   R25,
 447   R26,
 448   R27,
 449   R28,
 450 /*R29,*/             // global TOC
 451   R30,
 452   R31
 453 );
 454 
 455 // 32 bit registers that can only be read i.e. these registers can
 456 // only be src of all instructions.
 457 reg_class bits32_reg_ro(
 458 /*R0*/              // R0
 459 /*R1*/              // SP
 460   R2                // TOC
 461   R3,
 462   R4,
 463   R5,
 464   R6,
 465   R7,
 466   R8,
 467   R9,
 468   R10,
 469   R11,
 470   R12,
 471 /*R13*/             // system thread id
 472   R14,
 473   R15,
 474 /*R16*/             // R16_thread
 475   R17,
 476   R18,
 477   R19,
 478   R20,
 479   R21,
 480   R22,
 481   R23,
 482   R24,
 483   R25,
 484   R26,
 485   R27,
 486   R28,
 487 /*R29,*/
 488   R30,
 489   R31
 490 );
 491 
 492 reg_class rscratch1_bits32_reg(R11);
 493 reg_class rscratch2_bits32_reg(R12);
 494 reg_class rarg1_bits32_reg(R3);
 495 reg_class rarg2_bits32_reg(R4);
 496 reg_class rarg3_bits32_reg(R5);
 497 reg_class rarg4_bits32_reg(R6);
 498 
 499 // ----------------------------
 500 // 64 Bit Register Classes
 501 // ----------------------------
 502 // 64-bit build means 64-bit pointers means hi/lo pairs
 503 
 504 reg_class rscratch1_bits64_reg(R11_H, R11);
 505 reg_class rscratch2_bits64_reg(R12_H, R12);
 506 reg_class rarg1_bits64_reg(R3_H, R3);
 507 reg_class rarg2_bits64_reg(R4_H, R4);
 508 reg_class rarg3_bits64_reg(R5_H, R5);
 509 reg_class rarg4_bits64_reg(R6_H, R6);
 510 // Thread register, 'written' by tlsLoadP, see there.
 511 reg_class thread_bits64_reg(R16_H, R16);
 512 
 513 reg_class r19_bits64_reg(R19_H, R19);
 514 
 515 // 64 bit registers that can be read and written i.e. these registers
 516 // can be dest (or src) of normal instructions.
 517 reg_class bits64_reg_rw(
 518 /*R0_H,  R0*/     // R0
 519 /*R1_H,  R1*/     // SP
 520   R2_H,  R2,      // TOC
 521   R3_H,  R3,
 522   R4_H,  R4,
 523   R5_H,  R5,
 524   R6_H,  R6,
 525   R7_H,  R7,
 526   R8_H,  R8,
 527   R9_H,  R9,
 528   R10_H, R10,
 529   R11_H, R11,
 530   R12_H, R12,
 531 /*R13_H, R13*/   // system thread id
 532   R14_H, R14,
 533   R15_H, R15,
 534 /*R16_H, R16*/   // R16_thread
 535   R17_H, R17,
 536   R18_H, R18,
 537   R19_H, R19,
 538   R20_H, R20,
 539   R21_H, R21,
 540   R22_H, R22,
 541   R23_H, R23,
 542   R24_H, R24,
 543   R25_H, R25,
 544   R26_H, R26,
 545   R27_H, R27,
 546   R28_H, R28,
 547 /*R29_H, R29,*/
 548   R30_H, R30,
 549   R31_H, R31
 550 );
 551 
 552 // 64 bit registers used excluding r2, r11 and r12
 553 // Used to hold the TOC to avoid collisions with expanded LeafCall which uses
 554 // r2, r11 and r12 internally.
 555 reg_class bits64_reg_leaf_call(
 556 /*R0_H,  R0*/     // R0
 557 /*R1_H,  R1*/     // SP
 558 /*R2_H,  R2*/     // TOC
 559   R3_H,  R3,
 560   R4_H,  R4,
 561   R5_H,  R5,
 562   R6_H,  R6,
 563   R7_H,  R7,
 564   R8_H,  R8,
 565   R9_H,  R9,
 566   R10_H, R10,
 567 /*R11_H, R11*/
 568 /*R12_H, R12*/
 569 /*R13_H, R13*/   // system thread id
 570   R14_H, R14,
 571   R15_H, R15,
 572 /*R16_H, R16*/   // R16_thread
 573   R17_H, R17,
 574   R18_H, R18,
 575   R19_H, R19,
 576   R20_H, R20,
 577   R21_H, R21,
 578   R22_H, R22,
 579   R23_H, R23,
 580   R24_H, R24,
 581   R25_H, R25,
 582   R26_H, R26,
 583   R27_H, R27,
 584   R28_H, R28,
 585 /*R29_H, R29,*/
 586   R30_H, R30,
 587   R31_H, R31
 588 );
 589 
 590 // Used to hold the TOC to avoid collisions with expanded DynamicCall
 591 // which uses r19 as inline cache internally and expanded LeafCall which uses
 592 // r2, r11 and r12 internally.
 593 reg_class bits64_constant_table_base(
 594 /*R0_H,  R0*/     // R0
 595 /*R1_H,  R1*/     // SP
 596 /*R2_H,  R2*/     // TOC
 597   R3_H,  R3,
 598   R4_H,  R4,
 599   R5_H,  R5,
 600   R6_H,  R6,
 601   R7_H,  R7,
 602   R8_H,  R8,
 603   R9_H,  R9,
 604   R10_H, R10,
 605 /*R11_H, R11*/
 606 /*R12_H, R12*/
 607 /*R13_H, R13*/   // system thread id
 608   R14_H, R14,
 609   R15_H, R15,
 610 /*R16_H, R16*/   // R16_thread
 611   R17_H, R17,
 612   R18_H, R18,
 613 /*R19_H, R19*/
 614   R20_H, R20,
 615   R21_H, R21,
 616   R22_H, R22,
 617   R23_H, R23,
 618   R24_H, R24,
 619   R25_H, R25,
 620   R26_H, R26,
 621   R27_H, R27,
 622   R28_H, R28,
 623 /*R29_H, R29,*/
 624   R30_H, R30,
 625   R31_H, R31
 626 );
 627 
 628 // 64 bit registers that can only be read i.e. these registers can
 629 // only be src of all instructions.
 630 reg_class bits64_reg_ro(
 631 /*R0_H,  R0*/     // R0
 632   R1_H,  R1,
 633   R2_H,  R2,       // TOC
 634   R3_H,  R3,
 635   R4_H,  R4,
 636   R5_H,  R5,
 637   R6_H,  R6,
 638   R7_H,  R7,
 639   R8_H,  R8,
 640   R9_H,  R9,
 641   R10_H, R10,
 642   R11_H, R11,
 643   R12_H, R12,
 644 /*R13_H, R13*/   // system thread id
 645   R14_H, R14,
 646   R15_H, R15,
 647   R16_H, R16,    // R16_thread
 648   R17_H, R17,
 649   R18_H, R18,
 650   R19_H, R19,
 651   R20_H, R20,
 652   R21_H, R21,
 653   R22_H, R22,
 654   R23_H, R23,
 655   R24_H, R24,
 656   R25_H, R25,
 657   R26_H, R26,
 658   R27_H, R27,
 659   R28_H, R28,
 660 /*R29_H, R29,*/ // TODO: let allocator handle TOC!!
 661   R30_H, R30,
 662   R31_H, R31
 663 );
 664 
 665 
 666 // ----------------------------
 667 // Special Class for Condition Code Flags Register
 668 
 669 reg_class int_flags(
 670 /*CCR0*/             // scratch
 671 /*CCR1*/             // scratch
 672 /*CCR2*/             // nv!
 673 /*CCR3*/             // nv!
 674 /*CCR4*/             // nv!
 675   CCR5,
 676   CCR6,
 677   CCR7
 678 );
 679 
 680 reg_class int_flags_ro(
 681   CCR0,
 682   CCR1,
 683   CCR2,
 684   CCR3,
 685   CCR4,
 686   CCR5,
 687   CCR6,
 688   CCR7
 689 );
 690 
 691 reg_class int_flags_CR0(CCR0);
 692 reg_class int_flags_CR1(CCR1);
 693 reg_class int_flags_CR6(CCR6);
 694 reg_class ctr_reg(SR_CTR);
 695 
 696 // ----------------------------
 697 // Float Register Classes
 698 // ----------------------------
 699 
 700 reg_class flt_reg(
 701   F0,
 702   F1,
 703   F2,
 704   F3,
 705   F4,
 706   F5,
 707   F6,
 708   F7,
 709   F8,
 710   F9,
 711   F10,
 712   F11,
 713   F12,
 714   F13,
 715   F14,              // nv!
 716   F15,              // nv!
 717   F16,              // nv!
 718   F17,              // nv!
 719   F18,              // nv!
 720   F19,              // nv!
 721   F20,              // nv!
 722   F21,              // nv!
 723   F22,              // nv!
 724   F23,              // nv!
 725   F24,              // nv!
 726   F25,              // nv!
 727   F26,              // nv!
 728   F27,              // nv!
 729   F28,              // nv!
 730   F29,              // nv!
 731   F30,              // nv!
 732   F31               // nv!
 733 );
 734 
 735 // Double precision float registers have virtual `high halves' that
 736 // are needed by the allocator.
 737 reg_class dbl_reg(
 738   F0,  F0_H,
 739   F1,  F1_H,
 740   F2,  F2_H,
 741   F3,  F3_H,
 742   F4,  F4_H,
 743   F5,  F5_H,
 744   F6,  F6_H,
 745   F7,  F7_H,
 746   F8,  F8_H,
 747   F9,  F9_H,
 748   F10, F10_H,
 749   F11, F11_H,
 750   F12, F12_H,
 751   F13, F13_H,
 752   F14, F14_H,    // nv!
 753   F15, F15_H,    // nv!
 754   F16, F16_H,    // nv!
 755   F17, F17_H,    // nv!
 756   F18, F18_H,    // nv!
 757   F19, F19_H,    // nv!
 758   F20, F20_H,    // nv!
 759   F21, F21_H,    // nv!
 760   F22, F22_H,    // nv!
 761   F23, F23_H,    // nv!
 762   F24, F24_H,    // nv!
 763   F25, F25_H,    // nv!
 764   F26, F26_H,    // nv!
 765   F27, F27_H,    // nv!
 766   F28, F28_H,    // nv!
 767   F29, F29_H,    // nv!
 768   F30, F30_H,    // nv!
 769   F31, F31_H     // nv!
 770 );
 771 
 772  %}
 773 
 774 //----------DEFINITION BLOCK---------------------------------------------------
 775 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
 776 // Current support includes integer values in the range [0, 0x7FFFFFFF]
 777 // Format:
 778 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
 779 // Generated Code in ad_&lt;arch&gt;.hpp
 780 //        #define  &lt;name&gt;   (&lt;expression&gt;)
 781 //        // value == &lt;int_value&gt;
 782 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
 783 //        assert( &lt;name&gt; == &lt;int_value&gt;, "Expect (&lt;expression&gt;) to equal &lt;int_value&gt;");
 784 //
 785 definitions %{
 786   // The default cost (of an ALU instruction).
 787   int_def DEFAULT_COST_LOW        (     30,      30);
 788   int_def DEFAULT_COST            (    100,     100);
 789   int_def HUGE_COST               (1000000, 1000000);
 790 
 791   // Memory refs
 792   int_def MEMORY_REF_COST_LOW     (    200, DEFAULT_COST * 2);
 793   int_def MEMORY_REF_COST         (    300, DEFAULT_COST * 3);
 794 
 795   // Branches are even more expensive.
 796   int_def BRANCH_COST             (    900, DEFAULT_COST * 9);
 797   int_def CALL_COST               (   1300, DEFAULT_COST * 13);
 798 %}
 799 
 800 
 801 //----------SOURCE BLOCK-------------------------------------------------------
 802 // This is a block of C++ code which provides values, functions, and
 803 // definitions necessary in the rest of the architecture description.
 804 source_hpp %{
 805   // Header information of the source block.
 806   // Method declarations/definitions which are used outside
 807   // the ad-scope can conveniently be defined here.
 808   //
 809   // To keep related declarations/definitions/uses close together,
 810   // we switch between source %{ }% and source_hpp %{ }% freely as needed.
 811 
 812   // Returns true if Node n is followed by a MemBar node that
 813   // will do an acquire. If so, this node must not do the acquire
 814   // operation.
 815   bool followed_by_acquire(const Node *n);
 816 %}
 817 
 818 source %{
 819 
 820 // Should the Matcher clone shifts on addressing modes, expecting them
 821 // to be subsumed into complex addressing expressions or compute them
 822 // into registers?
 823 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 824   return clone_base_plus_offset_address(m, mstack, address_visited);
 825 }
 826 
 827 void Compile::reshape_address(AddPNode* addp) {
 828 }
 829 
 830 // Optimize load-acquire.
 831 //
 832 // Check if acquire is unnecessary due to following operation that does
 833 // acquire anyways.
 834 // Walk the pattern:
 835 //
 836 //      n: Load.acq
 837 //           |
 838 //      MemBarAcquire
 839 //       |         |
 840 //  Proj(ctrl)  Proj(mem)
 841 //       |         |
 842 //   MemBarRelease/Volatile
 843 //
 844 bool followed_by_acquire(const Node *load) {
 845   assert(load-&gt;is_Load(), "So far implemented only for loads.");
 846 
 847   // Find MemBarAcquire.
 848   const Node *mba = NULL;
 849   for (DUIterator_Fast imax, i = load-&gt;fast_outs(imax); i &lt; imax; i++) {
 850     const Node *out = load-&gt;fast_out(i);
 851     if (out-&gt;Opcode() == Op_MemBarAcquire) {
 852       if (out-&gt;in(0) == load) continue; // Skip control edge, membar should be found via precedence edge.
 853       mba = out;
 854       break;
 855     }
 856   }
 857   if (!mba) return false;
 858 
 859   // Find following MemBar node.
 860   //
 861   // The following node must be reachable by control AND memory
 862   // edge to assure no other operations are in between the two nodes.
 863   //
 864   // So first get the Proj node, mem_proj, to use it to iterate forward.
 865   Node *mem_proj = NULL;
 866   for (DUIterator_Fast imax, i = mba-&gt;fast_outs(imax); i &lt; imax; i++) {
 867     mem_proj = mba-&gt;fast_out(i);      // Throw out-of-bounds if proj not found
 868     assert(mem_proj-&gt;is_Proj(), "only projections here");
 869     ProjNode *proj = mem_proj-&gt;as_Proj();
 870     if (proj-&gt;_con == TypeFunc::Memory &amp;&amp;
 871         !Compile::current()-&gt;node_arena()-&gt;contains(mem_proj)) // Unmatched old-space only
 872       break;
 873   }
 874   assert(mem_proj-&gt;as_Proj()-&gt;_con == TypeFunc::Memory, "Graph broken");
 875 
 876   // Search MemBar behind Proj. If there are other memory operations
 877   // behind the Proj we lost.
 878   for (DUIterator_Fast jmax, j = mem_proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 879     Node *x = mem_proj-&gt;fast_out(j);
 880     // Proj might have an edge to a store or load node which precedes the membar.
 881     if (x-&gt;is_Mem()) return false;
 882 
 883     // On PPC64 release and volatile are implemented by an instruction
 884     // that also has acquire semantics. I.e. there is no need for an
 885     // acquire before these.
 886     int xop = x-&gt;Opcode();
 887     if (xop == Op_MemBarRelease || xop == Op_MemBarVolatile) {
 888       // Make sure we're not missing Call/Phi/MergeMem by checking
 889       // control edges. The control edge must directly lead back
 890       // to the MemBarAcquire
 891       Node *ctrl_proj = x-&gt;in(0);
 892       if (ctrl_proj-&gt;is_Proj() &amp;&amp; ctrl_proj-&gt;in(0) == mba) {
 893         return true;
 894       }
 895     }
 896   }
 897 
 898   return false;
 899 }
 900 
 901 #define __ _masm.
 902 
 903 // Tertiary op of a LoadP or StoreP encoding.
 904 #define REGP_OP true
 905 
 906 // ****************************************************************************
 907 
 908 // REQUIRED FUNCTIONALITY
 909 
 910 // !!!!! Special hack to get all type of calls to specify the byte offset
 911 //       from the start of the call to the point where the return address
 912 //       will point.
 913 
 914 // PPC port: Removed use of lazy constant construct.
 915 
 916 int MachCallStaticJavaNode::ret_addr_offset() {
 917   // It's only a single branch-and-link instruction.
 918   return 4;
 919 }
 920 
 921 int MachCallDynamicJavaNode::ret_addr_offset() {
 922   // Offset is 4 with postalloc expanded calls (bl is one instruction). We use
 923   // postalloc expanded calls if we use inline caches and do not update method data.
 924   if (UseInlineCaches)
 925     return 4;
 926 
 927   int vtable_index = this-&gt;_vtable_index;
 928   if (vtable_index &lt; 0) {
 929     // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 930     assert(vtable_index == Method::invalid_vtable_index, "correct sentinel value");
 931     return 12;
 932   } else {
 933     assert(!UseInlineCaches, "expect vtable calls only if not using ICs");
 934     return 24;
 935   }
 936 }
 937 
 938 int MachCallRuntimeNode::ret_addr_offset() {
 939 #if defined(ABI_ELFv2)
 940   return 28;
 941 #else
 942   return 40;
 943 #endif
 944 }
 945 
 946 //=============================================================================
 947 
 948 // condition code conversions
 949 
 950 static int cc_to_boint(int cc) {
 951   return Assembler::bcondCRbiIs0 | (cc &amp; 8);
 952 }
 953 
 954 static int cc_to_inverse_boint(int cc) {
 955   return Assembler::bcondCRbiIs0 | (8-(cc &amp; 8));
 956 }
 957 
 958 static int cc_to_biint(int cc, int flags_reg) {
 959   return (flags_reg &lt;&lt; 2) | (cc &amp; 3);
 960 }
 961 
 962 //=============================================================================
 963 
 964 // Compute padding required for nodes which need alignment. The padding
 965 // is the number of bytes (not instructions) which will be inserted before
 966 // the instruction. The padding must match the size of a NOP instruction.
 967 
 968 // Currently not used on this platform.
 969 
 970 //=============================================================================
 971 
 972 // Indicate if the safepoint node needs the polling page as an input.
 973 bool SafePointNode::needs_polling_address_input() {
 974   // The address is loaded from thread by a seperate node.
 975   return true;
 976 }
 977 
 978 //=============================================================================
 979 
 980 // Emit an interrupt that is caught by the debugger (for debugging compiler).
 981 void emit_break(CodeBuffer &amp;cbuf) {
 982   MacroAssembler _masm(&amp;cbuf);
 983   __ illtrap();
 984 }
 985 
 986 #ifndef PRODUCT
 987 void MachBreakpointNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 988   st-&gt;print("BREAKPOINT");
 989 }
 990 #endif
 991 
 992 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 993   emit_break(cbuf);
 994 }
 995 
 996 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
 997   return MachNode::size(ra_);
 998 }
 999 
1000 //=============================================================================
1001 
1002 void emit_nop(CodeBuffer &amp;cbuf) {
1003   MacroAssembler _masm(&amp;cbuf);
1004   __ nop();
1005 }
1006 
1007 static inline void emit_long(CodeBuffer &amp;cbuf, int value) {
1008   *((int*)(cbuf.insts_end())) = value;
1009   cbuf.set_insts_end(cbuf.insts_end() + BytesPerInstWord);
1010 }
1011 
1012 //=============================================================================
1013 
1014 %} // interrupt source
1015 
1016 source_hpp %{ // Header information of the source block.
1017 
1018 //--------------------------------------------------------------
1019 //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
1020 //--------------------------------------------------------------
1021 
1022 class CallStubImpl {
1023 
1024  public:
1025 
1026   // Emit call stub, compiled java to interpreter.
1027   static void emit_trampoline_stub(MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset);
1028 
1029   // Size of call trampoline stub.
1030   // This doesn't need to be accurate to the byte, but it
1031   // must be larger than or equal to the real size of the stub.
1032   static uint size_call_trampoline() {
1033     return MacroAssembler::trampoline_stub_size;
1034   }
1035 
1036   // number of relocations needed by a call trampoline stub
1037   static uint reloc_call_trampoline() {
1038     return 5;
1039   }
1040 
1041 };
1042 
1043 %} // end source_hpp
1044 
1045 source %{
1046 
1047 // Emit a trampoline stub for a call to a target which is too far away.
1048 //
1049 // code sequences:
1050 //
1051 // call-site:
1052 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
1053 //
1054 // Related trampoline stub for this call-site in the stub section:
1055 //   load the call target from the constant pool
1056 //   branch via CTR (LR/link still points to the call-site above)
1057 
1058 void CallStubImpl::emit_trampoline_stub(MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset) {
1059   address stub = __ emit_trampoline_stub(destination_toc_offset, insts_call_instruction_offset);
1060   if (stub == NULL) {
1061     ciEnv::current()-&gt;record_out_of_memory_failure();
1062   }
1063 }
1064 
1065 //=============================================================================
1066 
1067 // Emit an inline branch-and-link call and a related trampoline stub.
1068 //
1069 // code sequences:
1070 //
1071 // call-site:
1072 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
1073 //
1074 // Related trampoline stub for this call-site in the stub section:
1075 //   load the call target from the constant pool
1076 //   branch via CTR (LR/link still points to the call-site above)
1077 //
1078 
1079 typedef struct {
1080   int insts_call_instruction_offset;
1081   int ret_addr_offset;
1082 } EmitCallOffsets;
1083 
1084 // Emit a branch-and-link instruction that branches to a trampoline.
1085 // - Remember the offset of the branch-and-link instruction.
1086 // - Add a relocation at the branch-and-link instruction.
1087 // - Emit a branch-and-link.
1088 // - Remember the return pc offset.
1089 EmitCallOffsets emit_call_with_trampoline_stub(MacroAssembler &amp;_masm, address entry_point, relocInfo::relocType rtype) {
1090   EmitCallOffsets offsets = { -1, -1 };
1091   const int start_offset = __ offset();
1092   offsets.insts_call_instruction_offset = __ offset();
1093 
1094   // No entry point given, use the current pc.
1095   if (entry_point == NULL) entry_point = __ pc();
1096 
1097   // Put the entry point as a constant into the constant pool.
1098   const address entry_point_toc_addr   = __ address_constant(entry_point, RelocationHolder::none);
1099   if (entry_point_toc_addr == NULL) {
1100     ciEnv::current()-&gt;record_out_of_memory_failure();
1101     return offsets;
1102   }
1103   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
1104   
1105   // Emit the trampoline stub which will be related to the branch-and-link below.
1106   CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, offsets.insts_call_instruction_offset);
1107   if (ciEnv::current()-&gt;failing()) { return offsets; } // Code cache may be full.
1108   __ relocate(rtype);
1109   
1110   // Note: At this point we do not have the address of the trampoline
1111   // stub, and the entry point might be too far away for bl, so __ pc()
1112   // serves as dummy and the bl will be patched later.
1113   __ bl((address) __ pc());
1114 
1115   offsets.ret_addr_offset = __ offset() - start_offset;
1116 
1117   return offsets;
1118 }
1119 
1120 //=============================================================================
1121 
1122 // Factory for creating loadConL* nodes for large/small constant pool.
1123 
1124 static inline jlong replicate_immF(float con) {
1125   // Replicate float con 2 times and pack into vector.
1126   int val = *((int*)&amp;con);
1127   jlong lval = val;
1128   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
1129   return lval;
1130 }
1131 
1132 //=============================================================================
1133 
1134 const RegMask&amp; MachConstantBaseNode::_out_RegMask = BITS64_CONSTANT_TABLE_BASE_mask();
1135 int Compile::ConstantTable::calculate_table_base_offset() const {
1136   return 0;  // absolute addressing, no offset
1137 }
1138 
1139 bool MachConstantBaseNode::requires_postalloc_expand() const { return true; }
1140 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
1141   iRegPdstOper *op_dst = new iRegPdstOper();
1142   MachNode *m1 = new loadToc_hiNode();
1143   MachNode *m2 = new loadToc_loNode();
1144 
1145   m1-&gt;add_req(NULL);
1146   m2-&gt;add_req(NULL, m1);
1147   m1-&gt;_opnds[0] = op_dst;
1148   m2-&gt;_opnds[0] = op_dst;
1149   m2-&gt;_opnds[1] = op_dst;
1150   ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
1151   ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
1152   nodes-&gt;push(m1);
1153   nodes-&gt;push(m2);
1154 }
1155 
1156 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
1157   // Is postalloc expanded.
1158   ShouldNotReachHere();
1159 }
1160 
1161 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
1162   return 0;
1163 }
1164 
1165 #ifndef PRODUCT
1166 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
1167   st-&gt;print("-- \t// MachConstantBaseNode (empty encoding)");
1168 }
1169 #endif
1170 
1171 //=============================================================================
1172 
1173 #ifndef PRODUCT
1174 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1175   Compile* C = ra_-&gt;C;
1176   const long framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
1177 
1178   st-&gt;print("PROLOG\n\t");
1179   if (C-&gt;need_stack_bang(framesize)) {
1180     st-&gt;print("stack_overflow_check\n\t");
1181   }
1182 
1183   if (!false /* TODO: PPC port C-&gt;is_frameless_method()*/) {
1184     st-&gt;print("save return pc\n\t");
1185     st-&gt;print("push frame %ld\n\t", -framesize);
1186   }
1187 }
1188 #endif
1189 
1190 // Macro used instead of the common __ to emulate the pipes of PPC.
1191 // Instead of e.g. __ ld(...) one hase to write ___(ld) ld(...) This enables the
1192 // micro scheduler to cope with "hand written" assembler like in the prolog. Though
1193 // still no scheduling of this code is possible, the micro scheduler is aware of the
1194 // code and can update its internal data. The following mechanism is used to achieve this:
1195 // The micro scheduler calls size() of each compound node during scheduling. size() does a
1196 // dummy emit and only during this dummy emit C-&gt;hb_scheduling() is not NULL.
1197 #if 0 // TODO: PPC port
1198 #define ___(op) if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
1199                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(ppc64Opcode_##op); \
1200                 _masm.
1201 #define ___stop if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
1202                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(archOpcode_none)
1203 #define ___advance if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                 \
1204                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;advance_offset
1205 #else
1206 #define ___(op) if (UsePower6SchedulerPPC64)                                          \
1207                   Unimplemented();                                                    \
1208                 _masm.
1209 #define ___stop if (UsePower6SchedulerPPC64)                                          \
1210                   Unimplemented()
1211 #define ___advance if (UsePower6SchedulerPPC64)                                       \
1212                   Unimplemented()
1213 #endif
1214 
1215 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1216   Compile* C = ra_-&gt;C;
1217   MacroAssembler _masm(&amp;cbuf);
1218 
1219   const long framesize = C-&gt;frame_size_in_bytes();
1220   assert(framesize % (2 * wordSize) == 0, "must preserve 2*wordSize alignment");
1221 
1222   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
1223 
1224   const Register return_pc            = R20; // Must match return_addr() in frame section.
1225   const Register callers_sp           = R21;
1226   const Register push_frame_temp      = R22;
1227   const Register toc_temp             = R23;
1228   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
1229 
1230   if (method_is_frameless) {
1231     // Add nop at beginning of all frameless methods to prevent any
1232     // oop instructions from getting overwritten by make_not_entrant
1233     // (patching attempt would fail).
1234     ___(nop) nop();
1235   } else {
1236     // Get return pc.
1237     ___(mflr) mflr(return_pc);
1238   }
1239 
1240   // Calls to C2R adapters often do not accept exceptional returns.
1241   // We require that their callers must bang for them. But be
1242   // careful, because some VM calls (such as call site linkage) can
1243   // use several kilobytes of stack. But the stack safety zone should
1244   // account for that. See bugs 4446381, 4468289, 4497237.
1245 
1246   int bangsize = C-&gt;bang_size_in_bytes();
1247   assert(bangsize &gt;= framesize || bangsize &lt;= 0, "stack bang size incorrect");
1248   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
1249     // Unfortunately we cannot use the function provided in
1250     // assembler.cpp as we have to emulate the pipes. So I had to
1251     // insert the code of generate_stack_overflow_check(), see
1252     // assembler.cpp for some illuminative comments.
1253     const int page_size = os::vm_page_size();
1254     int bang_end = JavaThread::stack_shadow_zone_size();
1255 
1256     // This is how far the previous frame's stack banging extended.
1257     const int bang_end_safe = bang_end;
1258 
1259     if (bangsize &gt; page_size) {
1260       bang_end += bangsize;
1261     }
1262 
1263     int bang_offset = bang_end_safe;
1264 
1265     while (bang_offset &lt;= bang_end) {
1266       // Need at least one stack bang at end of shadow zone.
1267 
1268       // Again I had to copy code, this time from assembler_ppc.cpp,
1269       // bang_stack_with_offset - see there for comments.
1270 
1271       // Stack grows down, caller passes positive offset.
1272       assert(bang_offset &gt; 0, "must bang with positive offset");
1273 
1274       long stdoffset = -bang_offset;
1275 
1276       if (Assembler::is_simm(stdoffset, 16)) {
1277         // Signed 16 bit offset, a simple std is ok.
1278         if (UseLoadInstructionsForStackBangingPPC64) {
1279           ___(ld) ld(R0,  (int)(signed short)stdoffset, R1_SP);
1280         } else {
1281           ___(std) std(R0, (int)(signed short)stdoffset, R1_SP);
1282         }
1283       } else if (Assembler::is_simm(stdoffset, 31)) {
1284         // Use largeoffset calculations for addis &amp; ld/std.
1285         const int hi = MacroAssembler::largeoffset_si16_si16_hi(stdoffset);
1286         const int lo = MacroAssembler::largeoffset_si16_si16_lo(stdoffset);
1287 
1288         Register tmp = R11;
1289         ___(addis) addis(tmp, R1_SP, hi);
1290         if (UseLoadInstructionsForStackBangingPPC64) {
1291           ___(ld) ld(R0, lo, tmp);
1292         } else {
1293           ___(std) std(R0, lo, tmp);
1294         }
1295       } else {
1296         ShouldNotReachHere();
1297       }
1298 
1299       bang_offset += page_size;
1300     }
1301     // R11 trashed
1302   } // C-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging
1303 
1304   unsigned int bytes = (unsigned int)framesize;
1305   long offset = Assembler::align_addr(bytes, frame::alignment_in_bytes);
1306   ciMethod *currMethod = C-&gt;method();
1307 
1308   // Optimized version for most common case.
1309   if (UsePower6SchedulerPPC64 &amp;&amp;
1310       !method_is_frameless &amp;&amp; Assembler::is_simm((int)(-offset), 16) &amp;&amp;
1311       !(false /* ConstantsALot TODO: PPC port*/)) {
1312     ___(or) mr(callers_sp, R1_SP);
1313     ___(std) std(return_pc, _abi(lr), R1_SP);
1314     ___(stdu) stdu(R1_SP, -offset, R1_SP);
1315     return;
1316   }
1317 
1318   if (!method_is_frameless) {
1319     // Get callers sp.
1320     ___(or) mr(callers_sp, R1_SP);
1321 
1322     // Push method's frame, modifies SP.
1323     assert(Assembler::is_uimm(framesize, 32U), "wrong type");
1324     // The ABI is already accounted for in 'framesize' via the
1325     // 'out_preserve' area.
1326     Register tmp = push_frame_temp;
1327     // Had to insert code of push_frame((unsigned int)framesize, push_frame_temp).
1328     if (Assembler::is_simm(-offset, 16)) {
1329       ___(stdu) stdu(R1_SP, -offset, R1_SP);
1330     } else {
1331       long x = -offset;
1332       // Had to insert load_const(tmp, -offset).
1333       ___(addis)  lis( tmp, (int)((signed short)(((x &gt;&gt; 32) &amp; 0xffff0000) &gt;&gt; 16)));
1334       ___(ori)    ori( tmp, tmp, ((x &gt;&gt; 32) &amp; 0x0000ffff));
1335       ___(rldicr) sldi(tmp, tmp, 32);
1336       ___(oris)   oris(tmp, tmp, (x &amp; 0xffff0000) &gt;&gt; 16);
1337       ___(ori)    ori( tmp, tmp, (x &amp; 0x0000ffff));
1338 
1339       ___(stdux) stdux(R1_SP, R1_SP, tmp);
1340     }
1341   }
1342 #if 0 // TODO: PPC port
1343   // For testing large constant pools, emit a lot of constants to constant pool.
1344   // "Randomize" const_size.
1345   if (ConstantsALot) {
1346     const int num_consts = const_size();
1347     for (int i = 0; i &lt; num_consts; i++) {
1348       __ long_constant(0xB0B5B00BBABE);
1349     }
1350   }
1351 #endif
1352   if (!method_is_frameless) {
1353     // Save return pc.
1354     ___(std) std(return_pc, _abi(lr), callers_sp);
1355   }
1356   
1357   C-&gt;set_frame_complete(cbuf.insts_size());
1358 }
1359 #undef ___
1360 #undef ___stop
1361 #undef ___advance
1362 
1363 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
1364   // Variable size. determine dynamically.
1365   return MachNode::size(ra_);
1366 }
1367 
1368 int MachPrologNode::reloc() const {
1369   // Return number of relocatable values contained in this instruction.
1370   return 1; // 1 reloc entry for load_const(toc).
1371 }
1372 
1373 //=============================================================================
1374 
1375 #ifndef PRODUCT
1376 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1377   Compile* C = ra_-&gt;C;
1378 
1379   st-&gt;print("EPILOG\n\t");
1380   st-&gt;print("restore return pc\n\t");
1381   st-&gt;print("pop frame\n\t");
1382 
1383   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
1384     st-&gt;print("touch polling page\n\t");
1385   }
1386 }
1387 #endif
1388 
1389 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1390   Compile* C = ra_-&gt;C;
1391   MacroAssembler _masm(&amp;cbuf);
1392 
1393   const long framesize = ((long)C-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;
1394   assert(framesize &gt;= 0, "negative frame-size?");
1395 
1396   const bool method_needs_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
1397   const bool method_is_frameless  = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
1398   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
1399   const Register polling_page     = R12;
1400 
1401   if (!method_is_frameless) {
1402     // Restore return pc relative to callers' sp.
1403     __ ld(return_pc, ((int)framesize) + _abi(lr), R1_SP);
1404   }
1405 
1406   if (method_needs_polling) {
1407     if (LoadPollAddressFromThread) {
1408       // TODO: PPC port __ ld(polling_page, in_bytes(JavaThread::poll_address_offset()), R16_thread);
1409       Unimplemented();
1410     } else {
1411       __ load_const_optimized(polling_page, (long)(address) os::get_polling_page()); // TODO: PPC port: get_standard_polling_page()
1412     }
1413   }
1414 
1415   if (!method_is_frameless) {
1416     // Move return pc to LR.
1417     __ mtlr(return_pc);
1418     // Pop frame (fixed frame-size).
1419     __ addi(R1_SP, R1_SP, (int)framesize);
1420   }
1421 
1422   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
1423     __ reserved_stack_check(return_pc);
1424   }
1425 
1426   if (method_needs_polling) {
1427     // We need to mark the code position where the load from the safepoint
1428     // polling page was emitted as relocInfo::poll_return_type here.
1429     __ relocate(relocInfo::poll_return_type);
1430     __ load_from_polling_page(polling_page);
1431   }
1432 }
1433 
1434 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
1435   // Variable size. Determine dynamically.
1436   return MachNode::size(ra_);
1437 }
1438 
1439 int MachEpilogNode::reloc() const {
1440   // Return number of relocatable values contained in this instruction.
1441   return 1; // 1 for load_from_polling_page.
1442 }
1443 
1444 const Pipeline * MachEpilogNode::pipeline() const {
1445   return MachNode::pipeline_class();
1446 }
1447 
1448 // This method seems to be obsolete. It is declared in machnode.hpp
1449 // and defined in all *.ad files, but it is never called. Should we
1450 // get rid of it?
1451 int MachEpilogNode::safepoint_offset() const {
1452   assert(do_polling(), "no return for this epilog node");
1453   return 0;
1454 }
1455 
1456 #if 0 // TODO: PPC port
1457 void MachLoadPollAddrLateNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
1458   MacroAssembler _masm(&amp;cbuf);
1459   if (LoadPollAddressFromThread) {
1460     _masm.ld(R11, in_bytes(JavaThread::poll_address_offset()), R16_thread);
1461   } else {
1462     _masm.nop();
1463   }
1464 }
1465 
1466 uint MachLoadPollAddrLateNode::size(PhaseRegAlloc* ra_) const {
1467   if (LoadPollAddressFromThread) {
1468     return 4;
1469   } else {
1470     return 4;
1471   }
1472 }
1473 
1474 #ifndef PRODUCT
1475 void MachLoadPollAddrLateNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
1476   st-&gt;print_cr(" LD R11, PollAddressOffset, R16_thread \t// LoadPollAddressFromThread");
1477 }
1478 #endif
1479 
1480 const RegMask &amp;MachLoadPollAddrLateNode::out_RegMask() const {
1481   return RSCRATCH1_BITS64_REG_mask();
1482 }
1483 #endif // PPC port
1484 
1485 // =============================================================================
1486 
1487 // Figure out which register class each belongs in: rc_int, rc_float or
1488 // rc_stack.
1489 enum RC { rc_bad, rc_int, rc_float, rc_stack };
1490 
1491 static enum RC rc_class(OptoReg::Name reg) {
1492   // Return the register class for the given register. The given register
1493   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
1494   // enumeration in adGlobals_ppc.hpp.
1495 
1496   if (reg == OptoReg::Bad) return rc_bad;
1497 
1498   // We have 64 integer register halves, starting at index 0.
1499   if (reg &lt; 64) return rc_int;
1500 
1501   // We have 64 floating-point register halves, starting at index 64.
1502   if (reg &lt; 64+64) return rc_float;
1503 
1504   // Between float regs &amp; stack are the flags regs.
1505   assert(OptoReg::is_stack(reg), "blow up if spilling flags");
1506 
1507   return rc_stack;
1508 }
1509 
1510 static int ld_st_helper(CodeBuffer *cbuf, const char *op_str, uint opcode, int reg, int offset,
1511                         bool do_print, Compile* C, outputStream *st) {
1512 
1513   assert(opcode == Assembler::LD_OPCODE   ||
1514          opcode == Assembler::STD_OPCODE  ||
1515          opcode == Assembler::LWZ_OPCODE  ||
1516          opcode == Assembler::STW_OPCODE  ||
1517          opcode == Assembler::LFD_OPCODE  ||
1518          opcode == Assembler::STFD_OPCODE ||
1519          opcode == Assembler::LFS_OPCODE  ||
1520          opcode == Assembler::STFS_OPCODE,
1521          "opcode not supported");
1522 
1523   if (cbuf) {
1524     int d =
1525       (Assembler::LD_OPCODE == opcode || Assembler::STD_OPCODE == opcode) ?
1526         Assembler::ds(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/)
1527       : Assembler::d1(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/); // Makes no difference in opt build.
1528     emit_long(*cbuf, opcode | Assembler::rt(Matcher::_regEncode[reg]) | d | Assembler::ra(R1_SP));
1529   }
1530 #ifndef PRODUCT
1531   else if (do_print) {
1532     st-&gt;print("%-7s %s, [R1_SP + #%d+%d] \t// spill copy",
1533               op_str,
1534               Matcher::regName[reg],
1535               offset, 0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/);
1536   }
1537 #endif
1538   return 4; // size
1539 }
1540 
1541 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {
1542   Compile* C = ra_-&gt;C;
1543 
1544   // Get registers to move.
1545   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
1546   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
1547   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
1548   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
1549 
1550   enum RC src_hi_rc = rc_class(src_hi);
1551   enum RC src_lo_rc = rc_class(src_lo);
1552   enum RC dst_hi_rc = rc_class(dst_hi);
1553   enum RC dst_lo_rc = rc_class(dst_lo);
1554 
1555   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, "must move at least 1 register");
1556   if (src_hi != OptoReg::Bad)
1557     assert((src_lo&amp;1)==0 &amp;&amp; src_lo+1==src_hi &amp;&amp;
1558            (dst_lo&amp;1)==0 &amp;&amp; dst_lo+1==dst_hi,
1559            "expected aligned-adjacent pairs");
1560   // Generate spill code!
1561   int size = 0;
1562 
1563   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
1564     return size;            // Self copy, no move.
1565 
1566   // --------------------------------------
1567   // Memory-&gt;Memory Spill. Use R0 to hold the value.
1568   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
1569     int src_offset = ra_-&gt;reg2offset(src_lo);
1570     int dst_offset = ra_-&gt;reg2offset(dst_lo);
1571     if (src_hi != OptoReg::Bad) {
1572       assert(src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack,
1573              "expected same type of move for high parts");
1574       size += ld_st_helper(cbuf, "LD  ", Assembler::LD_OPCODE,  R0_num, src_offset, !do_size, C, st);
1575       if (!cbuf &amp;&amp; !do_size) st-&gt;print("\n\t");
1576       size += ld_st_helper(cbuf, "STD ", Assembler::STD_OPCODE, R0_num, dst_offset, !do_size, C, st);
1577     } else {
1578       size += ld_st_helper(cbuf, "LWZ ", Assembler::LWZ_OPCODE, R0_num, src_offset, !do_size, C, st);
1579       if (!cbuf &amp;&amp; !do_size) st-&gt;print("\n\t");
1580       size += ld_st_helper(cbuf, "STW ", Assembler::STW_OPCODE, R0_num, dst_offset, !do_size, C, st);
1581     }
1582     return size;
1583   }
1584 
1585   // --------------------------------------
1586   // Check for float-&gt;int copy; requires a trip through memory.
1587   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
1588     Unimplemented();
1589   }
1590 
1591   // --------------------------------------
1592   // Check for integer reg-reg copy.
1593   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
1594       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
1595       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
1596       size = (Rsrc != Rdst) ? 4 : 0;
1597 
1598       if (cbuf) {
1599         MacroAssembler _masm(cbuf);
1600         if (size) {
1601           __ mr(Rdst, Rsrc);
1602         }
1603       }
1604 #ifndef PRODUCT
1605       else if (!do_size) {
1606         if (size) {
1607           st-&gt;print("%-7s %s, %s \t// spill copy", "MR", Matcher::regName[dst_lo], Matcher::regName[src_lo]);
1608         } else {
1609           st-&gt;print("%-7s %s, %s \t// spill copy", "MR-NOP", Matcher::regName[dst_lo], Matcher::regName[src_lo]);
1610         }
1611       }
1612 #endif
1613       return size;
1614   }
1615 
1616   // Check for integer store.
1617   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
1618     int dst_offset = ra_-&gt;reg2offset(dst_lo);
1619     if (src_hi != OptoReg::Bad) {
1620       assert(src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack,
1621              "expected same type of move for high parts");
1622       size += ld_st_helper(cbuf, "STD ", Assembler::STD_OPCODE, src_lo, dst_offset, !do_size, C, st);
1623     } else {
1624       size += ld_st_helper(cbuf, "STW ", Assembler::STW_OPCODE, src_lo, dst_offset, !do_size, C, st);
1625     }
1626     return size;
1627   }
1628 
1629   // Check for integer load.
1630   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
1631     int src_offset = ra_-&gt;reg2offset(src_lo);
1632     if (src_hi != OptoReg::Bad) {
1633       assert(dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack,
1634              "expected same type of move for high parts");
1635       size += ld_st_helper(cbuf, "LD  ", Assembler::LD_OPCODE, dst_lo, src_offset, !do_size, C, st);
1636     } else {
1637       size += ld_st_helper(cbuf, "LWZ ", Assembler::LWZ_OPCODE, dst_lo, src_offset, !do_size, C, st);
1638     }
1639     return size;
1640   }
1641 
1642   // Check for float reg-reg copy.
1643   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
1644     if (cbuf) {
1645       MacroAssembler _masm(cbuf);
1646       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
1647       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
1648       __ fmr(Rdst, Rsrc);
1649     }
1650 #ifndef PRODUCT
1651     else if (!do_size) {
1652       st-&gt;print("%-7s %s, %s \t// spill copy", "FMR", Matcher::regName[dst_lo], Matcher::regName[src_lo]);
1653     }
1654 #endif
1655     return 4;
1656   }
1657 
1658   // Check for float store.
1659   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
1660     int dst_offset = ra_-&gt;reg2offset(dst_lo);
1661     if (src_hi != OptoReg::Bad) {
1662       assert(src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack,
1663              "expected same type of move for high parts");
1664       size += ld_st_helper(cbuf, "STFD", Assembler::STFD_OPCODE, src_lo, dst_offset, !do_size, C, st);
1665     } else {
1666       size += ld_st_helper(cbuf, "STFS", Assembler::STFS_OPCODE, src_lo, dst_offset, !do_size, C, st);
1667     }
1668     return size;
1669   }
1670 
1671   // Check for float load.
1672   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
1673     int src_offset = ra_-&gt;reg2offset(src_lo);
1674     if (src_hi != OptoReg::Bad) {
1675       assert(dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack,
1676              "expected same type of move for high parts");
1677       size += ld_st_helper(cbuf, "LFD ", Assembler::LFD_OPCODE, dst_lo, src_offset, !do_size, C, st);
1678     } else {
1679       size += ld_st_helper(cbuf, "LFS ", Assembler::LFS_OPCODE, dst_lo, src_offset, !do_size, C, st);
1680     }
1681     return size;
1682   }
1683 
1684   // --------------------------------------------------------------------
1685   // Check for hi bits still needing moving. Only happens for misaligned
1686   // arguments to native calls.
1687   if (src_hi == dst_hi)
1688     return size;               // Self copy; no move.
1689 
1690   assert(src_hi_rc != rc_bad &amp;&amp; dst_hi_rc != rc_bad, "src_hi &amp; dst_hi cannot be Bad");
1691   ShouldNotReachHere(); // Unimplemented
1692   return 0;
1693 }
1694 
1695 #ifndef PRODUCT
1696 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1697   if (!ra_)
1698     st-&gt;print("N%d = SpillCopy(N%d)", _idx, in(1)-&gt;_idx);
1699   else
1700     implementation(NULL, ra_, false, st);
1701 }
1702 #endif
1703 
1704 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1705   implementation(&amp;cbuf, ra_, false, NULL);
1706 }
1707 
1708 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
1709   return implementation(NULL, ra_, true, NULL);
1710 }
1711 
1712 #if 0 // TODO: PPC port
1713 ArchOpcode MachSpillCopyNode_archOpcode(MachSpillCopyNode *n, PhaseRegAlloc *ra_) {
1714 #ifndef PRODUCT
1715   if (ra_-&gt;node_regs_max_index() == 0) return archOpcode_undefined;
1716 #endif
1717   assert(ra_-&gt;node_regs_max_index() != 0, "");
1718 
1719   // Get registers to move.
1720   OptoReg::Name src_hi = ra_-&gt;get_reg_second(n-&gt;in(1));
1721   OptoReg::Name src_lo = ra_-&gt;get_reg_first(n-&gt;in(1));
1722   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(n);
1723   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(n);
1724 
1725   enum RC src_lo_rc = rc_class(src_lo);
1726   enum RC dst_lo_rc = rc_class(dst_lo);
1727 
1728   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
1729     return ppc64Opcode_none;            // Self copy, no move.
1730 
1731   // --------------------------------------
1732   // Memory-&gt;Memory Spill. Use R0 to hold the value.
1733   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
1734     return ppc64Opcode_compound;
1735   }
1736 
1737   // --------------------------------------
1738   // Check for float-&gt;int copy; requires a trip through memory.
1739   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
1740     Unimplemented();
1741   }
1742 
1743   // --------------------------------------
1744   // Check for integer reg-reg copy.
1745   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
1746     Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
1747     Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
1748     if (Rsrc == Rdst) {
1749       return ppc64Opcode_none;
1750     } else {
1751       return ppc64Opcode_or;
1752     }
1753   }
1754 
1755   // Check for integer store.
1756   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
1757     if (src_hi != OptoReg::Bad) {
1758       return ppc64Opcode_std;
1759     } else {
1760       return ppc64Opcode_stw;
1761     }
1762   }
1763 
1764   // Check for integer load.
1765   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
1766     if (src_hi != OptoReg::Bad) {
1767       return ppc64Opcode_ld;
1768     } else {
1769       return ppc64Opcode_lwz;
1770     }
1771   }
1772 
1773   // Check for float reg-reg copy.
1774   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
1775     return ppc64Opcode_fmr;
1776   }
1777 
1778   // Check for float store.
1779   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
1780     if (src_hi != OptoReg::Bad) {
1781       return ppc64Opcode_stfd;
1782     } else {
1783       return ppc64Opcode_stfs;
1784     }
1785   }
1786 
1787   // Check for float load.
1788   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
1789     if (src_hi != OptoReg::Bad) {
1790       return ppc64Opcode_lfd;
1791     } else {
1792       return ppc64Opcode_lfs;
1793     }
1794   }
1795 
1796   // --------------------------------------------------------------------
1797   // Check for hi bits still needing moving. Only happens for misaligned
1798   // arguments to native calls.
1799   if (src_hi == dst_hi) {
1800     return ppc64Opcode_none;               // Self copy; no move.
1801   }
1802 
1803   ShouldNotReachHere();
1804   return ppc64Opcode_undefined;
1805 }
1806 #endif // PPC port
1807 
1808 #ifndef PRODUCT
1809 void MachNopNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1810   st-&gt;print("NOP \t// %d nops to pad for loops.", _count);
1811 }
1812 #endif
1813 
1814 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
1815   MacroAssembler _masm(&amp;cbuf);
1816   // _count contains the number of nops needed for padding.
1817   for (int i = 0; i &lt; _count; i++) {
1818     __ nop();
1819   }
1820 }
1821 
1822 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
1823   return _count * 4;
1824 }
1825 
1826 #ifndef PRODUCT
1827 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1828   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1829   char reg_str[128];
1830   ra_-&gt;dump_register(this, reg_str);
1831   st-&gt;print("ADDI    %s, SP, %d \t// box node", reg_str, offset);
1832 }
1833 #endif
1834 
1835 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1836   MacroAssembler _masm(&amp;cbuf);
1837 
1838   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1839   int reg    = ra_-&gt;get_encode(this);
1840 
1841   if (Assembler::is_simm(offset, 16)) {
1842     __ addi(as_Register(reg), R1, offset);
1843   } else {
1844     ShouldNotReachHere();
1845   }
1846 }
1847 
1848 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
1849   // BoxLockNode is not a MachNode, so we can't just call MachNode::size(ra_).
1850   return 4;
1851 }
1852 
1853 #ifndef PRODUCT
1854 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1855   st-&gt;print_cr("---- MachUEPNode ----");
1856   st-&gt;print_cr("...");
1857 }
1858 #endif
1859 
1860 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1861   // This is the unverified entry point.
1862   MacroAssembler _masm(&amp;cbuf);
1863 
1864   // Inline_cache contains a klass.
1865   Register ic_klass       = as_Register(Matcher::inline_cache_reg_encode());
1866   Register receiver_klass = R12_scratch2;  // tmp
1867 
1868   assert_different_registers(ic_klass, receiver_klass, R11_scratch1, R3_ARG1);
1869   assert(R11_scratch1 == R11, "need prologue scratch register");
1870 
1871   // Check for NULL argument if we don't have implicit null checks.
1872   if (!ImplicitNullChecks || !os::zero_page_read_protected()) {
1873     if (TrapBasedNullChecks) {
1874       __ trap_null_check(R3_ARG1);
1875     } else {
1876       Label valid;
1877       __ cmpdi(CCR0, R3_ARG1, 0);
1878       __ bne_predict_taken(CCR0, valid);
1879       // We have a null argument, branch to ic_miss_stub.
1880       __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
1881                            relocInfo::runtime_call_type);
1882       __ bind(valid);
1883     }
1884   }
1885   // Assume argument is not NULL, load klass from receiver.
1886   __ load_klass(receiver_klass, R3_ARG1);
1887 
1888   if (TrapBasedICMissChecks) {
1889     __ trap_ic_miss_check(receiver_klass, ic_klass);
1890   } else {
1891     Label valid;
1892     __ cmpd(CCR0, receiver_klass, ic_klass);
1893     __ beq_predict_taken(CCR0, valid);
1894     // We have an unexpected klass, branch to ic_miss_stub.
1895     __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
1896                          relocInfo::runtime_call_type);
1897     __ bind(valid);
1898   }
1899 
1900   // Argument is valid and klass is as expected, continue.
1901 }
1902 
1903 #if 0 // TODO: PPC port
1904 // Optimize UEP code on z (save a load_const() call in main path).
1905 int MachUEPNode::ep_offset() {
1906   return 0;
1907 }
1908 #endif
1909 
1910 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
1911   // Variable size. Determine dynamically.
1912   return MachNode::size(ra_);
1913 }
1914 
1915 //=============================================================================
1916 
1917 %} // interrupt source
1918 
1919 source_hpp %{ // Header information of the source block.
1920 
1921 class HandlerImpl {
1922 
1923  public:
1924 
1925   static int emit_exception_handler(CodeBuffer &amp;cbuf);
1926   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
1927 
1928   static uint size_exception_handler() {
1929     // The exception_handler is a b64_patchable.
1930     return MacroAssembler::b64_patchable_size;
1931   }
1932 
1933   static uint size_deopt_handler() {
1934     // The deopt_handler is a bl64_patchable.
1935     return MacroAssembler::bl64_patchable_size;
1936   }
1937 
1938 };
1939 
1940 %} // end source_hpp
1941 
1942 source %{
1943 
1944 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
1945   MacroAssembler _masm(&amp;cbuf);
1946 
1947   address base = __ start_a_stub(size_exception_handler());
1948   if (base == NULL) return 0; // CodeBuffer::expand failed
1949 
1950   int offset = __ offset();
1951   __ b64_patchable((address)OptoRuntime::exception_blob()-&gt;content_begin(),
1952                        relocInfo::runtime_call_type);
1953   assert(__ offset() - offset == (int)size_exception_handler(), "must be fixed size");
1954   __ end_a_stub();
1955 
1956   return offset;
1957 }
1958 
1959 // The deopt_handler is like the exception handler, but it calls to
1960 // the deoptimization blob instead of jumping to the exception blob.
1961 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
1962   MacroAssembler _masm(&amp;cbuf);
1963 
1964   address base = __ start_a_stub(size_deopt_handler());
1965   if (base == NULL) return 0; // CodeBuffer::expand failed
1966 
1967   int offset = __ offset();
1968   __ bl64_patchable((address)SharedRuntime::deopt_blob()-&gt;unpack(),
1969                         relocInfo::runtime_call_type);
1970   assert(__ offset() - offset == (int) size_deopt_handler(), "must be fixed size");
1971   __ end_a_stub();
1972 
1973   return offset;
1974 }
1975 
1976 //=============================================================================
1977 
1978 // Use a frame slots bias for frameless methods if accessing the stack.
1979 static int frame_slots_bias(int reg_enc, PhaseRegAlloc* ra_) {
1980   if (as_Register(reg_enc) == R1_SP) {
1981     return 0; // TODO: PPC port ra_-&gt;C-&gt;frame_slots_sp_bias_in_bytes();
1982   }
1983   return 0;
1984 }
1985 
1986 const bool Matcher::match_rule_supported(int opcode) {
1987   if (!has_match_rule(opcode))
1988     return false;
1989 
1990   switch (opcode) {
1991   case Op_SqrtD:
1992     return VM_Version::has_fsqrt();
1993   case Op_CountLeadingZerosI:
1994   case Op_CountLeadingZerosL:
1995   case Op_CountTrailingZerosI:
1996   case Op_CountTrailingZerosL:
1997     if (!UseCountLeadingZerosInstructionsPPC64)
1998       return false;
1999     break;
2000 
2001   case Op_PopCountI:
2002   case Op_PopCountL:
2003     return (UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
2004 
2005   case Op_StrComp:
2006     return SpecialStringCompareTo;
2007   case Op_StrEquals:
2008     return SpecialStringEquals;
2009   case Op_StrIndexOf:
2010     return SpecialStringIndexOf;
2011   case Op_StrIndexOfChar:
2012     return SpecialStringIndexOf;
2013   }
2014 
2015   return true;  // Per default match rules are supported.
2016 }
2017 
2018 const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {
2019 
2020   // TODO
2021   // identify extra cases that we might want to provide match rules for
2022   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
2023   bool ret_value = match_rule_supported(opcode);
2024   // Add rules here.
2025 
2026   return ret_value;  // Per default match rules are supported.
2027 }
2028 
2029 const bool Matcher::has_predicated_vectors(void) {
2030   return false;
2031 }
2032 
2033 const int Matcher::float_pressure(int default_pressure_threshold) {
2034   return default_pressure_threshold;
2035 }
2036 
2037 int Matcher::regnum_to_fpu_offset(int regnum) {
2038   // No user for this method?
2039   Unimplemented();
2040   return 999;
2041 }
2042 
2043 const bool Matcher::convL2FSupported(void) {
2044   // fcfids can do the conversion (&gt;= Power7).
2045   // fcfid + frsp showed rounding problem when result should be 0x3f800001.
2046   return VM_Version::has_fcfids(); // False means that conversion is done by runtime call.
2047 }
2048 
2049 // Vector width in bytes.
2050 const int Matcher::vector_width_in_bytes(BasicType bt) {
2051   assert(MaxVectorSize == 8, "");
2052   return 8;
2053 }
2054 
2055 // Vector ideal reg.
2056 const int Matcher::vector_ideal_reg(int size) {
2057   assert(MaxVectorSize == 8 &amp;&amp; size == 8, "");
2058   return Op_RegL;
2059 }
2060 
2061 const int Matcher::vector_shift_count_ideal_reg(int size) {
2062   fatal("vector shift is not supported");
2063   return Node::NotAMachineReg;
2064 }
2065 
2066 // Limits on vector size (number of elements) loaded into vector.
2067 const int Matcher::max_vector_size(const BasicType bt) {
2068   assert(is_java_primitive(bt), "only primitive type vectors");
2069   return vector_width_in_bytes(bt)/type2aelembytes(bt);
2070 }
2071 
2072 const int Matcher::min_vector_size(const BasicType bt) {
2073   return max_vector_size(bt); // Same as max.
2074 }
2075 
2076 // PPC doesn't support misaligned vectors store/load.
2077 const bool Matcher::misaligned_vectors_ok() {
2078   return false;
2079 }
2080 
2081 // PPC AES support not yet implemented
2082 const bool Matcher::pass_original_key_for_aes() {
2083   return false;
2084 }
2085 
2086 // RETURNS: whether this branch offset is short enough that a short
2087 // branch can be used.
2088 //
2089 // If the platform does not provide any short branch variants, then
2090 // this method should return `false' for offset 0.
2091 //
2092 // `Compile::Fill_buffer' will decide on basis of this information
2093 // whether to do the pass `Compile::Shorten_branches' at all.
2094 //
2095 // And `Compile::Shorten_branches' will decide on basis of this
2096 // information whether to replace particular branch sites by short
2097 // ones.
2098 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
2099   // Is the offset within the range of a ppc64 pc relative branch?
2100   bool b;
2101 
2102   const int safety_zone = 3 * BytesPerInstWord;
2103   b = Assembler::is_simm((offset&lt;0 ? offset-safety_zone : offset+safety_zone),
2104                          29 - 16 + 1 + 2);
2105   return b;
2106 }
2107 
2108 const bool Matcher::isSimpleConstant64(jlong value) {
2109   // Probably always true, even if a temp register is required.
2110   return true;
2111 }
2112 /* TODO: PPC port
2113 // Make a new machine dependent decode node (with its operands).
2114 MachTypeNode *Matcher::make_decode_node() {
2115   assert(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0,
2116          "This method is only implemented for unscaled cOops mode so far");
2117   MachTypeNode *decode = new decodeN_unscaledNode();
2118   decode-&gt;set_opnd_array(0, new iRegPdstOper());
2119   decode-&gt;set_opnd_array(1, new iRegNsrcOper());
2120   return decode;
2121 }
2122 */
2123 
2124 // false =&gt; size gets scaled to BytesPerLong, ok.
2125 const bool Matcher::init_array_count_is_in_bytes = false;
2126 
2127 // Use conditional move (CMOVL) on Power7.
2128 const int Matcher::long_cmove_cost() { return 0; } // this only makes long cmoves more expensive than int cmoves
2129 
2130 // Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.
2131 // fsel doesn't accept a condition register as input, so this would be slightly different.
2132 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
2133 
2134 // Power6 requires postalloc expand (see block.cpp for description of postalloc expand).
2135 const bool Matcher::require_postalloc_expand = true;
2136 
2137 // Do we need to mask the count passed to shift instructions or does
2138 // the cpu only look at the lower 5/6 bits anyway?
2139 // PowerPC requires masked shift counts.
2140 const bool Matcher::need_masked_shift_count = true;
2141 
2142 // This affects two different things:
2143 //  - how Decode nodes are matched
2144 //  - how ImplicitNullCheck opportunities are recognized
2145 // If true, the matcher will try to remove all Decodes and match them
2146 // (as operands) into nodes. NullChecks are not prepared to deal with
2147 // Decodes by final_graph_reshaping().
2148 // If false, final_graph_reshaping() forces the decode behind the Cmp
2149 // for a NullCheck. The matcher matches the Decode node into a register.
2150 // Implicit_null_check optimization moves the Decode along with the
2151 // memory operation back up before the NullCheck.
2152 bool Matcher::narrow_oop_use_complex_address() {
2153   // TODO: PPC port if (MatchDecodeNodes) return true;
2154   return false;
2155 }
2156 
2157 bool Matcher::narrow_klass_use_complex_address() {
2158   NOT_LP64(ShouldNotCallThis());
2159   assert(UseCompressedClassPointers, "only for compressed klass code");
2160   // TODO: PPC port if (MatchDecodeNodes) return true;
2161   return false;
2162 }
2163 
2164 bool Matcher::const_oop_prefer_decode() {
2165   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
2166   return Universe::narrow_oop_base() == NULL;
2167 }
2168 
2169 bool Matcher::const_klass_prefer_decode() {
2170   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
2171   return Universe::narrow_klass_base() == NULL;
2172 }
2173 
2174 // Is it better to copy float constants, or load them directly from memory?
2175 // Intel can load a float constant from a direct address, requiring no
2176 // extra registers. Most RISCs will have to materialize an address into a
2177 // register first, so they would do better to copy the constant from stack.
2178 const bool Matcher::rematerialize_float_constants = false;
2179 
2180 // If CPU can load and store mis-aligned doubles directly then no fixup is
2181 // needed. Else we split the double into 2 integer pieces and move it
2182 // piece-by-piece. Only happens when passing doubles into C code as the
2183 // Java calling convention forces doubles to be aligned.
2184 const bool Matcher::misaligned_doubles_ok = true;
2185 
2186 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
2187  Unimplemented();
2188 }
2189 
2190 // Advertise here if the CPU requires explicit rounding operations
2191 // to implement the UseStrictFP mode.
2192 const bool Matcher::strict_fp_requires_explicit_rounding = false;
2193 
2194 // Do floats take an entire double register or just half?
2195 //
2196 // A float occupies a ppc64 double register. For the allocator, a
2197 // ppc64 double register appears as a pair of float registers.
2198 bool Matcher::float_in_double() { return true; }
2199 
2200 // Do ints take an entire long register or just half?
2201 // The relevant question is how the int is callee-saved:
2202 // the whole long is written but de-opt'ing will have to extract
2203 // the relevant 32 bits.
2204 const bool Matcher::int_in_long = true;
2205 
2206 // Constants for c2c and c calling conventions.
2207 
2208 const MachRegisterNumbers iarg_reg[8] = {
2209   R3_num, R4_num, R5_num, R6_num,
2210   R7_num, R8_num, R9_num, R10_num
2211 };
2212 
2213 const MachRegisterNumbers farg_reg[13] = {
2214   F1_num, F2_num, F3_num, F4_num,
2215   F5_num, F6_num, F7_num, F8_num,
2216   F9_num, F10_num, F11_num, F12_num,
2217   F13_num
2218 };
2219 
2220 const int num_iarg_registers = sizeof(iarg_reg) / sizeof(iarg_reg[0]);
2221 
2222 const int num_farg_registers = sizeof(farg_reg) / sizeof(farg_reg[0]);
2223 
2224 // Return whether or not this register is ever used as an argument. This
2225 // function is used on startup to build the trampoline stubs in generateOptoStub.
2226 // Registers not mentioned will be killed by the VM call in the trampoline, and
2227 // arguments in those registers not be available to the callee.
2228 bool Matcher::can_be_java_arg(int reg) {
2229   // We return true for all registers contained in iarg_reg[] and
2230   // farg_reg[] and their virtual halves.
2231   // We must include the virtual halves in order to get STDs and LDs
2232   // instead of STWs and LWs in the trampoline stubs.
2233 
2234   if (   reg == R3_num  || reg == R3_H_num
2235       || reg == R4_num  || reg == R4_H_num
2236       || reg == R5_num  || reg == R5_H_num
2237       || reg == R6_num  || reg == R6_H_num
2238       || reg == R7_num  || reg == R7_H_num
2239       || reg == R8_num  || reg == R8_H_num
2240       || reg == R9_num  || reg == R9_H_num
2241       || reg == R10_num || reg == R10_H_num)
2242     return true;
2243 
2244   if (   reg == F1_num  || reg == F1_H_num
2245       || reg == F2_num  || reg == F2_H_num
2246       || reg == F3_num  || reg == F3_H_num
2247       || reg == F4_num  || reg == F4_H_num
2248       || reg == F5_num  || reg == F5_H_num
2249       || reg == F6_num  || reg == F6_H_num
2250       || reg == F7_num  || reg == F7_H_num
2251       || reg == F8_num  || reg == F8_H_num
2252       || reg == F9_num  || reg == F9_H_num
2253       || reg == F10_num || reg == F10_H_num
2254       || reg == F11_num || reg == F11_H_num
2255       || reg == F12_num || reg == F12_H_num
2256       || reg == F13_num || reg == F13_H_num)
2257     return true;
2258 
2259   return false;
2260 }
2261 
2262 bool Matcher::is_spillable_arg(int reg) {
2263   return can_be_java_arg(reg);
2264 }
2265 
2266 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
2267   return false;
2268 }
2269 
2270 // Register for DIVI projection of divmodI.
2271 RegMask Matcher::divI_proj_mask() {
2272   ShouldNotReachHere();
2273   return RegMask();
2274 }
2275 
2276 // Register for MODI projection of divmodI.
2277 RegMask Matcher::modI_proj_mask() {
2278   ShouldNotReachHere();
2279   return RegMask();
2280 }
2281 
2282 // Register for DIVL projection of divmodL.
2283 RegMask Matcher::divL_proj_mask() {
2284   ShouldNotReachHere();
2285   return RegMask();
2286 }
2287 
2288 // Register for MODL projection of divmodL.
2289 RegMask Matcher::modL_proj_mask() {
2290   ShouldNotReachHere();
2291   return RegMask();
2292 }
2293 
2294 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
2295   return RegMask();
2296 }
2297 
2298 const bool Matcher::convi2l_type_required = true;
2299 
2300 %}
2301 
2302 //----------ENCODING BLOCK-----------------------------------------------------
2303 // This block specifies the encoding classes used by the compiler to output
2304 // byte streams. Encoding classes are parameterized macros used by
2305 // Machine Instruction Nodes in order to generate the bit encoding of the
2306 // instruction. Operands specify their base encoding interface with the
2307 // interface keyword. There are currently supported four interfaces,
2308 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
2309 // operand to generate a function which returns its register number when
2310 // queried. CONST_INTER causes an operand to generate a function which
2311 // returns the value of the constant when queried. MEMORY_INTER causes an
2312 // operand to generate four functions which return the Base Register, the
2313 // Index Register, the Scale Value, and the Offset Value of the operand when
2314 // queried. COND_INTER causes an operand to generate six functions which
2315 // return the encoding code (ie - encoding bits for the instruction)
2316 // associated with each basic boolean condition for a conditional instruction.
2317 //
2318 // Instructions specify two basic values for encoding. Again, a function
2319 // is available to check if the constant displacement is an oop. They use the
2320 // ins_encode keyword to specify their encoding classes (which must be
2321 // a sequence of enc_class names, and their parameters, specified in
2322 // the encoding block), and they use the
2323 // opcode keyword to specify, in order, their primary, secondary, and
2324 // tertiary opcode. Only the opcode sections which a particular instruction
2325 // needs for encoding need to be specified.
2326 encode %{
2327   enc_class enc_unimplemented %{
2328     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2329     MacroAssembler _masm(&amp;cbuf);
2330     __ unimplemented("Unimplemented mach node encoding in AD file.", 13);
2331   %}
2332 
2333   enc_class enc_untested %{
2334 #ifdef ASSERT
2335     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2336     MacroAssembler _masm(&amp;cbuf);
2337     __ untested("Untested mach node encoding in AD file.");
2338 #else
2339     // TODO: PPC port $archOpcode(ppc64Opcode_none);
2340 #endif
2341   %}
2342 
2343   enc_class enc_lbz(iRegIdst dst, memory mem) %{
2344     // TODO: PPC port $archOpcode(ppc64Opcode_lbz);
2345     MacroAssembler _masm(&amp;cbuf);
2346     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2347     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
2348   %}
2349 
2350   // Load acquire.
2351   enc_class enc_lbz_ac(iRegIdst dst, memory mem) %{
2352     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2353     MacroAssembler _masm(&amp;cbuf);
2354     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2355     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
2356     __ twi_0($dst$$Register);
2357     __ isync();
2358   %}
2359 
2360   enc_class enc_lhz(iRegIdst dst, memory mem) %{
2361     // TODO: PPC port $archOpcode(ppc64Opcode_lhz);
2362 
2363     MacroAssembler _masm(&amp;cbuf);
2364     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2365     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
2366   %}
2367 
2368   // Load acquire.
2369   enc_class enc_lhz_ac(iRegIdst dst, memory mem) %{
2370     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2371 
2372     MacroAssembler _masm(&amp;cbuf);
2373     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2374     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
2375     __ twi_0($dst$$Register);
2376     __ isync();
2377   %}
2378 
2379   enc_class enc_lwz(iRegIdst dst, memory mem) %{
2380     // TODO: PPC port $archOpcode(ppc64Opcode_lwz);
2381 
2382     MacroAssembler _masm(&amp;cbuf);
2383     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2384     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
2385   %}
2386 
2387   // Load acquire.
2388   enc_class enc_lwz_ac(iRegIdst dst, memory mem) %{
2389     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2390 
2391     MacroAssembler _masm(&amp;cbuf);
2392     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2393     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
2394     __ twi_0($dst$$Register);
2395     __ isync();
2396   %}
2397 
2398   enc_class enc_ld(iRegLdst dst, memoryAlg4 mem) %{
2399     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
2400     MacroAssembler _masm(&amp;cbuf);
2401     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2402     // Operand 'ds' requires 4-alignment.
2403     assert((Idisp &amp; 0x3) == 0, "unaligned offset");
2404     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
2405   %}
2406 
2407   // Load acquire.
2408   enc_class enc_ld_ac(iRegLdst dst, memoryAlg4 mem) %{
2409     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2410     MacroAssembler _masm(&amp;cbuf);
2411     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2412     // Operand 'ds' requires 4-alignment.
2413     assert((Idisp &amp; 0x3) == 0, "unaligned offset");
2414     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
2415     __ twi_0($dst$$Register);
2416     __ isync();
2417   %}
2418 
2419   enc_class enc_lfd(RegF dst, memory mem) %{
2420     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
2421     MacroAssembler _masm(&amp;cbuf);
2422     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2423     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
2424   %}
2425 
2426   enc_class enc_load_long_constL(iRegLdst dst, immL src, iRegLdst toc) %{
2427     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
2428 
2429     MacroAssembler _masm(&amp;cbuf);
2430     int toc_offset = 0;
2431 
2432     address const_toc_addr;
2433     // Create a non-oop constant, no relocation needed.
2434     // If it is an IC, it has a virtual_call_Relocation.
2435     const_toc_addr = __ long_constant((jlong)$src$$constant);
2436     if (const_toc_addr == NULL) {
2437       ciEnv::current()-&gt;record_out_of_memory_failure();
2438       return;
2439     }
2440     
2441     // Get the constant's TOC offset.
2442     toc_offset = __ offset_to_method_toc(const_toc_addr);
2443     
2444     // Keep the current instruction offset in mind.
2445     ((loadConLNode*)this)-&gt;_cbuf_insts_offset = __ offset();
2446   
2447     __ ld($dst$$Register, toc_offset, $toc$$Register);
2448   %}
2449 
2450   enc_class enc_load_long_constL_hi(iRegLdst dst, iRegLdst toc, immL src) %{
2451     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
2452 
2453     MacroAssembler _masm(&amp;cbuf);
2454 
2455     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
2456       address const_toc_addr;
2457       // Create a non-oop constant, no relocation needed.
2458       // If it is an IC, it has a virtual_call_Relocation.
2459       const_toc_addr = __ long_constant((jlong)$src$$constant);
2460       if (const_toc_addr == NULL) {
2461         ciEnv::current()-&gt;record_out_of_memory_failure();
2462         return;
2463       }
2464 
2465       // Get the constant's TOC offset.
2466       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
2467       // Store the toc offset of the constant.
2468       ((loadConL_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
2469 
2470       // Also keep the current instruction offset in mind.
2471       ((loadConL_hiNode*)this)-&gt;_cbuf_insts_offset = __ offset();
2472     }
2473 
2474     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
2475   %}
2476 
2477 %} // encode
2478 
2479 source %{
2480 
2481 typedef struct {
2482   loadConL_hiNode *_large_hi;
2483   loadConL_loNode *_large_lo;
2484   loadConLNode    *_small;
2485   MachNode        *_last;
2486 } loadConLNodesTuple;
2487 
2488 loadConLNodesTuple loadConLNodesTuple_create(PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
2489                                              OptoReg::Name reg_second, OptoReg::Name reg_first) {
2490   loadConLNodesTuple nodes;
2491 
2492   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
2493   if (large_constant_pool) {
2494     // Create new nodes.
2495     loadConL_hiNode *m1 = new loadConL_hiNode();
2496     loadConL_loNode *m2 = new loadConL_loNode();
2497 
2498     // inputs for new nodes
2499     m1-&gt;add_req(NULL, toc);
2500     m2-&gt;add_req(NULL, m1);
2501 
2502     // operands for new nodes
2503     m1-&gt;_opnds[0] = new iRegLdstOper(); // dst
2504     m1-&gt;_opnds[1] = immSrc;             // src
2505     m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
2506     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
2507     m2-&gt;_opnds[1] = immSrc;             // src
2508     m2-&gt;_opnds[2] = new iRegLdstOper(); // base
2509 
2510     // Initialize ins_attrib TOC fields.
2511     m1-&gt;_const_toc_offset = -1;
2512     m2-&gt;_const_toc_offset_hi_node = m1;
2513 
2514     // Initialize ins_attrib instruction offset.
2515     m1-&gt;_cbuf_insts_offset = -1;
2516 
2517     // register allocation for new nodes
2518     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
2519     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
2520 
2521     // Create result.
2522     nodes._large_hi = m1;
2523     nodes._large_lo = m2;
2524     nodes._small = NULL;
2525     nodes._last = nodes._large_lo;
2526     assert(m2-&gt;bottom_type()-&gt;isa_long(), "must be long");
2527   } else {
2528     loadConLNode *m2 = new loadConLNode();
2529 
2530     // inputs for new nodes
2531     m2-&gt;add_req(NULL, toc);
2532 
2533     // operands for new nodes
2534     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
2535     m2-&gt;_opnds[1] = immSrc;             // src
2536     m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
2537 
2538     // Initialize ins_attrib instruction offset.
2539     m2-&gt;_cbuf_insts_offset = -1;
2540 
2541     // register allocation for new nodes
2542     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
2543 
2544     // Create result.
2545     nodes._large_hi = NULL;
2546     nodes._large_lo = NULL;
2547     nodes._small = m2;
2548     nodes._last = nodes._small;
2549     assert(m2-&gt;bottom_type()-&gt;isa_long(), "must be long");
2550   }
2551 
2552   return nodes;
2553 }
2554 
2555 %} // source
2556 
2557 encode %{
2558   // Postalloc expand emitter for loading a long constant from the method's TOC.
2559   // Enc_class needed as consttanttablebase is not supported by postalloc
2560   // expand.
2561   enc_class postalloc_expand_load_long_constant(iRegLdst dst, immL src, iRegLdst toc) %{
2562     // Create new nodes.
2563     loadConLNodesTuple loadConLNodes =
2564       loadConLNodesTuple_create(ra_, n_toc, op_src,
2565                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2566 
2567     // Push new nodes.
2568     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
2569     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
2570 
2571     // some asserts
2572     assert(nodes-&gt;length() &gt;= 1, "must have created at least 1 node");
2573     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), "must be long");
2574   %}
2575 
2576   enc_class enc_load_long_constP(iRegLdst dst, immP src, iRegLdst toc) %{
2577     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
2578 
2579     MacroAssembler _masm(&amp;cbuf);
2580     int toc_offset = 0;
2581 
2582     intptr_t val = $src$$constant;
2583     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
2584     address const_toc_addr;
2585     if (constant_reloc == relocInfo::oop_type) {
2586       // Create an oop constant and a corresponding relocation.
2587       AddressLiteral a = __ allocate_oop_address((jobject)val);
2588       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
2589       __ relocate(a.rspec());
2590     } else if (constant_reloc == relocInfo::metadata_type) {
2591       AddressLiteral a = __ constant_metadata_address((Metadata *)val);
2592       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
2593       __ relocate(a.rspec());
2594     } else {
2595       // Create a non-oop constant, no relocation needed.
2596       const_toc_addr = __ long_constant((jlong)$src$$constant);
2597     }
2598 
2599     if (const_toc_addr == NULL) {
2600       ciEnv::current()-&gt;record_out_of_memory_failure();
2601       return;
2602     }
2603     // Get the constant's TOC offset.
2604     toc_offset = __ offset_to_method_toc(const_toc_addr);
2605 
2606     __ ld($dst$$Register, toc_offset, $toc$$Register);
2607   %}
2608 
2609   enc_class enc_load_long_constP_hi(iRegLdst dst, immP src, iRegLdst toc) %{
2610     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
2611 
2612     MacroAssembler _masm(&amp;cbuf);
2613     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
2614       intptr_t val = $src$$constant;
2615       relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
2616       address const_toc_addr;
2617       if (constant_reloc == relocInfo::oop_type) {
2618         // Create an oop constant and a corresponding relocation.
2619         AddressLiteral a = __ allocate_oop_address((jobject)val);
2620         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
2621         __ relocate(a.rspec());
2622       } else if (constant_reloc == relocInfo::metadata_type) {
2623         AddressLiteral a = __ constant_metadata_address((Metadata *)val);
2624         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
2625         __ relocate(a.rspec());
2626       } else {  // non-oop pointers, e.g. card mark base, heap top
2627         // Create a non-oop constant, no relocation needed.
2628         const_toc_addr = __ long_constant((jlong)$src$$constant);
2629       }
2630 
2631       if (const_toc_addr == NULL) {
2632         ciEnv::current()-&gt;record_out_of_memory_failure();
2633         return;
2634       }
2635       // Get the constant's TOC offset.
2636       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
2637       // Store the toc offset of the constant.
2638       ((loadConP_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
2639     }
2640 
2641     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
2642   %}
2643 
2644   // Postalloc expand emitter for loading a ptr constant from the method's TOC.
2645   // Enc_class needed as consttanttablebase is not supported by postalloc
2646   // expand.
2647   enc_class postalloc_expand_load_ptr_constant(iRegPdst dst, immP src, iRegLdst toc) %{
2648     const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
2649     if (large_constant_pool) {
2650       // Create new nodes.
2651       loadConP_hiNode *m1 = new loadConP_hiNode();
2652       loadConP_loNode *m2 = new loadConP_loNode();
2653 
2654       // inputs for new nodes
2655       m1-&gt;add_req(NULL, n_toc);
2656       m2-&gt;add_req(NULL, m1);
2657 
2658       // operands for new nodes
2659       m1-&gt;_opnds[0] = new iRegPdstOper(); // dst
2660       m1-&gt;_opnds[1] = op_src;             // src
2661       m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
2662       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
2663       m2-&gt;_opnds[1] = op_src;             // src
2664       m2-&gt;_opnds[2] = new iRegLdstOper(); // base
2665 
2666       // Initialize ins_attrib TOC fields.
2667       m1-&gt;_const_toc_offset = -1;
2668       m2-&gt;_const_toc_offset_hi_node = m1;
2669 
2670       // Register allocation for new nodes.
2671       ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2672       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2673 
2674       nodes-&gt;push(m1);
2675       nodes-&gt;push(m2);
2676       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), "must be ptr");
2677     } else {
2678       loadConPNode *m2 = new loadConPNode();
2679 
2680       // inputs for new nodes
2681       m2-&gt;add_req(NULL, n_toc);
2682 
2683       // operands for new nodes
2684       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
2685       m2-&gt;_opnds[1] = op_src;             // src
2686       m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
2687 
2688       // Register allocation for new nodes.
2689       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2690 
2691       nodes-&gt;push(m2);
2692       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), "must be ptr");
2693     }
2694   %}
2695 
2696   // Enc_class needed as consttanttablebase is not supported by postalloc
2697   // expand.
2698   enc_class postalloc_expand_load_float_constant(regF dst, immF src, iRegLdst toc) %{
2699     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
2700 
2701     MachNode *m2;
2702     if (large_constant_pool) {
2703       m2 = new loadConFCompNode();
2704     } else {
2705       m2 = new loadConFNode();
2706     }
2707     // inputs for new nodes
2708     m2-&gt;add_req(NULL, n_toc);
2709 
2710     // operands for new nodes
2711     m2-&gt;_opnds[0] = op_dst;
2712     m2-&gt;_opnds[1] = op_src;
2713     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
2714 
2715     // register allocation for new nodes
2716     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2717     nodes-&gt;push(m2);
2718   %}
2719 
2720   // Enc_class needed as consttanttablebase is not supported by postalloc
2721   // expand.
2722   enc_class postalloc_expand_load_double_constant(regD dst, immD src, iRegLdst toc) %{
2723     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
2724 
2725     MachNode *m2;
2726     if (large_constant_pool) {
2727       m2 = new loadConDCompNode();
2728     } else {
2729       m2 = new loadConDNode();
2730     }
2731     // inputs for new nodes
2732     m2-&gt;add_req(NULL, n_toc);
2733 
2734     // operands for new nodes
2735     m2-&gt;_opnds[0] = op_dst;
2736     m2-&gt;_opnds[1] = op_src;
2737     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
2738 
2739     // register allocation for new nodes
2740     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2741     nodes-&gt;push(m2);
2742   %}
2743 
2744   enc_class enc_stw(iRegIsrc src, memory mem) %{
2745     // TODO: PPC port $archOpcode(ppc64Opcode_stw);
2746     MacroAssembler _masm(&amp;cbuf);
2747     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2748     __ stw($src$$Register, Idisp, $mem$$base$$Register);
2749   %}
2750 
2751   enc_class enc_std(iRegIsrc src, memoryAlg4 mem) %{
2752     // TODO: PPC port $archOpcode(ppc64Opcode_std);
2753     MacroAssembler _masm(&amp;cbuf);
2754     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2755     // Operand 'ds' requires 4-alignment.
2756     assert((Idisp &amp; 0x3) == 0, "unaligned offset");
2757     __ std($src$$Register, Idisp, $mem$$base$$Register);
2758   %}
2759 
2760   enc_class enc_stfs(RegF src, memory mem) %{
2761     // TODO: PPC port $archOpcode(ppc64Opcode_stfs);
2762     MacroAssembler _masm(&amp;cbuf);
2763     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2764     __ stfs($src$$FloatRegister, Idisp, $mem$$base$$Register);
2765   %}
2766 
2767   enc_class enc_stfd(RegF src, memory mem) %{
2768     // TODO: PPC port $archOpcode(ppc64Opcode_stfd);
2769     MacroAssembler _masm(&amp;cbuf);
2770     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2771     __ stfd($src$$FloatRegister, Idisp, $mem$$base$$Register);
2772   %}
2773 
2774   // Use release_store for card-marking to ensure that previous
2775   // oop-stores are visible before the card-mark change.
2776   enc_class enc_cms_card_mark(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
2777     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2778     // FIXME: Implement this as a cmove and use a fixed condition code
2779     // register which is written on every transition to compiled code,
2780     // e.g. in call-stub and when returning from runtime stubs.
2781     //
2782     // Proposed code sequence for the cmove implementation:
2783     //
2784     // Label skip_release;
2785     // __ beq(CCRfixed, skip_release);
2786     // __ release();
2787     // __ bind(skip_release);
2788     // __ stb(card mark);
2789 
2790     MacroAssembler _masm(&amp;cbuf);
2791     Label skip_storestore;
2792 
2793 #if 0 // TODO: PPC port
2794     // Check CMSCollectorCardTableModRefBSExt::_requires_release and do the
2795     // StoreStore barrier conditionally.
2796     __ lwz(R0, 0, $releaseFieldAddr$$Register);
2797     __ cmpwi($crx$$CondRegister, R0, 0);
2798     __ beq_predict_taken($crx$$CondRegister, skip_storestore);
2799 #endif
2800     __ li(R0, 0);
2801     __ membar(Assembler::StoreStore);
2802 #if 0 // TODO: PPC port
2803     __ bind(skip_storestore);
2804 #endif
2805 
2806     // Do the store.
2807     if ($mem$$index == 0) {
2808       __ stb(R0, $mem$$disp, $mem$$base$$Register);
2809     } else {
2810       assert(0 == $mem$$disp, "no displacement possible with indexed load/stores on ppc");
2811       __ stbx(R0, $mem$$base$$Register, $mem$$index$$Register);
2812     }
2813   %}
2814 
2815   enc_class postalloc_expand_encode_oop(iRegNdst dst, iRegPdst src, flagsReg crx) %{
2816 
2817     if (VM_Version::has_isel()) {
2818       // use isel instruction with Power 7
2819       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
2820       encodeP_subNode    *n_sub_base = new encodeP_subNode();
2821       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
2822       cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();
2823 
2824       n_compare-&gt;add_req(n_region, n_src);
2825       n_compare-&gt;_opnds[0] = op_crx;
2826       n_compare-&gt;_opnds[1] = op_src;
2827       n_compare-&gt;_opnds[2] = new immL16Oper(0);
2828 
2829       n_sub_base-&gt;add_req(n_region, n_src);
2830       n_sub_base-&gt;_opnds[0] = op_dst;
2831       n_sub_base-&gt;_opnds[1] = op_src;
2832       n_sub_base-&gt;_bottom_type = _bottom_type;
2833 
2834       n_shift-&gt;add_req(n_region, n_sub_base);
2835       n_shift-&gt;_opnds[0] = op_dst;
2836       n_shift-&gt;_opnds[1] = op_dst;
2837       n_shift-&gt;_bottom_type = _bottom_type;
2838 
2839       n_cond_set-&gt;add_req(n_region, n_compare, n_shift);
2840       n_cond_set-&gt;_opnds[0] = op_dst;
2841       n_cond_set-&gt;_opnds[1] = op_crx;
2842       n_cond_set-&gt;_opnds[2] = op_dst;
2843       n_cond_set-&gt;_bottom_type = _bottom_type;
2844 
2845       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
2846       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2847       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2848       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2849 
2850       nodes-&gt;push(n_compare);
2851       nodes-&gt;push(n_sub_base);
2852       nodes-&gt;push(n_shift);
2853       nodes-&gt;push(n_cond_set);
2854 
2855     } else {
2856       // before Power 7
2857       moveRegNode        *n_move     = new moveRegNode();
2858       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
2859       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
2860       cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();
2861 
2862       n_move-&gt;add_req(n_region, n_src);
2863       n_move-&gt;_opnds[0] = op_dst;
2864       n_move-&gt;_opnds[1] = op_src;
2865       ra_-&gt;set_oop(n_move, true); // Until here, 'n_move' still produces an oop.
2866 
2867       n_compare-&gt;add_req(n_region, n_src);
2868       n_compare-&gt;add_prec(n_move);
2869 
2870       n_compare-&gt;_opnds[0] = op_crx;
2871       n_compare-&gt;_opnds[1] = op_src;
2872       n_compare-&gt;_opnds[2] = new immL16Oper(0);
2873 
2874       n_sub_base-&gt;add_req(n_region, n_compare, n_src);
2875       n_sub_base-&gt;_opnds[0] = op_dst;
2876       n_sub_base-&gt;_opnds[1] = op_crx;
2877       n_sub_base-&gt;_opnds[2] = op_src;
2878       n_sub_base-&gt;_bottom_type = _bottom_type;
2879 
2880       n_shift-&gt;add_req(n_region, n_sub_base);
2881       n_shift-&gt;_opnds[0] = op_dst;
2882       n_shift-&gt;_opnds[1] = op_dst;
2883       n_shift-&gt;_bottom_type = _bottom_type;
2884 
2885       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2886       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
2887       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2888       ra_-&gt;set_pair(n_move-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2889 
2890       nodes-&gt;push(n_move);
2891       nodes-&gt;push(n_compare);
2892       nodes-&gt;push(n_sub_base);
2893       nodes-&gt;push(n_shift);
2894     }
2895 
2896     assert(!(ra_-&gt;is_oop(this)), "sanity"); // This is not supposed to be GC'ed.
2897   %}
2898 
2899   enc_class postalloc_expand_encode_oop_not_null(iRegNdst dst, iRegPdst src) %{
2900 
2901     encodeP_subNode *n1 = new encodeP_subNode();
2902     n1-&gt;add_req(n_region, n_src);
2903     n1-&gt;_opnds[0] = op_dst;
2904     n1-&gt;_opnds[1] = op_src;
2905     n1-&gt;_bottom_type = _bottom_type;
2906 
2907     encodeP_shiftNode *n2 = new encodeP_shiftNode();
2908     n2-&gt;add_req(n_region, n1);
2909     n2-&gt;_opnds[0] = op_dst;
2910     n2-&gt;_opnds[1] = op_dst;
2911     n2-&gt;_bottom_type = _bottom_type;
2912     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2913     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2914 
2915     nodes-&gt;push(n1);
2916     nodes-&gt;push(n2);
2917     assert(!(ra_-&gt;is_oop(this)), "sanity"); // This is not supposed to be GC'ed.
2918   %}
2919 
2920   enc_class postalloc_expand_decode_oop(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
2921     decodeN_shiftNode *n_shift    = new decodeN_shiftNode();
2922     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
2923 
2924     n_compare-&gt;add_req(n_region, n_src);
2925     n_compare-&gt;_opnds[0] = op_crx;
2926     n_compare-&gt;_opnds[1] = op_src;
2927     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
2928 
2929     n_shift-&gt;add_req(n_region, n_src);
2930     n_shift-&gt;_opnds[0] = op_dst;
2931     n_shift-&gt;_opnds[1] = op_src;
2932     n_shift-&gt;_bottom_type = _bottom_type;
2933 
2934     if (VM_Version::has_isel()) {
2935       // use isel instruction with Power 7
2936 
2937       decodeN_addNode *n_add_base = new decodeN_addNode();
2938       n_add_base-&gt;add_req(n_region, n_shift);
2939       n_add_base-&gt;_opnds[0] = op_dst;
2940       n_add_base-&gt;_opnds[1] = op_dst;
2941       n_add_base-&gt;_bottom_type = _bottom_type;
2942 
2943       cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
2944       n_cond_set-&gt;add_req(n_region, n_compare, n_add_base);
2945       n_cond_set-&gt;_opnds[0] = op_dst;
2946       n_cond_set-&gt;_opnds[1] = op_crx;
2947       n_cond_set-&gt;_opnds[2] = op_dst;
2948       n_cond_set-&gt;_bottom_type = _bottom_type;
2949 
2950       assert(ra_-&gt;is_oop(this) == true, "A decodeN node must produce an oop!");
2951       ra_-&gt;set_oop(n_cond_set, true);
2952 
2953       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2954       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
2955       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2956       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2957 
2958       nodes-&gt;push(n_compare);
2959       nodes-&gt;push(n_shift);
2960       nodes-&gt;push(n_add_base);
2961       nodes-&gt;push(n_cond_set);
2962 
2963     } else {
2964       // before Power 7
2965       cond_add_baseNode *n_add_base = new cond_add_baseNode();
2966 
2967       n_add_base-&gt;add_req(n_region, n_compare, n_shift);
2968       n_add_base-&gt;_opnds[0] = op_dst;
2969       n_add_base-&gt;_opnds[1] = op_crx;
2970       n_add_base-&gt;_opnds[2] = op_dst;
2971       n_add_base-&gt;_bottom_type = _bottom_type;
2972 
2973       assert(ra_-&gt;is_oop(this) == true, "A decodeN node must produce an oop!");
2974       ra_-&gt;set_oop(n_add_base, true);
2975 
2976       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2977       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
2978       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2979 
2980       nodes-&gt;push(n_compare);
2981       nodes-&gt;push(n_shift);
2982       nodes-&gt;push(n_add_base);
2983     }
2984   %}
2985 
2986   enc_class postalloc_expand_decode_oop_not_null(iRegPdst dst, iRegNsrc src) %{
2987     decodeN_shiftNode *n1 = new decodeN_shiftNode();
2988     n1-&gt;add_req(n_region, n_src);
2989     n1-&gt;_opnds[0] = op_dst;
2990     n1-&gt;_opnds[1] = op_src;
2991     n1-&gt;_bottom_type = _bottom_type;
2992 
2993     decodeN_addNode *n2 = new decodeN_addNode();
2994     n2-&gt;add_req(n_region, n1);
2995     n2-&gt;_opnds[0] = op_dst;
2996     n2-&gt;_opnds[1] = op_dst;
2997     n2-&gt;_bottom_type = _bottom_type;
2998     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2999     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
3000 
3001     assert(ra_-&gt;is_oop(this) == true, "A decodeN node must produce an oop!");
3002     ra_-&gt;set_oop(n2, true);
3003 
3004     nodes-&gt;push(n1);
3005     nodes-&gt;push(n2);
3006   %}
3007 
3008   enc_class enc_cmove_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src, cmpOp cmp) %{
3009     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
3010 
3011     MacroAssembler _masm(&amp;cbuf);
3012     int cc        = $cmp$$cmpcode;
3013     int flags_reg = $crx$$reg;
3014     Label done;
3015     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, "check encoding");
3016     // Branch if not (cmp crx).
3017     __ bc(cc_to_inverse_boint(cc), cc_to_biint(cc, flags_reg), done);
3018     __ mr($dst$$Register, $src$$Register);
3019     // TODO PPC port __ endgroup_if_needed(_size == 12);
3020     __ bind(done);
3021   %}
3022 
3023   enc_class enc_cmove_imm(iRegIdst dst, flagsRegSrc crx, immI16 src, cmpOp cmp) %{
3024     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
3025 
3026     MacroAssembler _masm(&amp;cbuf);
3027     Label done;
3028     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, "check encoding");
3029     // Branch if not (cmp crx).
3030     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
3031     __ li($dst$$Register, $src$$constant);
3032     // TODO PPC port __ endgroup_if_needed(_size == 12);
3033     __ bind(done);
3034   %}
3035 
3036   // This enc_class is needed so that scheduler gets proper
3037   // input mapping for latency computation.
3038   enc_class enc_andc(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
3039     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
3040     MacroAssembler _masm(&amp;cbuf);
3041     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
3042   %}
3043 
3044   enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
3045     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
3046 
3047     MacroAssembler _masm(&amp;cbuf);
3048 
3049     Label done;
3050     __ cmpwi($crx$$CondRegister, $src$$Register, 0);
3051     __ li($dst$$Register, $zero$$constant);
3052     __ beq($crx$$CondRegister, done);
3053     __ li($dst$$Register, $notzero$$constant);
3054     __ bind(done);
3055   %}
3056 
3057   enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
3058     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
3059 
3060     MacroAssembler _masm(&amp;cbuf);
3061 
3062     Label done;
3063     __ cmpdi($crx$$CondRegister, $src$$Register, 0);
3064     __ li($dst$$Register, $zero$$constant);
3065     __ beq($crx$$CondRegister, done);
3066     __ li($dst$$Register, $notzero$$constant);
3067     __ bind(done);
3068   %}
3069 
3070   enc_class enc_cmove_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL mem ) %{
3071     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
3072 
3073     MacroAssembler _masm(&amp;cbuf);
3074     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
3075     Label done;
3076     __ bso($crx$$CondRegister, done);
3077     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
3078     // TODO PPC port __ endgroup_if_needed(_size == 12);
3079     __ bind(done);
3080   %}
3081 
3082   enc_class enc_bc(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
3083     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
3084 
3085     MacroAssembler _masm(&amp;cbuf);
3086     Label d;   // dummy
3087     __ bind(d);
3088     Label* p = ($lbl$$label);
3089     // `p' is `NULL' when this encoding class is used only to
3090     // determine the size of the encoded instruction.
3091     Label&amp; l = (NULL == p)? d : *(p);
3092     int cc = $cmp$$cmpcode;
3093     int flags_reg = $crx$$reg;
3094     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, "check encoding");
3095     int bhint = Assembler::bhintNoHint;
3096 
3097     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
3098       if (_prob &lt;= PROB_NEVER) {
3099         bhint = Assembler::bhintIsNotTaken;
3100       } else if (_prob &gt;= PROB_ALWAYS) {
3101         bhint = Assembler::bhintIsTaken;
3102       }
3103     }
3104 
3105     __ bc(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
3106           cc_to_biint(cc, flags_reg),
3107           l);
3108   %}
3109 
3110   enc_class enc_bc_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
3111     // The scheduler doesn't know about branch shortening, so we set the opcode
3112     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
3113     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
3114 
3115     MacroAssembler _masm(&amp;cbuf);
3116     Label d;    // dummy
3117     __ bind(d);
3118     Label* p = ($lbl$$label);
3119     // `p' is `NULL' when this encoding class is used only to
3120     // determine the size of the encoded instruction.
3121     Label&amp; l = (NULL == p)? d : *(p);
3122     int cc = $cmp$$cmpcode;
3123     int flags_reg = $crx$$reg;
3124     int bhint = Assembler::bhintNoHint;
3125 
3126     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
3127       if (_prob &lt;= PROB_NEVER) {
3128         bhint = Assembler::bhintIsNotTaken;
3129       } else if (_prob &gt;= PROB_ALWAYS) {
3130         bhint = Assembler::bhintIsTaken;
3131       }
3132     }
3133 
3134     // Tell the conditional far branch to optimize itself when being relocated.
3135     __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
3136                   cc_to_biint(cc, flags_reg),
3137                   l,
3138                   MacroAssembler::bc_far_optimize_on_relocate);
3139   %}
3140 
3141   // Branch used with Power6 scheduling (can be shortened without changing the node).
3142   enc_class enc_bc_short_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
3143     // The scheduler doesn't know about branch shortening, so we set the opcode
3144     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
3145     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
3146 
3147     MacroAssembler _masm(&amp;cbuf);
3148     Label d;   // dummy
3149     __ bind(d);
3150     Label* p = ($lbl$$label);
3151     // `p' is `NULL' when this encoding class is used only to
3152     // determine the size of the encoded instruction.
3153     Label&amp; l = (NULL == p)? d : *(p);
3154     int cc = $cmp$$cmpcode;
3155     int flags_reg = $crx$$reg;
3156     int bhint = Assembler::bhintNoHint;
3157 
3158     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
3159       if (_prob &lt;= PROB_NEVER) {
3160         bhint = Assembler::bhintIsNotTaken;
3161       } else if (_prob &gt;= PROB_ALWAYS) {
3162         bhint = Assembler::bhintIsTaken;
3163       }
3164     }
3165 
3166 #if 0 // TODO: PPC port
3167     if (_size == 8) {
3168       // Tell the conditional far branch to optimize itself when being relocated.
3169       __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
3170                     cc_to_biint(cc, flags_reg),
3171                     l,
3172                     MacroAssembler::bc_far_optimize_on_relocate);
3173     } else {
3174       __ bc    (Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
3175                     cc_to_biint(cc, flags_reg),
3176                     l);
3177     }
3178 #endif
3179     Unimplemented();
3180   %}
3181 
3182   // Postalloc expand emitter for loading a replicatef float constant from
3183   // the method's TOC.
3184   // Enc_class needed as consttanttablebase is not supported by postalloc
3185   // expand.
3186   enc_class postalloc_expand_load_replF_constant(iRegLdst dst, immF src, iRegLdst toc) %{
3187     // Create new nodes.
3188 
3189     // Make an operand with the bit pattern to load as float.
3190     immLOper *op_repl = new immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
3191 
3192     loadConLNodesTuple loadConLNodes =
3193       loadConLNodesTuple_create(ra_, n_toc, op_repl,
3194                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
3195 
3196     // Push new nodes.
3197     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
3198     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
3199 
3200     assert(nodes-&gt;length() &gt;= 1, "must have created at least 1 node");
3201     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), "must be long");
3202   %}
3203 
3204   // This enc_class is needed so that scheduler gets proper
3205   // input mapping for latency computation.
3206   enc_class enc_poll(immI dst, iRegLdst poll) %{
3207     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
3208     // Fake operand dst needed for PPC scheduler.
3209     assert($dst$$constant == 0x0, "dst must be 0x0");
3210 
3211     MacroAssembler _masm(&amp;cbuf);
3212     // Mark the code position where the load from the safepoint
3213     // polling page was emitted as relocInfo::poll_type.
3214     __ relocate(relocInfo::poll_type);
3215     __ load_from_polling_page($poll$$Register);
3216   %}
3217 
3218   // A Java static call or a runtime call.
3219   //
3220   // Branch-and-link relative to a trampoline.
3221   // The trampoline loads the target address and does a long branch to there.
3222   // In case we call java, the trampoline branches to a interpreter_stub
3223   // which loads the inline cache and the real call target from the constant pool.
3224   //
3225   // This basically looks like this:
3226   //
3227   // &gt;&gt;&gt;&gt; consts      -+  -+
3228   //                   |   |- offset1
3229   // [call target1]    | &lt;-+
3230   // [IC cache]        |- offset2
3231   // [call target2] &lt;--+
3232   //
3233   // &lt;&lt;&lt;&lt; consts
3234   // &gt;&gt;&gt;&gt; insts
3235   //
3236   // bl offset16               -+  -+             ??? // How many bits available?
3237   //                            |   |
3238   // &lt;&lt;&lt;&lt; insts                 |   |
3239   // &gt;&gt;&gt;&gt; stubs                 |   |
3240   //                            |   |- trampoline_stub_Reloc
3241   // trampoline stub:           | &lt;-+
3242   //   r2 = toc                 |
3243   //   r2 = [r2 + offset1]      |       // Load call target1 from const section
3244   //   mtctr r2                 |
3245   //   bctr                     |- static_stub_Reloc
3246   // comp_to_interp_stub:   &lt;---+
3247   //   r1 = toc
3248   //   ICreg = [r1 + IC_offset]         // Load IC from const section
3249   //   r1    = [r1 + offset2]           // Load call target2 from const section
3250   //   mtctr r1
3251   //   bctr
3252   //
3253   // &lt;&lt;&lt;&lt; stubs
3254   //
3255   // The call instruction in the code either
3256   // - Branches directly to a compiled method if the offset is encodable in instruction.
3257   // - Branches to the trampoline stub if the offset to the compiled method is not encodable.
3258   // - Branches to the compiled_to_interp stub if the target is interpreted.
3259   //
3260   // Further there are three relocations from the loads to the constants in
3261   // the constant section.
3262   //
3263   // Usage of r1 and r2 in the stubs allows to distinguish them.
3264   enc_class enc_java_static_call(method meth) %{
3265     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
3266 
3267     MacroAssembler _masm(&amp;cbuf);
3268     address entry_point = (address)$meth$$method;
3269 
3270     if (!_method) {
3271       // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
3272       emit_call_with_trampoline_stub(_masm, entry_point, relocInfo::runtime_call_type);
3273     } else {
3274       // Remember the offset not the address.
3275       const int start_offset = __ offset();
3276 
3277       // The trampoline stub.
3278       // No entry point given, use the current pc.
3279       // Make sure branch fits into
3280       if (entry_point == 0) entry_point = __ pc();
3281 
3282       // Put the entry point as a constant into the constant pool.
3283       const address entry_point_toc_addr = __ address_constant(entry_point, RelocationHolder::none);
3284       if (entry_point_toc_addr == NULL) {
3285         ciEnv::current()-&gt;record_out_of_memory_failure();
3286         return;
3287       }
3288       const int entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
3289 
3290       // Emit the trampoline stub which will be related to the branch-and-link below.
3291       CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, start_offset);
3292       if (ciEnv::current()-&gt;failing()) { return; } // Code cache may be full.
3293       int method_index = resolved_method_index(cbuf);
3294       __ relocate(_optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
3295                   : static_call_Relocation::spec(method_index));
3296 
3297       // The real call.
3298       // Note: At this point we do not have the address of the trampoline
3299       // stub, and the entry point might be too far away for bl, so __ pc()
3300       // serves as dummy and the bl will be patched later.
3301       cbuf.set_insts_mark();
3302       __ bl(__ pc());  // Emits a relocation.
3303 
3304       // The stub for call to interpreter.
3305       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
3306       if (stub == NULL) {
3307         ciEnv::current()-&gt;record_failure("CodeCache is full");
3308         return;
3309       }
3310     }
3311   %}
3312 
3313   // Second node of expanded dynamic call - the call.
3314   enc_class enc_java_dynamic_call_sched(method meth) %{
3315     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
3316 
3317     MacroAssembler _masm(&amp;cbuf);
3318 
3319     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
3320       // Create a call trampoline stub for the given method.
3321       const address entry_point = !($meth$$method) ? 0 : (address)$meth$$method;
3322       const address entry_point_const = __ address_constant(entry_point, RelocationHolder::none);
3323       if (entry_point_const == NULL) {
3324         ciEnv::current()-&gt;record_out_of_memory_failure();
3325         return;
3326       }
3327       const int entry_point_const_toc_offset = __ offset_to_method_toc(entry_point_const);
3328       CallStubImpl::emit_trampoline_stub(_masm, entry_point_const_toc_offset, __ offset());
3329       if (ra_-&gt;C-&gt;env()-&gt;failing()) { return; } // Code cache may be full.
3330 
3331       // Build relocation at call site with ic position as data.
3332       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_node == NULL) ||
3333              (_load_ic_hi_node == NULL &amp;&amp; _load_ic_node != NULL),
3334              "must have one, but can't have both");
3335       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_hi_node-&gt;_cbuf_insts_offset != -1) ||
3336              (_load_ic_node != NULL    &amp;&amp; _load_ic_node-&gt;_cbuf_insts_offset != -1),
3337              "must contain instruction offset");
3338       const int virtual_call_oop_addr_offset = _load_ic_hi_node != NULL
3339         ? _load_ic_hi_node-&gt;_cbuf_insts_offset
3340         : _load_ic_node-&gt;_cbuf_insts_offset;
3341       const address virtual_call_oop_addr = __ addr_at(virtual_call_oop_addr_offset);
3342       assert(MacroAssembler::is_load_const_from_method_toc_at(virtual_call_oop_addr),
3343              "should be load from TOC");
3344       int method_index = resolved_method_index(cbuf);
3345       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
3346     }
3347 
3348     // At this point I do not have the address of the trampoline stub,
3349     // and the entry point might be too far away for bl. Pc() serves
3350     // as dummy and bl will be patched later.
3351     __ bl((address) __ pc());
3352   %}
3353 
3354   // postalloc expand emitter for virtual calls.
3355   enc_class postalloc_expand_java_dynamic_call_sched(method meth, iRegLdst toc) %{
3356 
3357     // Create the nodes for loading the IC from the TOC.
3358     loadConLNodesTuple loadConLNodes_IC =
3359       loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong)Universe::non_oop_word()),
3360                                 OptoReg::Name(R19_H_num), OptoReg::Name(R19_num));
3361 
3362     // Create the call node.
3363     CallDynamicJavaDirectSchedNode *call = new CallDynamicJavaDirectSchedNode();
3364     call-&gt;_method_handle_invoke = _method_handle_invoke;
3365     call-&gt;_vtable_index      = _vtable_index;
3366     call-&gt;_method            = _method;
3367     call-&gt;_bci               = _bci;
3368     call-&gt;_optimized_virtual = _optimized_virtual;
3369     call-&gt;_tf                = _tf;
3370     call-&gt;_entry_point       = _entry_point;
3371     call-&gt;_cnt               = _cnt;
3372     call-&gt;_argsize           = _argsize;
3373     call-&gt;_oop_map           = _oop_map;
3374     call-&gt;_jvms              = _jvms;
3375     call-&gt;_jvmadj            = _jvmadj;
3376     call-&gt;_in_rms            = _in_rms;
3377     call-&gt;_nesting           = _nesting;
3378     call-&gt;_override_symbolic_info = _override_symbolic_info;
3379 
3380     // New call needs all inputs of old call.
3381     // Req...
3382     for (uint i = 0; i &lt; req(); ++i) {
3383       // The expanded node does not need toc any more.
3384       // Add the inline cache constant here instead. This expresses the
3385       // register of the inline cache must be live at the call.
3386       // Else we would have to adapt JVMState by -1.
3387       if (i == mach_constant_base_node_input()) {
3388         call-&gt;add_req(loadConLNodes_IC._last);
3389       } else {
3390         call-&gt;add_req(in(i));
3391       }
3392     }
3393     // ...as well as prec
3394     for (uint i = req(); i &lt; len(); ++i) {
3395       call-&gt;add_prec(in(i));
3396     }
3397 
3398     // Remember nodes loading the inline cache into r19.
3399     call-&gt;_load_ic_hi_node = loadConLNodes_IC._large_hi;
3400     call-&gt;_load_ic_node    = loadConLNodes_IC._small;
3401 
3402     // Operands for new nodes.
3403     call-&gt;_opnds[0] = _opnds[0];
3404     call-&gt;_opnds[1] = _opnds[1];
3405 
3406     // Only the inline cache is associated with a register.
3407     assert(Matcher::inline_cache_reg() == OptoReg::Name(R19_num), "ic reg should be R19");
3408 
3409     // Push new nodes.
3410     if (loadConLNodes_IC._large_hi) nodes-&gt;push(loadConLNodes_IC._large_hi);
3411     if (loadConLNodes_IC._last)     nodes-&gt;push(loadConLNodes_IC._last);
3412     nodes-&gt;push(call);
3413   %}
3414 
3415   // Compound version of call dynamic
3416   // Toc is only passed so that it can be used in ins_encode statement.
3417   // In the code we have to use $constanttablebase.
3418   enc_class enc_java_dynamic_call(method meth, iRegLdst toc) %{
3419     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
3420     MacroAssembler _masm(&amp;cbuf);
3421     int start_offset = __ offset();
3422 
3423     Register Rtoc = (ra_) ? $constanttablebase : R2_TOC;
3424 #if 0
3425     int vtable_index = this-&gt;_vtable_index;
3426     if (_vtable_index &lt; 0) {
3427       // Must be invalid_vtable_index, not nonvirtual_vtable_index.
3428       assert(_vtable_index == Method::invalid_vtable_index, "correct sentinel value");
3429       Register ic_reg = as_Register(Matcher::inline_cache_reg_encode());
3430 
3431       // Virtual call relocation will point to ic load.
3432       address virtual_call_meta_addr = __ pc();
3433       // Load a clear inline cache.
3434       AddressLiteral empty_ic((address) Universe::non_oop_word());
3435       bool success = __ load_const_from_method_toc(ic_reg, empty_ic, Rtoc, /*fixed_size*/ true);
3436       if (!success) {
3437         ciEnv::current()-&gt;record_out_of_memory_failure();
3438         return;
3439       }
3440       // CALL to fixup routine.  Fixup routine uses ScopeDesc info
3441       // to determine who we intended to call.
3442       __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
3443       emit_call_with_trampoline_stub(_masm, (address)$meth$$method, relocInfo::none);
3444       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
3445              "Fix constant in ret_addr_offset()");
3446     } else {
3447       assert(!UseInlineCaches, "expect vtable calls only if not using ICs");
3448       // Go thru the vtable. Get receiver klass. Receiver already
3449       // checked for non-null. If we'll go thru a C2I adapter, the
3450       // interpreter expects method in R19_method.
3451 
3452       __ load_klass(R11_scratch1, R3);
3453 
3454       int entry_offset = in_bytes(Klass::vtable_start_offset()) + _vtable_index * vtableEntry::size_in_bytes();
3455       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
3456       __ li(R19_method, v_off);
3457       __ ldx(R19_method/*method oop*/, R19_method/*method offset*/, R11_scratch1/*class*/);
3458       // NOTE: for vtable dispatches, the vtable entry will never be
3459       // null. However it may very well end up in handle_wrong_method
3460       // if the method is abstract for the particular class.
3461       __ ld(R11_scratch1, in_bytes(Method::from_compiled_offset()), R19_method);
3462       // Call target. Either compiled code or C2I adapter.
3463       __ mtctr(R11_scratch1);
3464       __ bctrl();
3465       if (((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() != __ offset() - start_offset) {
3466         tty-&gt;print(" %d, %d\n", ((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset(),__ offset() - start_offset);
3467       }
3468       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
3469              "Fix constant in ret_addr_offset()");
3470     }
3471 #endif
3472     Unimplemented();  // ret_addr_offset not yet fixed. Depends on compressed oops (load klass!).
3473   %}
3474 
3475   // a runtime call
3476   enc_class enc_java_to_runtime_call (method meth) %{
3477     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
3478 
3479     MacroAssembler _masm(&amp;cbuf);
3480     const address start_pc = __ pc();
3481 
3482 #if defined(ABI_ELFv2)
3483     address entry= !($meth$$method) ? NULL : (address)$meth$$method;
3484     __ call_c(entry, relocInfo::runtime_call_type);
3485 #else
3486     // The function we're going to call.
3487     FunctionDescriptor fdtemp;
3488     const FunctionDescriptor* fd = !($meth$$method) ? &amp;fdtemp : (FunctionDescriptor*)$meth$$method;
3489 
3490     Register Rtoc = R12_scratch2;
3491     // Calculate the method's TOC.
3492     __ calculate_address_from_global_toc(Rtoc, __ method_toc());
3493     // Put entry, env, toc into the constant pool, this needs up to 3 constant
3494     // pool entries; call_c_using_toc will optimize the call.
3495     bool success = __ call_c_using_toc(fd, relocInfo::runtime_call_type, Rtoc);
3496     if (!success) {
3497       ciEnv::current()-&gt;record_out_of_memory_failure();
3498       return;
3499     }
3500 #endif
3501 
3502     // Check the ret_addr_offset.
3503     assert(((MachCallRuntimeNode*)this)-&gt;ret_addr_offset() ==  __ last_calls_return_pc() - start_pc,
3504            "Fix constant in ret_addr_offset()");
3505   %}
3506 
3507   // Move to ctr for leaf call.
3508   // This enc_class is needed so that scheduler gets proper
3509   // input mapping for latency computation.
3510   enc_class enc_leaf_call_mtctr(iRegLsrc src) %{
3511     // TODO: PPC port $archOpcode(ppc64Opcode_mtctr);
3512     MacroAssembler _masm(&amp;cbuf);
3513     __ mtctr($src$$Register);
3514   %}
3515 
3516   // Postalloc expand emitter for runtime leaf calls.
3517   enc_class postalloc_expand_java_to_runtime_call(method meth, iRegLdst toc) %{
3518     loadConLNodesTuple loadConLNodes_Entry;
3519 #if defined(ABI_ELFv2)
3520     jlong entry_address = (jlong) this-&gt;entry_point();
3521     assert(entry_address, "need address here");
3522     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
3523                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
3524 #else
3525     // Get the struct that describes the function we are about to call.
3526     FunctionDescriptor* fd = (FunctionDescriptor*) this-&gt;entry_point();
3527     assert(fd, "need fd here");
3528     jlong entry_address = (jlong) fd-&gt;entry();
3529     // new nodes
3530     loadConLNodesTuple loadConLNodes_Env;
3531     loadConLNodesTuple loadConLNodes_Toc;
3532 
3533     // Create nodes and operands for loading the entry point.
3534     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
3535                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
3536 
3537 
3538     // Create nodes and operands for loading the env pointer.
3539     if (fd-&gt;env() != NULL) {
3540       loadConLNodes_Env = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;env()),
3541                                                     OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
3542     } else {
3543       loadConLNodes_Env._large_hi = NULL;
3544       loadConLNodes_Env._large_lo = NULL;
3545       loadConLNodes_Env._small    = NULL;
3546       loadConLNodes_Env._last = new loadConL16Node();
3547       loadConLNodes_Env._last-&gt;_opnds[0] = new iRegLdstOper();
3548       loadConLNodes_Env._last-&gt;_opnds[1] = new immL16Oper(0);
3549       ra_-&gt;set_pair(loadConLNodes_Env._last-&gt;_idx, OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
3550     }
3551 
3552     // Create nodes and operands for loading the Toc point.
3553     loadConLNodes_Toc = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;toc()),
3554                                                   OptoReg::Name(R2_H_num), OptoReg::Name(R2_num));
3555 #endif // ABI_ELFv2
3556     // mtctr node
3557     MachNode *mtctr = new CallLeafDirect_mtctrNode();
3558 
3559     assert(loadConLNodes_Entry._last != NULL, "entry must exist");
3560     mtctr-&gt;add_req(0, loadConLNodes_Entry._last);
3561 
3562     mtctr-&gt;_opnds[0] = new iRegLdstOper();
3563     mtctr-&gt;_opnds[1] = new iRegLdstOper();
3564 
3565     // call node
3566     MachCallLeafNode *call = new CallLeafDirectNode();
3567 
3568     call-&gt;_opnds[0] = _opnds[0];
3569     call-&gt;_opnds[1] = new methodOper((intptr_t) entry_address); // May get set later.
3570 
3571     // Make the new call node look like the old one.
3572     call-&gt;_name        = _name;
3573     call-&gt;_tf          = _tf;
3574     call-&gt;_entry_point = _entry_point;
3575     call-&gt;_cnt         = _cnt;
3576     call-&gt;_argsize     = _argsize;
3577     call-&gt;_oop_map     = _oop_map;
3578     guarantee(!_jvms, "You must clone the jvms and adapt the offsets by fix_jvms().");
3579     call-&gt;_jvms        = NULL;
3580     call-&gt;_jvmadj      = _jvmadj;
3581     call-&gt;_in_rms      = _in_rms;
3582     call-&gt;_nesting     = _nesting;
3583 
3584 
3585     // New call needs all inputs of old call.
3586     // Req...
3587     for (uint i = 0; i &lt; req(); ++i) {
3588       if (i != mach_constant_base_node_input()) {
3589         call-&gt;add_req(in(i));
3590       }
3591     }
3592 
3593     // These must be reqired edges, as the registers are live up to
3594     // the call. Else the constants are handled as kills.
3595     call-&gt;add_req(mtctr);
3596 #if !defined(ABI_ELFv2)
3597     call-&gt;add_req(loadConLNodes_Env._last);
3598     call-&gt;add_req(loadConLNodes_Toc._last);
3599 #endif
3600 
3601     // ...as well as prec
3602     for (uint i = req(); i &lt; len(); ++i) {
3603       call-&gt;add_prec(in(i));
3604     }
3605 
3606     // registers
3607     ra_-&gt;set1(mtctr-&gt;_idx, OptoReg::Name(SR_CTR_num));
3608 
3609     // Insert the new nodes.
3610     if (loadConLNodes_Entry._large_hi) nodes-&gt;push(loadConLNodes_Entry._large_hi);
3611     if (loadConLNodes_Entry._last)     nodes-&gt;push(loadConLNodes_Entry._last);
3612 #if !defined(ABI_ELFv2)
3613     if (loadConLNodes_Env._large_hi)   nodes-&gt;push(loadConLNodes_Env._large_hi);
3614     if (loadConLNodes_Env._last)       nodes-&gt;push(loadConLNodes_Env._last);
3615     if (loadConLNodes_Toc._large_hi)   nodes-&gt;push(loadConLNodes_Toc._large_hi);
3616     if (loadConLNodes_Toc._last)       nodes-&gt;push(loadConLNodes_Toc._last);
3617 #endif
3618     nodes-&gt;push(mtctr);
3619     nodes-&gt;push(call);
3620   %}
3621 %}
3622 
3623 //----------FRAME--------------------------------------------------------------
3624 // Definition of frame structure and management information.
3625 
3626 frame %{
3627   // What direction does stack grow in (assumed to be same for native &amp; Java).
3628   stack_direction(TOWARDS_LOW);
3629 
3630   // These two registers define part of the calling convention between
3631   // compiled code and the interpreter.
3632 
3633   // Inline Cache Register or method for I2C.
3634   inline_cache_reg(R19); // R19_method
3635 
3636   // Method Oop Register when calling interpreter.
3637   interpreter_method_oop_reg(R19); // R19_method
3638 
3639   // Optional: name the operand used by cisc-spilling to access
3640   // [stack_pointer + offset].
3641   cisc_spilling_operand_name(indOffset);
3642 
3643   // Number of stack slots consumed by a Monitor enter.
3644   sync_stack_slots((frame::jit_monitor_size / VMRegImpl::stack_slot_size));
3645 
3646   // Compiled code's Frame Pointer.
3647   frame_pointer(R1); // R1_SP
3648 
3649   // Interpreter stores its frame pointer in a register which is
3650   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
3651   // interpreted java to compiled java.
3652   //
3653   // R14_state holds pointer to caller's cInterpreter.
3654   interpreter_frame_pointer(R14); // R14_state
3655 
3656   stack_alignment(frame::alignment_in_bytes);
3657 
3658   in_preserve_stack_slots((frame::jit_in_preserve_size / VMRegImpl::stack_slot_size));
3659 
3660   // Number of outgoing stack slots killed above the
3661   // out_preserve_stack_slots for calls to C. Supports the var-args
3662   // backing area for register parms.
3663   //
3664   varargs_C_out_slots_killed(((frame::abi_reg_args_size - frame::jit_out_preserve_size) / VMRegImpl::stack_slot_size));
3665 
3666   // The after-PROLOG location of the return address. Location of
3667   // return address specifies a type (REG or STACK) and a number
3668   // representing the register number (i.e. - use a register name) or
3669   // stack slot.
3670   //
3671   // A: Link register is stored in stack slot ...
3672   // M:  ... but it's in the caller's frame according to PPC-64 ABI.
3673   // J: Therefore, we make sure that the link register is also in R11_scratch1
3674   //    at the end of the prolog.
3675   // B: We use R20, now.
3676   //return_addr(REG R20);
3677 
3678   // G: After reading the comments made by all the luminaries on their
3679   //    failure to tell the compiler where the return address really is,
3680   //    I hardly dare to try myself.  However, I'm convinced it's in slot
3681   //    4 what apparently works and saves us some spills.
3682   return_addr(STACK 4);
3683 
3684   // This is the body of the function
3685   //
3686   // void Matcher::calling_convention(OptoRegPair* sig, // array of ideal regs
3687   //                                  uint length,      // length of array
3688   //                                  bool is_outgoing)
3689   //
3690   // The `sig' array is to be updated. sig[j] represents the location
3691   // of the j-th argument, either a register or a stack slot.
3692 
3693   // Comment taken from i486.ad:
3694   // Body of function which returns an integer array locating
3695   // arguments either in registers or in stack slots. Passed an array
3696   // of ideal registers called "sig" and a "length" count. Stack-slot
3697   // offsets are based on outgoing arguments, i.e. a CALLER setting up
3698   // arguments for a CALLEE. Incoming stack arguments are
3699   // automatically biased by the preserve_stack_slots field above.
3700   calling_convention %{
3701     // No difference between ingoing/outgoing. Just pass false.
3702     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
3703   %}
3704 
3705   // Comment taken from i486.ad:
3706   // Body of function which returns an integer array locating
3707   // arguments either in registers or in stack slots. Passed an array
3708   // of ideal registers called "sig" and a "length" count. Stack-slot
3709   // offsets are based on outgoing arguments, i.e. a CALLER setting up
3710   // arguments for a CALLEE. Incoming stack arguments are
3711   // automatically biased by the preserve_stack_slots field above.
3712   c_calling_convention %{
3713     // This is obviously always outgoing.
3714     // C argument in register AND stack slot.
3715     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
3716   %}
3717 
3718   // Location of native (C/C++) and interpreter return values. This
3719   // is specified to be the same as Java. In the 32-bit VM, long
3720   // values are actually returned from native calls in O0:O1 and
3721   // returned to the interpreter in I0:I1. The copying to and from
3722   // the register pairs is done by the appropriate call and epilog
3723   // opcodes. This simplifies the register allocator.
3724   c_return_value %{
3725     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
3726             (ideal_reg == Op_RegN &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0),
3727             "only return normal values");
3728     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
3729     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
3730     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
3731     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
3732   %}
3733 
3734   // Location of compiled Java return values.  Same as C
3735   return_value %{
3736     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
3737             (ideal_reg == Op_RegN &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0),
3738             "only return normal values");
3739     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
3740     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
3741     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
3742     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
3743   %}
3744 %}
3745 
3746 
3747 //----------ATTRIBUTES---------------------------------------------------------
3748 
3749 //----------Operand Attributes-------------------------------------------------
3750 op_attrib op_cost(1);          // Required cost attribute.
3751 
3752 //----------Instruction Attributes---------------------------------------------
3753 
3754 // Cost attribute. required.
3755 ins_attrib ins_cost(DEFAULT_COST);
3756 
3757 // Is this instruction a non-matching short branch variant of some
3758 // long branch? Not required.
3759 ins_attrib ins_short_branch(0);
3760 
3761 ins_attrib ins_is_TrapBasedCheckNode(true);
3762 
3763 // Number of constants.
3764 // This instruction uses the given number of constants
3765 // (optional attribute).
3766 // This is needed to determine in time whether the constant pool will
3767 // exceed 4000 entries. Before postalloc_expand the overall number of constants
3768 // is determined. It's also used to compute the constant pool size
3769 // in Output().
3770 ins_attrib ins_num_consts(0);
3771 
3772 // Required alignment attribute (must be a power of 2) specifies the
3773 // alignment that some part of the instruction (not necessarily the
3774 // start) requires. If &gt; 1, a compute_padding() function must be
3775 // provided for the instruction.
3776 ins_attrib ins_alignment(1);
3777 
3778 // Enforce/prohibit rematerializations.
3779 // - If an instruction is attributed with 'ins_cannot_rematerialize(true)'
3780 //   then rematerialization of that instruction is prohibited and the
3781 //   instruction's value will be spilled if necessary.
3782 //   Causes that MachNode::rematerialize() returns false.
3783 // - If an instruction is attributed with 'ins_should_rematerialize(true)'
3784 //   then rematerialization should be enforced and a copy of the instruction
3785 //   should be inserted if possible; rematerialization is not guaranteed.
3786 //   Note: this may result in rematerializations in front of every use.
3787 //   Causes that MachNode::rematerialize() can return true.
3788 // (optional attribute)
3789 ins_attrib ins_cannot_rematerialize(false);
3790 ins_attrib ins_should_rematerialize(false);
3791 
3792 // Instruction has variable size depending on alignment.
3793 ins_attrib ins_variable_size_depending_on_alignment(false);
3794 
3795 // Instruction is a nop.
3796 ins_attrib ins_is_nop(false);
3797 
3798 // Instruction is mapped to a MachIfFastLock node (instead of MachFastLock).
3799 ins_attrib ins_use_mach_if_fast_lock_node(false);
3800 
3801 // Field for the toc offset of a constant.
3802 //
3803 // This is needed if the toc offset is not encodable as an immediate in
3804 // the PPC load instruction. If so, the upper (hi) bits of the offset are
3805 // added to the toc, and from this a load with immediate is performed.
3806 // With postalloc expand, we get two nodes that require the same offset
3807 // but which don't know about each other. The offset is only known
3808 // when the constant is added to the constant pool during emitting.
3809 // It is generated in the 'hi'-node adding the upper bits, and saved
3810 // in this node.  The 'lo'-node has a link to the 'hi'-node and reads
3811 // the offset from there when it gets encoded.
3812 ins_attrib ins_field_const_toc_offset(0);
3813 ins_attrib ins_field_const_toc_offset_hi_node(0);
3814 
3815 // A field that can hold the instructions offset in the code buffer.
3816 // Set in the nodes emitter.
3817 ins_attrib ins_field_cbuf_insts_offset(-1);
3818 
3819 // Fields for referencing a call's load-IC-node.
3820 // If the toc offset can not be encoded as an immediate in a load, we
3821 // use two nodes.
3822 ins_attrib ins_field_load_ic_hi_node(0);
3823 ins_attrib ins_field_load_ic_node(0);
3824 
3825 //----------OPERANDS-----------------------------------------------------------
3826 // Operand definitions must precede instruction definitions for correct
3827 // parsing in the ADLC because operands constitute user defined types
3828 // which are used in instruction definitions.
3829 //
3830 // Formats are generated automatically for constants and base registers.
3831 
3832 //----------Simple Operands----------------------------------------------------
3833 // Immediate Operands
3834 
3835 // Integer Immediate: 32-bit
3836 operand immI() %{
3837   match(ConI);
3838   op_cost(40);
3839   format %{ %}
3840   interface(CONST_INTER);
3841 %}
3842 
3843 operand immI8() %{
3844   predicate(Assembler::is_simm(n-&gt;get_int(), 8));
3845   op_cost(0);
3846   match(ConI);
3847   format %{ %}
3848   interface(CONST_INTER);
3849 %}
3850 
3851 // Integer Immediate: 16-bit
3852 operand immI16() %{
3853   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
3854   op_cost(0);
3855   match(ConI);
3856   format %{ %}
3857   interface(CONST_INTER);
3858 %}
3859 
3860 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
3861 operand immIhi16() %{
3862   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
3863   match(ConI);
3864   op_cost(0);
3865   format %{ %}
3866   interface(CONST_INTER);
3867 %}
3868 
3869 operand immInegpow2() %{
3870   predicate(is_power_of_2_long((jlong) (julong) (juint) (-(n-&gt;get_int()))));
3871   match(ConI);
3872   op_cost(0);
3873   format %{ %}
3874   interface(CONST_INTER);
3875 %}
3876 
3877 operand immIpow2minus1() %{
3878   predicate(is_power_of_2_long((((jlong) (n-&gt;get_int()))+1)));
3879   match(ConI);
3880   op_cost(0);
3881   format %{ %}
3882   interface(CONST_INTER);
3883 %}
3884 
3885 operand immIpowerOf2() %{
3886   predicate(is_power_of_2_long((((jlong) (julong) (juint) (n-&gt;get_int())))));
3887   match(ConI);
3888   op_cost(0);
3889   format %{ %}
3890   interface(CONST_INTER);
3891 %}
3892 
3893 // Unsigned Integer Immediate: the values 0-31
3894 operand uimmI5() %{
3895   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
3896   match(ConI);
3897   op_cost(0);
3898   format %{ %}
3899   interface(CONST_INTER);
3900 %}
3901 
3902 // Unsigned Integer Immediate: 6-bit
3903 operand uimmI6() %{
3904   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
3905   match(ConI);
3906   op_cost(0);
3907   format %{ %}
3908   interface(CONST_INTER);
3909 %}
3910 
3911 // Unsigned Integer Immediate:  6-bit int, greater than 32
3912 operand uimmI6_ge32() %{
3913   predicate(Assembler::is_uimm(n-&gt;get_int(), 6) &amp;&amp; n-&gt;get_int() &gt;= 32);
3914   match(ConI);
3915   op_cost(0);
3916   format %{ %}
3917   interface(CONST_INTER);
3918 %}
3919 
3920 // Unsigned Integer Immediate: 15-bit
3921 operand uimmI15() %{
3922   predicate(Assembler::is_uimm(n-&gt;get_int(), 15));
3923   match(ConI);
3924   op_cost(0);
3925   format %{ %}
3926   interface(CONST_INTER);
3927 %}
3928 
3929 // Unsigned Integer Immediate: 16-bit
3930 operand uimmI16() %{
3931   predicate(Assembler::is_uimm(n-&gt;get_int(), 16));
3932   match(ConI);
3933   op_cost(0);
3934   format %{ %}
3935   interface(CONST_INTER);
3936 %}
3937 
3938 // constant 'int 0'.
3939 operand immI_0() %{
3940   predicate(n-&gt;get_int() == 0);
3941   match(ConI);
3942   op_cost(0);
3943   format %{ %}
3944   interface(CONST_INTER);
3945 %}
3946 
3947 // constant 'int 1'.
3948 operand immI_1() %{
3949   predicate(n-&gt;get_int() == 1);
3950   match(ConI);
3951   op_cost(0);
3952   format %{ %}
3953   interface(CONST_INTER);
3954 %}
3955 
3956 // constant 'int -1'.
3957 operand immI_minus1() %{
3958   predicate(n-&gt;get_int() == -1);
3959   match(ConI);
3960   op_cost(0);
3961   format %{ %}
3962   interface(CONST_INTER);
3963 %}
3964 
3965 // int value 16.
3966 operand immI_16() %{
3967   predicate(n-&gt;get_int() == 16);
3968   match(ConI);
3969   op_cost(0);
3970   format %{ %}
3971   interface(CONST_INTER);
3972 %}
3973 
3974 // int value 24.
3975 operand immI_24() %{
3976   predicate(n-&gt;get_int() == 24);
3977   match(ConI);
3978   op_cost(0);
3979   format %{ %}
3980   interface(CONST_INTER);
3981 %}
3982 
3983 // Compressed oops constants
3984 // Pointer Immediate
3985 operand immN() %{
3986   match(ConN);
3987 
3988   op_cost(10);
3989   format %{ %}
3990   interface(CONST_INTER);
3991 %}
3992 
3993 // NULL Pointer Immediate
3994 operand immN_0() %{
3995   predicate(n-&gt;get_narrowcon() == 0);
3996   match(ConN);
3997 
3998   op_cost(0);
3999   format %{ %}
4000   interface(CONST_INTER);
4001 %}
4002 
4003 // Compressed klass constants
4004 operand immNKlass() %{
4005   match(ConNKlass);
4006 
4007   op_cost(0);
4008   format %{ %}
4009   interface(CONST_INTER);
4010 %}
4011 
4012 // This operand can be used to avoid matching of an instruct
4013 // with chain rule.
4014 operand immNKlass_NM() %{
4015   match(ConNKlass);
4016   predicate(false);
4017   op_cost(0);
4018   format %{ %}
4019   interface(CONST_INTER);
4020 %}
4021 
4022 // Pointer Immediate: 64-bit
4023 operand immP() %{
4024   match(ConP);
4025   op_cost(0);
4026   format %{ %}
4027   interface(CONST_INTER);
4028 %}
4029 
4030 // Operand to avoid match of loadConP.
4031 // This operand can be used to avoid matching of an instruct
4032 // with chain rule.
4033 operand immP_NM() %{
4034   match(ConP);
4035   predicate(false);
4036   op_cost(0);
4037   format %{ %}
4038   interface(CONST_INTER);
4039 %}
4040 
4041 // costant 'pointer 0'.
4042 operand immP_0() %{
4043   predicate(n-&gt;get_ptr() == 0);
4044   match(ConP);
4045   op_cost(0);
4046   format %{ %}
4047   interface(CONST_INTER);
4048 %}
4049 
4050 // pointer 0x0 or 0x1
4051 operand immP_0or1() %{
4052   predicate((n-&gt;get_ptr() == 0) || (n-&gt;get_ptr() == 1));
4053   match(ConP);
4054   op_cost(0);
4055   format %{ %}
4056   interface(CONST_INTER);
4057 %}
4058 
4059 operand immL() %{
4060   match(ConL);
4061   op_cost(40);
4062   format %{ %}
4063   interface(CONST_INTER);
4064 %}
4065 
4066 operand immLmax30() %{
4067   predicate((n-&gt;get_long() &lt;= 30));
4068   match(ConL);
4069   op_cost(0);
4070   format %{ %}
4071   interface(CONST_INTER);
4072 %}
4073 
4074 // Long Immediate: 16-bit
4075 operand immL16() %{
4076   predicate(Assembler::is_simm(n-&gt;get_long(), 16));
4077   match(ConL);
4078   op_cost(0);
4079   format %{ %}
4080   interface(CONST_INTER);
4081 %}
4082 
4083 // Long Immediate: 16-bit, 4-aligned
4084 operand immL16Alg4() %{
4085   predicate(Assembler::is_simm(n-&gt;get_long(), 16) &amp;&amp; ((n-&gt;get_long() &amp; 0x3) == 0));
4086   match(ConL);
4087   op_cost(0);
4088   format %{ %}
4089   interface(CONST_INTER);
4090 %}
4091 
4092 // Long Immediate: 32-bit, where lowest 16 bits are 0x0000.
4093 operand immL32hi16() %{
4094   predicate(Assembler::is_simm(n-&gt;get_long(), 32) &amp;&amp; ((n-&gt;get_long() &amp; 0xffffL) == 0L));
4095   match(ConL);
4096   op_cost(0);
4097   format %{ %}
4098   interface(CONST_INTER);
4099 %}
4100 
4101 // Long Immediate: 32-bit
4102 operand immL32() %{
4103   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
4104   match(ConL);
4105   op_cost(0);
4106   format %{ %}
4107   interface(CONST_INTER);
4108 %}
4109 
4110 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
4111 operand immLhighest16() %{
4112   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
4113   match(ConL);
4114   op_cost(0);
4115   format %{ %}
4116   interface(CONST_INTER);
4117 %}
4118 
4119 operand immLnegpow2() %{
4120   predicate(is_power_of_2_long((jlong)-(n-&gt;get_long())));
4121   match(ConL);
4122   op_cost(0);
4123   format %{ %}
4124   interface(CONST_INTER);
4125 %}
4126 
4127 operand immLpow2minus1() %{
4128   predicate(is_power_of_2_long((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;
4129             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
4130   match(ConL);
4131   op_cost(0);
4132   format %{ %}
4133   interface(CONST_INTER);
4134 %}
4135 
4136 // constant 'long 0'.
4137 operand immL_0() %{
4138   predicate(n-&gt;get_long() == 0L);
4139   match(ConL);
4140   op_cost(0);
4141   format %{ %}
4142   interface(CONST_INTER);
4143 %}
4144 
4145 // constat ' long -1'.
4146 operand immL_minus1() %{
4147   predicate(n-&gt;get_long() == -1L);
4148   match(ConL);
4149   op_cost(0);
4150   format %{ %}
4151   interface(CONST_INTER);
4152 %}
4153 
4154 // Long Immediate: low 32-bit mask
4155 operand immL_32bits() %{
4156   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
4157   match(ConL);
4158   op_cost(0);
4159   format %{ %}
4160   interface(CONST_INTER);
4161 %}
4162 
4163 // Unsigned Long Immediate: 16-bit
4164 operand uimmL16() %{
4165   predicate(Assembler::is_uimm(n-&gt;get_long(), 16));
4166   match(ConL);
4167   op_cost(0);
4168   format %{ %}
4169   interface(CONST_INTER);
4170 %}
4171 
4172 // Float Immediate
4173 operand immF() %{
4174   match(ConF);
4175   op_cost(40);
4176   format %{ %}
4177   interface(CONST_INTER);
4178 %}
4179 
4180 // Float Immediate: +0.0f.
4181 operand immF_0() %{
4182   predicate(jint_cast(n-&gt;getf()) == 0);
4183   match(ConF);
4184 
4185   op_cost(0);
4186   format %{ %}
4187   interface(CONST_INTER);
4188 %}
4189 
4190 // Double Immediate
4191 operand immD() %{
4192   match(ConD);
4193   op_cost(40);
4194   format %{ %}
4195   interface(CONST_INTER);
4196 %}
4197 
4198 // Integer Register Operands
4199 // Integer Destination Register
4200 // See definition of reg_class bits32_reg_rw.
4201 operand iRegIdst() %{
4202   constraint(ALLOC_IN_RC(bits32_reg_rw));
4203   match(RegI);
4204   match(rscratch1RegI);
4205   match(rscratch2RegI);
4206   match(rarg1RegI);
4207   match(rarg2RegI);
4208   match(rarg3RegI);
4209   match(rarg4RegI);
4210   format %{ %}
4211   interface(REG_INTER);
4212 %}
4213 
4214 // Integer Source Register
4215 // See definition of reg_class bits32_reg_ro.
4216 operand iRegIsrc() %{
4217   constraint(ALLOC_IN_RC(bits32_reg_ro));
4218   match(RegI);
4219   match(rscratch1RegI);
4220   match(rscratch2RegI);
4221   match(rarg1RegI);
4222   match(rarg2RegI);
4223   match(rarg3RegI);
4224   match(rarg4RegI);
4225   format %{ %}
4226   interface(REG_INTER);
4227 %}
4228 
4229 operand rscratch1RegI() %{
4230   constraint(ALLOC_IN_RC(rscratch1_bits32_reg));
4231   match(iRegIdst);
4232   format %{ %}
4233   interface(REG_INTER);
4234 %}
4235 
4236 operand rscratch2RegI() %{
4237   constraint(ALLOC_IN_RC(rscratch2_bits32_reg));
4238   match(iRegIdst);
4239   format %{ %}
4240   interface(REG_INTER);
4241 %}
4242 
4243 operand rarg1RegI() %{
4244   constraint(ALLOC_IN_RC(rarg1_bits32_reg));
4245   match(iRegIdst);
4246   format %{ %}
4247   interface(REG_INTER);
4248 %}
4249 
4250 operand rarg2RegI() %{
4251   constraint(ALLOC_IN_RC(rarg2_bits32_reg));
4252   match(iRegIdst);
4253   format %{ %}
4254   interface(REG_INTER);
4255 %}
4256 
4257 operand rarg3RegI() %{
4258   constraint(ALLOC_IN_RC(rarg3_bits32_reg));
4259   match(iRegIdst);
4260   format %{ %}
4261   interface(REG_INTER);
4262 %}
4263 
4264 operand rarg4RegI() %{
4265   constraint(ALLOC_IN_RC(rarg4_bits32_reg));
4266   match(iRegIdst);
4267   format %{ %}
4268   interface(REG_INTER);
4269 %}
4270 
4271 operand rarg1RegL() %{
4272   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
4273   match(iRegLdst);
4274   format %{ %}
4275   interface(REG_INTER);
4276 %}
4277 
4278 operand rarg2RegL() %{
4279   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
4280   match(iRegLdst);
4281   format %{ %}
4282   interface(REG_INTER);
4283 %}
4284 
4285 operand rarg3RegL() %{
4286   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
4287   match(iRegLdst);
4288   format %{ %}
4289   interface(REG_INTER);
4290 %}
4291 
4292 operand rarg4RegL() %{
4293   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
4294   match(iRegLdst);
4295   format %{ %}
4296   interface(REG_INTER);
4297 %}
4298 
4299 // Pointer Destination Register
4300 // See definition of reg_class bits64_reg_rw.
4301 operand iRegPdst() %{
4302   constraint(ALLOC_IN_RC(bits64_reg_rw));
4303   match(RegP);
4304   match(rscratch1RegP);
4305   match(rscratch2RegP);
4306   match(rarg1RegP);
4307   match(rarg2RegP);
4308   match(rarg3RegP);
4309   match(rarg4RegP);
4310   format %{ %}
4311   interface(REG_INTER);
4312 %}
4313 
4314 // Pointer Destination Register
4315 // Operand not using r11 and r12 (killed in epilog).
4316 operand iRegPdstNoScratch() %{
4317   constraint(ALLOC_IN_RC(bits64_reg_leaf_call));
4318   match(RegP);
4319   match(rarg1RegP);
4320   match(rarg2RegP);
4321   match(rarg3RegP);
4322   match(rarg4RegP);
4323   format %{ %}
4324   interface(REG_INTER);
4325 %}
4326 
4327 // Pointer Source Register
4328 // See definition of reg_class bits64_reg_ro.
4329 operand iRegPsrc() %{
4330   constraint(ALLOC_IN_RC(bits64_reg_ro));
4331   match(RegP);
4332   match(iRegPdst);
4333   match(rscratch1RegP);
4334   match(rscratch2RegP);
4335   match(rarg1RegP);
4336   match(rarg2RegP);
4337   match(rarg3RegP);
4338   match(rarg4RegP);
4339   match(threadRegP);
4340   format %{ %}
4341   interface(REG_INTER);
4342 %}
4343 
4344 // Thread operand.
4345 operand threadRegP() %{
4346   constraint(ALLOC_IN_RC(thread_bits64_reg));
4347   match(iRegPdst);
4348   format %{ "R16" %}
4349   interface(REG_INTER);
4350 %}
4351 
4352 operand rscratch1RegP() %{
4353   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
4354   match(iRegPdst);
4355   format %{ "R11" %}
4356   interface(REG_INTER);
4357 %}
4358 
4359 operand rscratch2RegP() %{
4360   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
4361   match(iRegPdst);
4362   format %{ %}
4363   interface(REG_INTER);
4364 %}
4365 
4366 operand rarg1RegP() %{
4367   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
4368   match(iRegPdst);
4369   format %{ %}
4370   interface(REG_INTER);
4371 %}
4372 
4373 operand rarg2RegP() %{
4374   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
4375   match(iRegPdst);
4376   format %{ %}
4377   interface(REG_INTER);
4378 %}
4379 
4380 operand rarg3RegP() %{
4381   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
4382   match(iRegPdst);
4383   format %{ %}
4384   interface(REG_INTER);
4385 %}
4386 
4387 operand rarg4RegP() %{
4388   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
4389   match(iRegPdst);
4390   format %{ %}
4391   interface(REG_INTER);
4392 %}
4393 
4394 operand iRegNsrc() %{
4395   constraint(ALLOC_IN_RC(bits32_reg_ro));
4396   match(RegN);
4397   match(iRegNdst);
4398 
4399   format %{ %}
4400   interface(REG_INTER);
4401 %}
4402 
4403 operand iRegNdst() %{
4404   constraint(ALLOC_IN_RC(bits32_reg_rw));
4405   match(RegN);
4406 
4407   format %{ %}
4408   interface(REG_INTER);
4409 %}
4410 
4411 // Long Destination Register
4412 // See definition of reg_class bits64_reg_rw.
4413 operand iRegLdst() %{
4414   constraint(ALLOC_IN_RC(bits64_reg_rw));
4415   match(RegL);
4416   match(rscratch1RegL);
4417   match(rscratch2RegL);
4418   format %{ %}
4419   interface(REG_INTER);
4420 %}
4421 
4422 // Long Source Register
4423 // See definition of reg_class bits64_reg_ro.
4424 operand iRegLsrc() %{
4425   constraint(ALLOC_IN_RC(bits64_reg_ro));
4426   match(RegL);
4427   match(iRegLdst);
4428   match(rscratch1RegL);
4429   match(rscratch2RegL);
4430   format %{ %}
4431   interface(REG_INTER);
4432 %}
4433 
4434 // Special operand for ConvL2I.
4435 operand iRegL2Isrc(iRegLsrc reg) %{
4436   constraint(ALLOC_IN_RC(bits64_reg_ro));
4437   match(ConvL2I reg);
4438   format %{ "ConvL2I($reg)" %}
4439   interface(REG_INTER)
4440 %}
4441 
4442 operand rscratch1RegL() %{
4443   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
4444   match(RegL);
4445   format %{ %}
4446   interface(REG_INTER);
4447 %}
4448 
4449 operand rscratch2RegL() %{
4450   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
4451   match(RegL);
4452   format %{ %}
4453   interface(REG_INTER);
4454 %}
4455 
4456 // Condition Code Flag Registers
4457 operand flagsReg() %{
4458   constraint(ALLOC_IN_RC(int_flags));
4459   match(RegFlags);
4460   format %{ %}
4461   interface(REG_INTER);
4462 %}
4463 
4464 operand flagsRegSrc() %{
4465   constraint(ALLOC_IN_RC(int_flags_ro));
4466   match(RegFlags);
4467   match(flagsReg);
4468   match(flagsRegCR0);
4469   format %{ %}
4470   interface(REG_INTER);
4471 %}
4472 
4473 // Condition Code Flag Register CR0
4474 operand flagsRegCR0() %{
4475   constraint(ALLOC_IN_RC(int_flags_CR0));
4476   match(RegFlags);
4477   format %{ "CR0" %}
4478   interface(REG_INTER);
4479 %}
4480 
4481 operand flagsRegCR1() %{
4482   constraint(ALLOC_IN_RC(int_flags_CR1));
4483   match(RegFlags);
4484   format %{ "CR1" %}
4485   interface(REG_INTER);
4486 %}
4487 
4488 operand flagsRegCR6() %{
4489   constraint(ALLOC_IN_RC(int_flags_CR6));
4490   match(RegFlags);
4491   format %{ "CR6" %}
4492   interface(REG_INTER);
4493 %}
4494 
4495 operand regCTR() %{
4496   constraint(ALLOC_IN_RC(ctr_reg));
4497   // RegFlags should work. Introducing a RegSpecial type would cause a
4498   // lot of changes.
4499   match(RegFlags);
4500   format %{"SR_CTR" %}
4501   interface(REG_INTER);
4502 %}
4503 
4504 operand regD() %{
4505   constraint(ALLOC_IN_RC(dbl_reg));
4506   match(RegD);
4507   format %{ %}
4508   interface(REG_INTER);
4509 %}
4510 
4511 operand regF() %{
4512   constraint(ALLOC_IN_RC(flt_reg));
4513   match(RegF);
4514   format %{ %}
4515   interface(REG_INTER);
4516 %}
4517 
4518 // Special Registers
4519 
4520 // Method Register
4521 operand inline_cache_regP(iRegPdst reg) %{
4522   constraint(ALLOC_IN_RC(r19_bits64_reg)); // inline_cache_reg
4523   match(reg);
4524   format %{ %}
4525   interface(REG_INTER);
4526 %}
4527 
4528 operand compiler_method_oop_regP(iRegPdst reg) %{
4529   constraint(ALLOC_IN_RC(rscratch1_bits64_reg)); // compiler_method_oop_reg
4530   match(reg);
4531   format %{ %}
4532   interface(REG_INTER);
4533 %}
4534 
4535 operand interpreter_method_oop_regP(iRegPdst reg) %{
4536   constraint(ALLOC_IN_RC(r19_bits64_reg)); // interpreter_method_oop_reg
4537   match(reg);
4538   format %{ %}
4539   interface(REG_INTER);
4540 %}
4541 
4542 // Operands to remove register moves in unscaled mode.
4543 // Match read/write registers with an EncodeP node if neither shift nor add are required.
4544 operand iRegP2N(iRegPsrc reg) %{
4545   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; Universe::narrow_oop_shift() == 0);
4546   constraint(ALLOC_IN_RC(bits64_reg_ro));
4547   match(EncodeP reg);
4548   format %{ "$reg" %}
4549   interface(REG_INTER)
4550 %}
4551 
4552 operand iRegN2P(iRegNsrc reg) %{
4553   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
4554   constraint(ALLOC_IN_RC(bits32_reg_ro));
4555   match(DecodeN reg);
4556   format %{ "$reg" %}
4557   interface(REG_INTER)
4558 %}
4559 
4560 operand iRegN2P_klass(iRegNsrc reg) %{
4561   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);
4562   constraint(ALLOC_IN_RC(bits32_reg_ro));
4563   match(DecodeNKlass reg);
4564   format %{ "$reg" %}
4565   interface(REG_INTER)
4566 %}
4567 
4568 //----------Complex Operands---------------------------------------------------
4569 // Indirect Memory Reference
4570 operand indirect(iRegPsrc reg) %{
4571   constraint(ALLOC_IN_RC(bits64_reg_ro));
4572   match(reg);
4573   op_cost(100);
4574   format %{ "[$reg]" %}
4575   interface(MEMORY_INTER) %{
4576     base($reg);
4577     index(0x0);
4578     scale(0x0);
4579     disp(0x0);
4580   %}
4581 %}
4582 
4583 // Indirect with Offset
4584 operand indOffset16(iRegPsrc reg, immL16 offset) %{
4585   constraint(ALLOC_IN_RC(bits64_reg_ro));
4586   match(AddP reg offset);
4587   op_cost(100);
4588   format %{ "[$reg + $offset]" %}
4589   interface(MEMORY_INTER) %{
4590     base($reg);
4591     index(0x0);
4592     scale(0x0);
4593     disp($offset);
4594   %}
4595 %}
4596 
4597 // Indirect with 4-aligned Offset
4598 operand indOffset16Alg4(iRegPsrc reg, immL16Alg4 offset) %{
4599   constraint(ALLOC_IN_RC(bits64_reg_ro));
4600   match(AddP reg offset);
4601   op_cost(100);
4602   format %{ "[$reg + $offset]" %}
4603   interface(MEMORY_INTER) %{
4604     base($reg);
4605     index(0x0);
4606     scale(0x0);
4607     disp($offset);
4608   %}
4609 %}
4610 
4611 //----------Complex Operands for Compressed OOPs-------------------------------
4612 // Compressed OOPs with narrow_oop_shift == 0.
4613 
4614 // Indirect Memory Reference, compressed OOP
4615 operand indirectNarrow(iRegNsrc reg) %{
4616   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
4617   constraint(ALLOC_IN_RC(bits64_reg_ro));
4618   match(DecodeN reg);
4619   op_cost(100);
4620   format %{ "[$reg]" %}
4621   interface(MEMORY_INTER) %{
4622     base($reg);
4623     index(0x0);
4624     scale(0x0);
4625     disp(0x0);
4626   %}
4627 %}
4628 
4629 operand indirectNarrow_klass(iRegNsrc reg) %{
4630   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);
4631   constraint(ALLOC_IN_RC(bits64_reg_ro));
4632   match(DecodeNKlass reg);
4633   op_cost(100);
4634   format %{ "[$reg]" %}
4635   interface(MEMORY_INTER) %{
4636     base($reg);
4637     index(0x0);
4638     scale(0x0);
4639     disp(0x0);
4640   %}
4641 %}
4642 
4643 // Indirect with Offset, compressed OOP
4644 operand indOffset16Narrow(iRegNsrc reg, immL16 offset) %{
4645   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
4646   constraint(ALLOC_IN_RC(bits64_reg_ro));
4647   match(AddP (DecodeN reg) offset);
4648   op_cost(100);
4649   format %{ "[$reg + $offset]" %}
4650   interface(MEMORY_INTER) %{
4651     base($reg);
4652     index(0x0);
4653     scale(0x0);
4654     disp($offset);
4655   %}
4656 %}
4657 
4658 operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
4659   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);
4660   constraint(ALLOC_IN_RC(bits64_reg_ro));
4661   match(AddP (DecodeNKlass reg) offset);
4662   op_cost(100);
4663   format %{ "[$reg + $offset]" %}
4664   interface(MEMORY_INTER) %{
4665     base($reg);
4666     index(0x0);
4667     scale(0x0);
4668     disp($offset);
4669   %}
4670 %}
4671 
4672 // Indirect with 4-aligned Offset, compressed OOP
4673 operand indOffset16NarrowAlg4(iRegNsrc reg, immL16Alg4 offset) %{
4674   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
4675   constraint(ALLOC_IN_RC(bits64_reg_ro));
4676   match(AddP (DecodeN reg) offset);
4677   op_cost(100);
4678   format %{ "[$reg + $offset]" %}
4679   interface(MEMORY_INTER) %{
4680     base($reg);
4681     index(0x0);
4682     scale(0x0);
4683     disp($offset);
4684   %}
4685 %}
4686 
4687 operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
4688   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);
4689   constraint(ALLOC_IN_RC(bits64_reg_ro));
4690   match(AddP (DecodeNKlass reg) offset);
4691   op_cost(100);
4692   format %{ "[$reg + $offset]" %}
4693   interface(MEMORY_INTER) %{
4694     base($reg);
4695     index(0x0);
4696     scale(0x0);
4697     disp($offset);
4698   %}
4699 %}
4700 
4701 //----------Special Memory Operands--------------------------------------------
4702 // Stack Slot Operand
4703 //
4704 // This operand is used for loading and storing temporary values on
4705 // the stack where a match requires a value to flow through memory.
4706 operand stackSlotI(sRegI reg) %{
4707   constraint(ALLOC_IN_RC(stack_slots));
4708   op_cost(100);
4709   //match(RegI);
4710   format %{ "[sp+$reg]" %}
4711   interface(MEMORY_INTER) %{
4712     base(0x1);   // R1_SP
4713     index(0x0);
4714     scale(0x0);
4715     disp($reg);  // Stack Offset
4716   %}
4717 %}
4718 
4719 operand stackSlotL(sRegL reg) %{
4720   constraint(ALLOC_IN_RC(stack_slots));
4721   op_cost(100);
4722   //match(RegL);
4723   format %{ "[sp+$reg]" %}
4724   interface(MEMORY_INTER) %{
4725     base(0x1);   // R1_SP
4726     index(0x0);
4727     scale(0x0);
4728     disp($reg);  // Stack Offset
4729   %}
4730 %}
4731 
4732 operand stackSlotP(sRegP reg) %{
4733   constraint(ALLOC_IN_RC(stack_slots));
4734   op_cost(100);
4735   //match(RegP);
4736   format %{ "[sp+$reg]" %}
4737   interface(MEMORY_INTER) %{
4738     base(0x1);   // R1_SP
4739     index(0x0);
4740     scale(0x0);
4741     disp($reg);  // Stack Offset
4742   %}
4743 %}
4744 
4745 operand stackSlotF(sRegF reg) %{
4746   constraint(ALLOC_IN_RC(stack_slots));
4747   op_cost(100);
4748   //match(RegF);
4749   format %{ "[sp+$reg]" %}
4750   interface(MEMORY_INTER) %{
4751     base(0x1);   // R1_SP
4752     index(0x0);
4753     scale(0x0);
4754     disp($reg);  // Stack Offset
4755   %}
4756 %}
4757 
4758 operand stackSlotD(sRegD reg) %{
4759   constraint(ALLOC_IN_RC(stack_slots));
4760   op_cost(100);
4761   //match(RegD);
4762   format %{ "[sp+$reg]" %}
4763   interface(MEMORY_INTER) %{
4764     base(0x1);   // R1_SP
4765     index(0x0);
4766     scale(0x0);
4767     disp($reg);  // Stack Offset
4768   %}
4769 %}
4770 
4771 // Operands for expressing Control Flow
4772 // NOTE: Label is a predefined operand which should not be redefined in
4773 //       the AD file. It is generically handled within the ADLC.
4774 
4775 //----------Conditional Branch Operands----------------------------------------
4776 // Comparison Op
4777 //
4778 // This is the operation of the comparison, and is limited to the
4779 // following set of codes: L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE
4780 // (!=).
4781 //
4782 // Other attributes of the comparison, such as unsignedness, are specified
4783 // by the comparison instruction that sets a condition code flags register.
4784 // That result is represented by a flags operand whose subtype is appropriate
4785 // to the unsignedness (etc.) of the comparison.
4786 //
4787 // Later, the instruction which matches both the Comparison Op (a Bool) and
4788 // the flags (produced by the Cmp) specifies the coding of the comparison op
4789 // by matching a specific subtype of Bool operand below.
4790 
4791 // When used for floating point comparisons: unordered same as less.
4792 operand cmpOp() %{
4793   match(Bool);
4794   format %{ "" %}
4795   interface(COND_INTER) %{
4796                            // BO only encodes bit 4 of bcondCRbiIsX, as bits 1-3 are always '100'.
4797                            //           BO          &amp;  BI
4798     equal(0xA);            // 10 10:   bcondCRbiIs1 &amp; Condition::equal
4799     not_equal(0x2);        // 00 10:   bcondCRbiIs0 &amp; Condition::equal
4800     less(0x8);             // 10 00:   bcondCRbiIs1 &amp; Condition::less
4801     greater_equal(0x0);    // 00 00:   bcondCRbiIs0 &amp; Condition::less
4802     less_equal(0x1);       // 00 01:   bcondCRbiIs0 &amp; Condition::greater
4803     greater(0x9);          // 10 01:   bcondCRbiIs1 &amp; Condition::greater
4804     overflow(0xB);         // 10 11:   bcondCRbiIs1 &amp; Condition::summary_overflow
4805     no_overflow(0x3);      // 00 11:   bcondCRbiIs0 &amp; Condition::summary_overflow
4806   %}
4807 %}
4808 
4809 //----------OPERAND CLASSES----------------------------------------------------
4810 // Operand Classes are groups of operands that are used to simplify
4811 // instruction definitions by not requiring the AD writer to specify
4812 // seperate instructions for every form of operand when the
4813 // instruction accepts multiple operand types with the same basic
4814 // encoding and format. The classic case of this is memory operands.
4815 // Indirect is not included since its use is limited to Compare &amp; Swap.
4816 
4817 opclass memory(indirect, indOffset16 /*, indIndex, tlsReference*/, indirectNarrow, indirectNarrow_klass, indOffset16Narrow, indOffset16Narrow_klass);
4818 // Memory operand where offsets are 4-aligned. Required for ld, std.
4819 opclass memoryAlg4(indirect, indOffset16Alg4, indirectNarrow, indOffset16NarrowAlg4, indOffset16NarrowAlg4_klass);
4820 opclass indirectMemory(indirect, indirectNarrow);
4821 
4822 // Special opclass for I and ConvL2I.
4823 opclass iRegIsrc_iRegL2Isrc(iRegIsrc, iRegL2Isrc);
4824 
4825 // Operand classes to match encode and decode. iRegN_P2N is only used
4826 // for storeN. I have never seen an encode node elsewhere.
4827 opclass iRegN_P2N(iRegNsrc, iRegP2N);
4828 opclass iRegP_N2P(iRegPsrc, iRegN2P, iRegN2P_klass);
4829 
4830 //----------PIPELINE-----------------------------------------------------------
4831 
4832 pipeline %{
4833 
4834 // See J.M.Tendler et al. "Power4 system microarchitecture", IBM
4835 // J. Res. &amp; Dev., No. 1, Jan. 2002.
4836 
4837 //----------ATTRIBUTES---------------------------------------------------------
4838 attributes %{
4839 
4840   // Power4 instructions are of fixed length.
4841   fixed_size_instructions;
4842 
4843   // TODO: if `bundle' means number of instructions fetched
4844   // per cycle, this is 8. If `bundle' means Power4 `group', that is
4845   // max instructions issued per cycle, this is 5.
4846   max_instructions_per_bundle = 8;
4847 
4848   // A Power4 instruction is 4 bytes long.
4849   instruction_unit_size = 4;
4850 
4851   // The Power4 processor fetches 64 bytes...
4852   instruction_fetch_unit_size = 64;
4853 
4854   // ...in one line
4855   instruction_fetch_units = 1
4856 
4857   // Unused, list one so that array generated by adlc is not empty.
4858   // Aix compiler chokes if _nop_count = 0.
4859   nops(fxNop);
4860 %}
4861 
4862 //----------RESOURCES----------------------------------------------------------
4863 // Resources are the functional units available to the machine
4864 resources(
4865    PPC_BR,         // branch unit
4866    PPC_CR,         // condition unit
4867    PPC_FX1,        // integer arithmetic unit 1
4868    PPC_FX2,        // integer arithmetic unit 2
4869    PPC_LDST1,      // load/store unit 1
4870    PPC_LDST2,      // load/store unit 2
4871    PPC_FP1,        // float arithmetic unit 1
4872    PPC_FP2,        // float arithmetic unit 2
4873    PPC_LDST = PPC_LDST1 | PPC_LDST2,
4874    PPC_FX = PPC_FX1 | PPC_FX2,
4875    PPC_FP = PPC_FP1 | PPC_FP2
4876  );
4877 
4878 //----------PIPELINE DESCRIPTION-----------------------------------------------
4879 // Pipeline Description specifies the stages in the machine's pipeline
4880 pipe_desc(
4881    // Power4 longest pipeline path
4882    PPC_IF,   // instruction fetch
4883    PPC_IC,
4884    //PPC_BP, // branch prediction
4885    PPC_D0,   // decode
4886    PPC_D1,   // decode
4887    PPC_D2,   // decode
4888    PPC_D3,   // decode
4889    PPC_Xfer1,
4890    PPC_GD,   // group definition
4891    PPC_MP,   // map
4892    PPC_ISS,  // issue
4893    PPC_RF,   // resource fetch
4894    PPC_EX1,  // execute (all units)
4895    PPC_EX2,  // execute (FP, LDST)
4896    PPC_EX3,  // execute (FP, LDST)
4897    PPC_EX4,  // execute (FP)
4898    PPC_EX5,  // execute (FP)
4899    PPC_EX6,  // execute (FP)
4900    PPC_WB,   // write back
4901    PPC_Xfer2,
4902    PPC_CP
4903  );
4904 
4905 //----------PIPELINE CLASSES---------------------------------------------------
4906 // Pipeline Classes describe the stages in which input and output are
4907 // referenced by the hardware pipeline.
4908 
4909 // Simple pipeline classes.
4910 
4911 // Default pipeline class.
4912 pipe_class pipe_class_default() %{
4913   single_instruction;
4914   fixed_latency(2);
4915 %}
4916 
4917 // Pipeline class for empty instructions.
4918 pipe_class pipe_class_empty() %{
4919   single_instruction;
4920   fixed_latency(0);
4921 %}
4922 
4923 // Pipeline class for compares.
4924 pipe_class pipe_class_compare() %{
4925   single_instruction;
4926   fixed_latency(16);
4927 %}
4928 
4929 // Pipeline class for traps.
4930 pipe_class pipe_class_trap() %{
4931   single_instruction;
4932   fixed_latency(100);
4933 %}
4934 
4935 // Pipeline class for memory operations.
4936 pipe_class pipe_class_memory() %{
4937   single_instruction;
4938   fixed_latency(16);
4939 %}
4940 
4941 // Pipeline class for call.
4942 pipe_class pipe_class_call() %{
4943   single_instruction;
4944   fixed_latency(100);
4945 %}
4946 
4947 // Define the class for the Nop node.
4948 define %{
4949    MachNop = pipe_class_default;
4950 %}
4951 
4952 %}
4953 
4954 //----------INSTRUCTIONS-------------------------------------------------------
4955 
4956 // Naming of instructions:
4957 //   opA_operB / opA_operB_operC:
4958 //     Operation 'op' with one or two source operands 'oper'. Result
4959 //     type is A, source operand types are B and C.
4960 //     Iff A == B == C, B and C are left out.
4961 //
4962 // The instructions are ordered according to the following scheme:
4963 //  - loads
4964 //  - load constants
4965 //  - prefetch
4966 //  - store
4967 //  - encode/decode
4968 //  - membar
4969 //  - conditional moves
4970 //  - compare &amp; swap
4971 //  - arithmetic and logic operations
4972 //    * int: Add, Sub, Mul, Div, Mod
4973 //    * int: lShift, arShift, urShift, rot
4974 //    * float: Add, Sub, Mul, Div
4975 //    * and, or, xor ...
4976 //  - register moves: float &lt;-&gt; int, reg &lt;-&gt; stack, repl
4977 //  - cast (high level type cast, XtoP, castPP, castII, not_null etc.
4978 //  - conv (low level type cast requiring bit changes (sign extend etc)
4979 //  - compares, range &amp; zero checks.
4980 //  - branches
4981 //  - complex operations, intrinsics, min, max, replicate
4982 //  - lock
4983 //  - Calls
4984 //
4985 // If there are similar instructions with different types they are sorted:
4986 // int before float
4987 // small before big
4988 // signed before unsigned
4989 // e.g., loadS before loadUS before loadI before loadF.
4990 
4991 
4992 //----------Load/Store Instructions--------------------------------------------
4993 
4994 //----------Load Instructions--------------------------------------------------
4995 
4996 // Converts byte to int.
4997 // As convB2I_reg, but without match rule.  The match rule of convB2I_reg
4998 // reuses the 'amount' operand, but adlc expects that operand specification
4999 // and operands in match rule are equivalent.
5000 instruct convB2I_reg_2(iRegIdst dst, iRegIsrc src) %{
5001   effect(DEF dst, USE src);
5002   format %{ "EXTSB   $dst, $src \t// byte-&gt;int" %}
5003   size(4);
5004   ins_encode %{
5005     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
5006     __ extsb($dst$$Register, $src$$Register);
5007   %}
5008   ins_pipe(pipe_class_default);
5009 %}
5010 
5011 instruct loadUB_indirect(iRegIdst dst, indirectMemory mem) %{
5012   // match-rule, false predicate
5013   match(Set dst (LoadB mem));
5014   predicate(false);
5015 
5016   format %{ "LBZ     $dst, $mem" %}
5017   size(4);
5018   ins_encode( enc_lbz(dst, mem) );
5019   ins_pipe(pipe_class_memory);
5020 %}
5021 
5022 instruct loadUB_indirect_ac(iRegIdst dst, indirectMemory mem) %{
5023   // match-rule, false predicate
5024   match(Set dst (LoadB mem));
5025   predicate(false);
5026 
5027   format %{ "LBZ     $dst, $mem\n\t"
5028             "TWI     $dst\n\t"
5029             "ISYNC" %}
5030   size(12);
5031   ins_encode( enc_lbz_ac(dst, mem) );
5032   ins_pipe(pipe_class_memory);
5033 %}
5034 
5035 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
5036 instruct loadB_indirect_Ex(iRegIdst dst, indirectMemory mem) %{
5037   match(Set dst (LoadB mem));
5038   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5039   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
5040   expand %{
5041     iRegIdst tmp;
5042     loadUB_indirect(tmp, mem);
5043     convB2I_reg_2(dst, tmp);
5044   %}
5045 %}
5046 
5047 instruct loadB_indirect_ac_Ex(iRegIdst dst, indirectMemory mem) %{
5048   match(Set dst (LoadB mem));
5049   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
5050   expand %{
5051     iRegIdst tmp;
5052     loadUB_indirect_ac(tmp, mem);
5053     convB2I_reg_2(dst, tmp);
5054   %}
5055 %}
5056 
5057 instruct loadUB_indOffset16(iRegIdst dst, indOffset16 mem) %{
5058   // match-rule, false predicate
5059   match(Set dst (LoadB mem));
5060   predicate(false);
5061 
5062   format %{ "LBZ     $dst, $mem" %}
5063   size(4);
5064   ins_encode( enc_lbz(dst, mem) );
5065   ins_pipe(pipe_class_memory);
5066 %}
5067 
5068 instruct loadUB_indOffset16_ac(iRegIdst dst, indOffset16 mem) %{
5069   // match-rule, false predicate
5070   match(Set dst (LoadB mem));
5071   predicate(false);
5072 
5073   format %{ "LBZ     $dst, $mem\n\t"
5074             "TWI     $dst\n\t"
5075             "ISYNC" %}
5076   size(12);
5077   ins_encode( enc_lbz_ac(dst, mem) );
5078   ins_pipe(pipe_class_memory);
5079 %}
5080 
5081 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
5082 instruct loadB_indOffset16_Ex(iRegIdst dst, indOffset16 mem) %{
5083   match(Set dst (LoadB mem));
5084   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5085   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
5086 
5087   expand %{
5088     iRegIdst tmp;
5089     loadUB_indOffset16(tmp, mem);
5090     convB2I_reg_2(dst, tmp);
5091   %}
5092 %}
5093 
5094 instruct loadB_indOffset16_ac_Ex(iRegIdst dst, indOffset16 mem) %{
5095   match(Set dst (LoadB mem));
5096   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
5097 
5098   expand %{
5099     iRegIdst tmp;
5100     loadUB_indOffset16_ac(tmp, mem);
5101     convB2I_reg_2(dst, tmp);
5102   %}
5103 %}
5104 
5105 // Load Unsigned Byte (8bit UNsigned) into an int reg.
5106 instruct loadUB(iRegIdst dst, memory mem) %{
5107   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5108   match(Set dst (LoadUB mem));
5109   ins_cost(MEMORY_REF_COST);
5110 
5111   format %{ "LBZ     $dst, $mem \t// byte, zero-extend to int" %}
5112   size(4);
5113   ins_encode( enc_lbz(dst, mem) );
5114   ins_pipe(pipe_class_memory);
5115 %}
5116 
5117 // Load  Unsigned Byte (8bit UNsigned) acquire.
5118 instruct loadUB_ac(iRegIdst dst, memory mem) %{
5119   match(Set dst (LoadUB mem));
5120   ins_cost(3*MEMORY_REF_COST);
5121 
5122   format %{ "LBZ     $dst, $mem \t// byte, zero-extend to int, acquire\n\t"
5123             "TWI     $dst\n\t"
5124             "ISYNC" %}
5125   size(12);
5126   ins_encode( enc_lbz_ac(dst, mem) );
5127   ins_pipe(pipe_class_memory);
5128 %}
5129 
5130 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
5131 instruct loadUB2L(iRegLdst dst, memory mem) %{
5132   match(Set dst (ConvI2L (LoadUB mem)));
5133   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
5134   ins_cost(MEMORY_REF_COST);
5135 
5136   format %{ "LBZ     $dst, $mem \t// byte, zero-extend to long" %}
5137   size(4);
5138   ins_encode( enc_lbz(dst, mem) );
5139   ins_pipe(pipe_class_memory);
5140 %}
5141 
5142 instruct loadUB2L_ac(iRegLdst dst, memory mem) %{
5143   match(Set dst (ConvI2L (LoadUB mem)));
5144   ins_cost(3*MEMORY_REF_COST);
5145 
5146   format %{ "LBZ     $dst, $mem \t// byte, zero-extend to long, acquire\n\t"
5147             "TWI     $dst\n\t"
5148             "ISYNC" %}
5149   size(12);
5150   ins_encode( enc_lbz_ac(dst, mem) );
5151   ins_pipe(pipe_class_memory);
5152 %}
5153 
5154 // Load Short (16bit signed)
5155 instruct loadS(iRegIdst dst, memory mem) %{
5156   match(Set dst (LoadS mem));
5157   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5158   ins_cost(MEMORY_REF_COST);
5159 
5160   format %{ "LHA     $dst, $mem" %}
5161   size(4);
5162   ins_encode %{
5163     // TODO: PPC port $archOpcode(ppc64Opcode_lha);
5164     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5165     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
5166   %}
5167   ins_pipe(pipe_class_memory);
5168 %}
5169 
5170 // Load Short (16bit signed) acquire.
5171 instruct loadS_ac(iRegIdst dst, memory mem) %{
5172   match(Set dst (LoadS mem));
5173   ins_cost(3*MEMORY_REF_COST);
5174 
5175   format %{ "LHA     $dst, $mem\t acquire\n\t"
5176             "TWI     $dst\n\t"
5177             "ISYNC" %}
5178   size(12);
5179   ins_encode %{
5180     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
5181     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5182     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
5183     __ twi_0($dst$$Register);
5184     __ isync();
5185   %}
5186   ins_pipe(pipe_class_memory);
5187 %}
5188 
5189 // Load Char (16bit unsigned)
5190 instruct loadUS(iRegIdst dst, memory mem) %{
5191   match(Set dst (LoadUS mem));
5192   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5193   ins_cost(MEMORY_REF_COST);
5194 
5195   format %{ "LHZ     $dst, $mem" %}
5196   size(4);
5197   ins_encode( enc_lhz(dst, mem) );
5198   ins_pipe(pipe_class_memory);
5199 %}
5200 
5201 // Load Char (16bit unsigned) acquire.
5202 instruct loadUS_ac(iRegIdst dst, memory mem) %{
5203   match(Set dst (LoadUS mem));
5204   ins_cost(3*MEMORY_REF_COST);
5205 
5206   format %{ "LHZ     $dst, $mem \t// acquire\n\t"
5207             "TWI     $dst\n\t"
5208             "ISYNC" %}
5209   size(12);
5210   ins_encode( enc_lhz_ac(dst, mem) );
5211   ins_pipe(pipe_class_memory);
5212 %}
5213 
5214 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
5215 instruct loadUS2L(iRegLdst dst, memory mem) %{
5216   match(Set dst (ConvI2L (LoadUS mem)));
5217   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
5218   ins_cost(MEMORY_REF_COST);
5219 
5220   format %{ "LHZ     $dst, $mem \t// short, zero-extend to long" %}
5221   size(4);
5222   ins_encode( enc_lhz(dst, mem) );
5223   ins_pipe(pipe_class_memory);
5224 %}
5225 
5226 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register acquire.
5227 instruct loadUS2L_ac(iRegLdst dst, memory mem) %{
5228   match(Set dst (ConvI2L (LoadUS mem)));
5229   ins_cost(3*MEMORY_REF_COST);
5230 
5231   format %{ "LHZ     $dst, $mem \t// short, zero-extend to long, acquire\n\t"
5232             "TWI     $dst\n\t"
5233             "ISYNC" %}
5234   size(12);
5235   ins_encode( enc_lhz_ac(dst, mem) );
5236   ins_pipe(pipe_class_memory);
5237 %}
5238 
5239 // Load Integer.
5240 instruct loadI(iRegIdst dst, memory mem) %{
5241   match(Set dst (LoadI mem));
5242   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5243   ins_cost(MEMORY_REF_COST);
5244 
5245   format %{ "LWZ     $dst, $mem" %}
5246   size(4);
5247   ins_encode( enc_lwz(dst, mem) );
5248   ins_pipe(pipe_class_memory);
5249 %}
5250 
5251 // Load Integer acquire.
5252 instruct loadI_ac(iRegIdst dst, memory mem) %{
5253   match(Set dst (LoadI mem));
5254   ins_cost(3*MEMORY_REF_COST);
5255 
5256   format %{ "LWZ     $dst, $mem \t// load acquire\n\t"
5257             "TWI     $dst\n\t"
5258             "ISYNC" %}
5259   size(12);
5260   ins_encode( enc_lwz_ac(dst, mem) );
5261   ins_pipe(pipe_class_memory);
5262 %}
5263 
5264 // Match loading integer and casting it to unsigned int in
5265 // long register.
5266 // LoadI + ConvI2L + AndL 0xffffffff.
5267 instruct loadUI2L(iRegLdst dst, memory mem, immL_32bits mask) %{
5268   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
5269   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
5270   ins_cost(MEMORY_REF_COST);
5271 
5272   format %{ "LWZ     $dst, $mem \t// zero-extend to long" %}
5273   size(4);
5274   ins_encode( enc_lwz(dst, mem) );
5275   ins_pipe(pipe_class_memory);
5276 %}
5277 
5278 // Match loading integer and casting it to long.
5279 instruct loadI2L(iRegLdst dst, memoryAlg4 mem) %{
5280   match(Set dst (ConvI2L (LoadI mem)));
5281   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
5282   ins_cost(MEMORY_REF_COST);
5283 
5284   format %{ "LWA     $dst, $mem \t// loadI2L" %}
5285   size(4);
5286   ins_encode %{
5287     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
5288     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5289     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
5290   %}
5291   ins_pipe(pipe_class_memory);
5292 %}
5293 
5294 // Match loading integer and casting it to long - acquire.
5295 instruct loadI2L_ac(iRegLdst dst, memoryAlg4 mem) %{
5296   match(Set dst (ConvI2L (LoadI mem)));
5297   ins_cost(3*MEMORY_REF_COST);
5298 
5299   format %{ "LWA     $dst, $mem \t// loadI2L acquire"
5300             "TWI     $dst\n\t"
5301             "ISYNC" %}
5302   size(12);
5303   ins_encode %{
5304     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
5305     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5306     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
5307     __ twi_0($dst$$Register);
5308     __ isync();
5309   %}
5310   ins_pipe(pipe_class_memory);
5311 %}
5312 
5313 // Load Long - aligned
5314 instruct loadL(iRegLdst dst, memoryAlg4 mem) %{
5315   match(Set dst (LoadL mem));
5316   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5317   ins_cost(MEMORY_REF_COST);
5318 
5319   format %{ "LD      $dst, $mem \t// long" %}
5320   size(4);
5321   ins_encode( enc_ld(dst, mem) );
5322   ins_pipe(pipe_class_memory);
5323 %}
5324 
5325 // Load Long - aligned acquire.
5326 instruct loadL_ac(iRegLdst dst, memoryAlg4 mem) %{
5327   match(Set dst (LoadL mem));
5328   ins_cost(3*MEMORY_REF_COST);
5329 
5330   format %{ "LD      $dst, $mem \t// long acquire\n\t"
5331             "TWI     $dst\n\t"
5332             "ISYNC" %}
5333   size(12);
5334   ins_encode( enc_ld_ac(dst, mem) );
5335   ins_pipe(pipe_class_memory);
5336 %}
5337 
5338 // Load Long - UNaligned
5339 instruct loadL_unaligned(iRegLdst dst, memoryAlg4 mem) %{
5340   match(Set dst (LoadL_unaligned mem));
5341   // predicate(...) // Unaligned_ac is not needed (and wouldn't make sense).
5342   ins_cost(MEMORY_REF_COST);
5343 
5344   format %{ "LD      $dst, $mem \t// unaligned long" %}
5345   size(4);
5346   ins_encode( enc_ld(dst, mem) );
5347   ins_pipe(pipe_class_memory);
5348 %}
5349 
5350 // Load nodes for superwords
5351 
5352 // Load Aligned Packed Byte
5353 instruct loadV8(iRegLdst dst, memoryAlg4 mem) %{
5354   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
5355   match(Set dst (LoadVector mem));
5356   ins_cost(MEMORY_REF_COST);
5357 
5358   format %{ "LD      $dst, $mem \t// load 8-byte Vector" %}
5359   size(4);
5360   ins_encode( enc_ld(dst, mem) );
5361   ins_pipe(pipe_class_memory);
5362 %}
5363 
5364 // Load Range, range = array length (=jint)
5365 instruct loadRange(iRegIdst dst, memory mem) %{
5366   match(Set dst (LoadRange mem));
5367   ins_cost(MEMORY_REF_COST);
5368 
5369   format %{ "LWZ     $dst, $mem \t// range" %}
5370   size(4);
5371   ins_encode( enc_lwz(dst, mem) );
5372   ins_pipe(pipe_class_memory);
5373 %}
5374 
5375 // Load Compressed Pointer
5376 instruct loadN(iRegNdst dst, memory mem) %{
5377   match(Set dst (LoadN mem));
5378   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5379   ins_cost(MEMORY_REF_COST);
5380 
5381   format %{ "LWZ     $dst, $mem \t// load compressed ptr" %}
5382   size(4);
5383   ins_encode( enc_lwz(dst, mem) );
5384   ins_pipe(pipe_class_memory);
5385 %}
5386 
5387 // Load Compressed Pointer acquire.
5388 instruct loadN_ac(iRegNdst dst, memory mem) %{
5389   match(Set dst (LoadN mem));
5390   ins_cost(3*MEMORY_REF_COST);
5391 
5392   format %{ "LWZ     $dst, $mem \t// load acquire compressed ptr\n\t"
5393             "TWI     $dst\n\t"
5394             "ISYNC" %}
5395   size(12);
5396   ins_encode( enc_lwz_ac(dst, mem) );
5397   ins_pipe(pipe_class_memory);
5398 %}
5399 
5400 // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
5401 instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
5402   match(Set dst (DecodeN (LoadN mem)));
5403   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; Universe::narrow_oop_shift() == 0);
5404   ins_cost(MEMORY_REF_COST);
5405 
5406   format %{ "LWZ     $dst, $mem \t// DecodeN (unscaled)" %}
5407   size(4);
5408   ins_encode( enc_lwz(dst, mem) );
5409   ins_pipe(pipe_class_memory);
5410 %}
5411 
5412 instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
5413   match(Set dst (DecodeNKlass (LoadNKlass mem)));
5414   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0 &amp;&amp;
5415             _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
5416   ins_cost(MEMORY_REF_COST);
5417 
5418   format %{ "LWZ     $dst, $mem \t// DecodeN (unscaled)" %}
5419   size(4);
5420   ins_encode( enc_lwz(dst, mem) );
5421   ins_pipe(pipe_class_memory);
5422 %}
5423 
5424 // Load Pointer
5425 instruct loadP(iRegPdst dst, memoryAlg4 mem) %{
5426   match(Set dst (LoadP mem));
5427   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5428   ins_cost(MEMORY_REF_COST);
5429 
5430   format %{ "LD      $dst, $mem \t// ptr" %}
5431   size(4);
5432   ins_encode( enc_ld(dst, mem) );
5433   ins_pipe(pipe_class_memory);
5434 %}
5435 
5436 // Load Pointer acquire.
5437 instruct loadP_ac(iRegPdst dst, memoryAlg4 mem) %{
5438   match(Set dst (LoadP mem));
5439   ins_cost(3*MEMORY_REF_COST);
5440 
5441   format %{ "LD      $dst, $mem \t// ptr acquire\n\t"
5442             "TWI     $dst\n\t"
5443             "ISYNC" %}
5444   size(12);
5445   ins_encode( enc_ld_ac(dst, mem) );
5446   ins_pipe(pipe_class_memory);
5447 %}
5448 
5449 // LoadP + CastP2L
5450 instruct loadP2X(iRegLdst dst, memoryAlg4 mem) %{
5451   match(Set dst (CastP2X (LoadP mem)));
5452   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
5453   ins_cost(MEMORY_REF_COST);
5454 
5455   format %{ "LD      $dst, $mem \t// ptr + p2x" %}
5456   size(4);
5457   ins_encode( enc_ld(dst, mem) );
5458   ins_pipe(pipe_class_memory);
5459 %}
5460 
5461 // Load compressed klass pointer.
5462 instruct loadNKlass(iRegNdst dst, memory mem) %{
5463   match(Set dst (LoadNKlass mem));
5464   ins_cost(MEMORY_REF_COST);
5465 
5466   format %{ "LWZ     $dst, $mem \t// compressed klass ptr" %}
5467   size(4);
5468   ins_encode( enc_lwz(dst, mem) );
5469   ins_pipe(pipe_class_memory);
5470 %}
5471 
5472 // Load Klass Pointer
5473 instruct loadKlass(iRegPdst dst, memoryAlg4 mem) %{
5474   match(Set dst (LoadKlass mem));
5475   ins_cost(MEMORY_REF_COST);
5476 
5477   format %{ "LD      $dst, $mem \t// klass ptr" %}
5478   size(4);
5479   ins_encode( enc_ld(dst, mem) );
5480   ins_pipe(pipe_class_memory);
5481 %}
5482 
5483 // Load Float
5484 instruct loadF(regF dst, memory mem) %{
5485   match(Set dst (LoadF mem));
5486   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5487   ins_cost(MEMORY_REF_COST);
5488 
5489   format %{ "LFS     $dst, $mem" %}
5490   size(4);
5491   ins_encode %{
5492     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
5493     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5494     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
5495   %}
5496   ins_pipe(pipe_class_memory);
5497 %}
5498 
5499 // Load Float acquire.
5500 instruct loadF_ac(regF dst, memory mem, flagsRegCR0 cr0) %{
5501   match(Set dst (LoadF mem));
5502   effect(TEMP cr0);
5503   ins_cost(3*MEMORY_REF_COST);
5504 
5505   format %{ "LFS     $dst, $mem \t// acquire\n\t"
5506             "FCMPU   cr0, $dst, $dst\n\t"
5507             "BNE     cr0, next\n"
5508             "next:\n\t"
5509             "ISYNC" %}
5510   size(16);
5511   ins_encode %{
5512     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
5513     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5514     Label next;
5515     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
5516     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
5517     __ bne(CCR0, next);
5518     __ bind(next);
5519     __ isync();
5520   %}
5521   ins_pipe(pipe_class_memory);
5522 %}
5523 
5524 // Load Double - aligned
5525 instruct loadD(regD dst, memory mem) %{
5526   match(Set dst (LoadD mem));
5527   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5528   ins_cost(MEMORY_REF_COST);
5529 
5530   format %{ "LFD     $dst, $mem" %}
5531   size(4);
5532   ins_encode( enc_lfd(dst, mem) );
5533   ins_pipe(pipe_class_memory);
5534 %}
5535 
5536 // Load Double - aligned acquire.
5537 instruct loadD_ac(regD dst, memory mem, flagsRegCR0 cr0) %{
5538   match(Set dst (LoadD mem));
5539   effect(TEMP cr0);
5540   ins_cost(3*MEMORY_REF_COST);
5541 
5542   format %{ "LFD     $dst, $mem \t// acquire\n\t"
5543             "FCMPU   cr0, $dst, $dst\n\t"
5544             "BNE     cr0, next\n"
5545             "next:\n\t"
5546             "ISYNC" %}
5547   size(16);
5548   ins_encode %{
5549     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
5550     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5551     Label next;
5552     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
5553     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
5554     __ bne(CCR0, next);
5555     __ bind(next);
5556     __ isync();
5557   %}
5558   ins_pipe(pipe_class_memory);
5559 %}
5560 
5561 // Load Double - UNaligned
5562 instruct loadD_unaligned(regD dst, memory mem) %{
5563   match(Set dst (LoadD_unaligned mem));
5564   // predicate(...) // Unaligned_ac is not needed (and wouldn't make sense).
5565   ins_cost(MEMORY_REF_COST);
5566 
5567   format %{ "LFD     $dst, $mem" %}
5568   size(4);
5569   ins_encode( enc_lfd(dst, mem) );
5570   ins_pipe(pipe_class_memory);
5571 %}
5572 
5573 //----------Constants--------------------------------------------------------
5574 
5575 // Load MachConstantTableBase: add hi offset to global toc.
5576 // TODO: Handle hidden register r29 in bundler!
5577 instruct loadToc_hi(iRegLdst dst) %{
5578   effect(DEF dst);
5579   ins_cost(DEFAULT_COST);
5580 
5581   format %{ "ADDIS   $dst, R29, DISP.hi \t// load TOC hi" %}
5582   size(4);
5583   ins_encode %{
5584     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
5585     __ calculate_address_from_global_toc_hi16only($dst$$Register, __ method_toc());
5586   %}
5587   ins_pipe(pipe_class_default);
5588 %}
5589 
5590 // Load MachConstantTableBase: add lo offset to global toc.
5591 instruct loadToc_lo(iRegLdst dst, iRegLdst src) %{
5592   effect(DEF dst, USE src);
5593   ins_cost(DEFAULT_COST);
5594 
5595   format %{ "ADDI    $dst, $src, DISP.lo \t// load TOC lo" %}
5596   size(4);
5597   ins_encode %{
5598     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
5599     __ calculate_address_from_global_toc_lo16only($dst$$Register, __ method_toc());
5600   %}
5601   ins_pipe(pipe_class_default);
5602 %}
5603 
5604 // Load 16-bit integer constant 0xssss????
5605 instruct loadConI16(iRegIdst dst, immI16 src) %{
5606   match(Set dst src);
5607 
5608   format %{ "LI      $dst, $src" %}
5609   size(4);
5610   ins_encode %{
5611     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
5612     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
5613   %}
5614   ins_pipe(pipe_class_default);
5615 %}
5616 
5617 // Load integer constant 0x????0000
5618 instruct loadConIhi16(iRegIdst dst, immIhi16 src) %{
5619   match(Set dst src);
5620   ins_cost(DEFAULT_COST);
5621 
5622   format %{ "LIS     $dst, $src.hi" %}
5623   size(4);
5624   ins_encode %{
5625     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
5626     // Lis sign extends 16-bit src then shifts it 16 bit to the left.
5627     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
5628   %}
5629   ins_pipe(pipe_class_default);
5630 %}
5631 
5632 // Part 2 of loading 32 bit constant: hi16 is is src1 (properly shifted
5633 // and sign extended), this adds the low 16 bits.
5634 instruct loadConI32_lo16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
5635   // no match-rule, false predicate
5636   effect(DEF dst, USE src1, USE src2);
5637   predicate(false);
5638 
5639   format %{ "ORI     $dst, $src1.hi, $src2.lo" %}
5640   size(4);
5641   ins_encode %{
5642     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
5643     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
5644   %}
5645   ins_pipe(pipe_class_default);
5646 %}
5647 
5648 instruct loadConI_Ex(iRegIdst dst, immI src) %{
5649   match(Set dst src);
5650   ins_cost(DEFAULT_COST*2);
5651 
5652   expand %{
5653     // Would like to use $src$$constant.
5654     immI16 srcLo %{ _opnds[1]-&gt;constant() %}
5655     // srcHi can be 0000 if srcLo sign-extends to a negative number.
5656     immIhi16 srcHi %{ _opnds[1]-&gt;constant() %}
5657     iRegIdst tmpI;
5658     loadConIhi16(tmpI, srcHi);
5659     loadConI32_lo16(dst, tmpI, srcLo);
5660   %}
5661 %}
5662 
5663 // No constant pool entries required.
5664 instruct loadConL16(iRegLdst dst, immL16 src) %{
5665   match(Set dst src);
5666 
5667   format %{ "LI      $dst, $src \t// long" %}
5668   size(4);
5669   ins_encode %{
5670     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
5671     __ li($dst$$Register, (int)((short) ($src$$constant &amp; 0xFFFF)));
5672   %}
5673   ins_pipe(pipe_class_default);
5674 %}
5675 
5676 // Load long constant 0xssssssss????0000
5677 instruct loadConL32hi16(iRegLdst dst, immL32hi16 src) %{
5678   match(Set dst src);
5679   ins_cost(DEFAULT_COST);
5680 
5681   format %{ "LIS     $dst, $src.hi \t// long" %}
5682   size(4);
5683   ins_encode %{
5684     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
5685     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
5686   %}
5687   ins_pipe(pipe_class_default);
5688 %}
5689 
5690 // To load a 32 bit constant: merge lower 16 bits into already loaded
5691 // high 16 bits.
5692 instruct loadConL32_lo16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
5693   // no match-rule, false predicate
5694   effect(DEF dst, USE src1, USE src2);
5695   predicate(false);
5696 
5697   format %{ "ORI     $dst, $src1, $src2.lo" %}
5698   size(4);
5699   ins_encode %{
5700     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
5701     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
5702   %}
5703   ins_pipe(pipe_class_default);
5704 %}
5705 
5706 // Load 32-bit long constant
5707 instruct loadConL32_Ex(iRegLdst dst, immL32 src) %{
5708   match(Set dst src);
5709   ins_cost(DEFAULT_COST*2);
5710 
5711   expand %{
5712     // Would like to use $src$$constant.
5713     immL16     srcLo %{ _opnds[1]-&gt;constant() /*&amp; 0x0000FFFFL */%}
5714     // srcHi can be 0000 if srcLo sign-extends to a negative number.
5715     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() /*&amp; 0xFFFF0000L */%}
5716     iRegLdst tmpL;
5717     loadConL32hi16(tmpL, srcHi);
5718     loadConL32_lo16(dst, tmpL, srcLo);
5719   %}
5720 %}
5721 
5722 // Load long constant 0x????000000000000.
5723 instruct loadConLhighest16_Ex(iRegLdst dst, immLhighest16 src) %{
5724   match(Set dst src);
5725   ins_cost(DEFAULT_COST);
5726 
5727   expand %{
5728     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() &gt;&gt; 32 /*&amp; 0xFFFF0000L */%}
5729     immI shift32 %{ 32 %}
5730     iRegLdst tmpL;
5731     loadConL32hi16(tmpL, srcHi);
5732     lshiftL_regL_immI(dst, tmpL, shift32);
5733   %}
5734 %}
5735 
5736 // Expand node for constant pool load: small offset.
5737 instruct loadConL(iRegLdst dst, immL src, iRegLdst toc) %{
5738   effect(DEF dst, USE src, USE toc);
5739   ins_cost(MEMORY_REF_COST);
5740 
5741   ins_num_consts(1);
5742   // Needed so that CallDynamicJavaDirect can compute the address of this
5743   // instruction for relocation.
5744   ins_field_cbuf_insts_offset(int);
5745 
5746   format %{ "LD      $dst, offset, $toc \t// load long $src from TOC" %}
5747   size(4);
5748   ins_encode( enc_load_long_constL(dst, src, toc) );
5749   ins_pipe(pipe_class_memory);
5750 %}
5751 
5752 // Expand node for constant pool load: large offset.
5753 instruct loadConL_hi(iRegLdst dst, immL src, iRegLdst toc) %{
5754   effect(DEF dst, USE src, USE toc);
5755   predicate(false);
5756 
5757   ins_num_consts(1);
5758   ins_field_const_toc_offset(int);
5759   // Needed so that CallDynamicJavaDirect can compute the address of this
5760   // instruction for relocation.
5761   ins_field_cbuf_insts_offset(int);
5762 
5763   format %{ "ADDIS   $dst, $toc, offset \t// load long $src from TOC (hi)" %}
5764   size(4);
5765   ins_encode( enc_load_long_constL_hi(dst, toc, src) );
5766   ins_pipe(pipe_class_default);
5767 %}
5768 
5769 // Expand node for constant pool load: large offset.
5770 // No constant pool entries required.
5771 instruct loadConL_lo(iRegLdst dst, immL src, iRegLdst base) %{
5772   effect(DEF dst, USE src, USE base);
5773   predicate(false);
5774 
5775   ins_field_const_toc_offset_hi_node(loadConL_hiNode*);
5776 
5777   format %{ "LD      $dst, offset, $base \t// load long $src from TOC (lo)" %}
5778   size(4);
5779   ins_encode %{
5780     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
5781     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;
5782     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
5783   %}
5784   ins_pipe(pipe_class_memory);
5785 %}
5786 
5787 // Load long constant from constant table. Expand in case of
5788 // offset &gt; 16 bit is needed.
5789 // Adlc adds toc node MachConstantTableBase.
5790 instruct loadConL_Ex(iRegLdst dst, immL src) %{
5791   match(Set dst src);
5792   ins_cost(MEMORY_REF_COST);
5793 
5794   format %{ "LD      $dst, offset, $constanttablebase\t// load long $src from table, postalloc expanded" %}
5795   // We can not inline the enc_class for the expand as that does not support constanttablebase.
5796   postalloc_expand( postalloc_expand_load_long_constant(dst, src, constanttablebase) );
5797 %}
5798 
5799 // Load NULL as compressed oop.
5800 instruct loadConN0(iRegNdst dst, immN_0 src) %{
5801   match(Set dst src);
5802   ins_cost(DEFAULT_COST);
5803 
5804   format %{ "LI      $dst, $src \t// compressed ptr" %}
5805   size(4);
5806   ins_encode %{
5807     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
5808     __ li($dst$$Register, 0);
5809   %}
5810   ins_pipe(pipe_class_default);
5811 %}
5812 
5813 // Load hi part of compressed oop constant.
5814 instruct loadConN_hi(iRegNdst dst, immN src) %{
5815   effect(DEF dst, USE src);
5816   ins_cost(DEFAULT_COST);
5817 
5818   format %{ "LIS     $dst, $src \t// narrow oop hi" %}
5819   size(4);
5820   ins_encode %{
5821     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
5822     __ lis($dst$$Register, (int)(short)(($src$$constant &gt;&gt; 16) &amp; 0xffff));
5823   %}
5824   ins_pipe(pipe_class_default);
5825 %}
5826 
5827 // Add lo part of compressed oop constant to already loaded hi part.
5828 instruct loadConN_lo(iRegNdst dst, iRegNsrc src1, immN src2) %{
5829   effect(DEF dst, USE src1, USE src2);
5830   ins_cost(DEFAULT_COST);
5831 
5832   format %{ "ORI     $dst, $src1, $src2 \t// narrow oop lo" %}
5833   size(4);
5834   ins_encode %{
5835     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
5836     assert(__ oop_recorder() != NULL, "this assembler needs an OopRecorder");
5837     int oop_index = __ oop_recorder()-&gt;find_index((jobject)$src2$$constant);
5838     RelocationHolder rspec = oop_Relocation::spec(oop_index);
5839     __ relocate(rspec, 1);
5840     __ ori($dst$$Register, $src1$$Register, $src2$$constant &amp; 0xffff);
5841   %}
5842   ins_pipe(pipe_class_default);
5843 %}
5844 
5845 // Needed to postalloc expand loadConN: ConN is loaded as ConI
5846 // leaving the upper 32 bits with sign-extension bits.
5847 // This clears these bits: dst = src &amp; 0xFFFFFFFF.
5848 // TODO: Eventually call this maskN_regN_FFFFFFFF.
5849 instruct clearMs32b(iRegNdst dst, iRegNsrc src) %{
5850   effect(DEF dst, USE src);
5851   predicate(false);
5852 
5853   format %{ "MASK    $dst, $src, 0xFFFFFFFF" %} // mask
5854   size(4);
5855   ins_encode %{
5856     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
5857     __ clrldi($dst$$Register, $src$$Register, 0x20);
5858   %}
5859   ins_pipe(pipe_class_default);
5860 %}
5861 
5862 // Optimize DecodeN for disjoint base.
5863 // Load base of compressed oops into a register
5864 instruct loadBase(iRegLdst dst) %{
5865   effect(DEF dst);
5866 
5867   format %{ "LoadConst $dst, heapbase" %}
5868   ins_encode %{
5869     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
5870     __ load_const_optimized($dst$$Register, Universe::narrow_oop_base(), R0);
5871   %}
5872   ins_pipe(pipe_class_default);
5873 %}
5874 
5875 // Loading ConN must be postalloc expanded so that edges between
5876 // the nodes are safe. They may not interfere with a safepoint.
5877 // GL TODO: This needs three instructions: better put this into the constant pool.
5878 instruct loadConN_Ex(iRegNdst dst, immN src) %{
5879   match(Set dst src);
5880   ins_cost(DEFAULT_COST*2);
5881 
5882   format %{ "LoadN   $dst, $src \t// postalloc expanded" %} // mask
5883   postalloc_expand %{
5884     MachNode *m1 = new loadConN_hiNode();
5885     MachNode *m2 = new loadConN_loNode();
5886     MachNode *m3 = new clearMs32bNode();
5887     m1-&gt;add_req(NULL);
5888     m2-&gt;add_req(NULL, m1);
5889     m3-&gt;add_req(NULL, m2);
5890     m1-&gt;_opnds[0] = op_dst;
5891     m1-&gt;_opnds[1] = op_src;
5892     m2-&gt;_opnds[0] = op_dst;
5893     m2-&gt;_opnds[1] = op_dst;
5894     m2-&gt;_opnds[2] = op_src;
5895     m3-&gt;_opnds[0] = op_dst;
5896     m3-&gt;_opnds[1] = op_dst;
5897     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5898     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5899     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5900     nodes-&gt;push(m1);
5901     nodes-&gt;push(m2);
5902     nodes-&gt;push(m3);
5903   %}
5904 %}
5905 
5906 // We have seen a safepoint between the hi and lo parts, and this node was handled
5907 // as an oop. Therefore this needs a match rule so that build_oop_map knows this is
5908 // not a narrow oop.
5909 instruct loadConNKlass_hi(iRegNdst dst, immNKlass_NM src) %{
5910   match(Set dst src);
5911   effect(DEF dst, USE src);
5912   ins_cost(DEFAULT_COST);
5913 
5914   format %{ "LIS     $dst, $src \t// narrow klass hi" %}
5915   size(4);
5916   ins_encode %{
5917     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
5918     intptr_t Csrc = Klass::encode_klass((Klass *)$src$$constant);
5919     __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
5920   %}
5921   ins_pipe(pipe_class_default);
5922 %}
5923 
5924 // As loadConNKlass_hi this must be recognized as narrow klass, not oop!
5925 instruct loadConNKlass_mask(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
5926   match(Set dst src1);
5927   effect(TEMP src2);
5928   ins_cost(DEFAULT_COST);
5929 
5930   format %{ "MASK    $dst, $src2, 0xFFFFFFFF" %} // mask
5931   size(4);
5932   ins_encode %{
5933     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
5934     __ clrldi($dst$$Register, $src2$$Register, 0x20);
5935   %}
5936   ins_pipe(pipe_class_default);
5937 %}
5938 
5939 // This needs a match rule so that build_oop_map knows this is
5940 // not a narrow oop.
5941 instruct loadConNKlass_lo(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
5942   match(Set dst src1);
5943   effect(TEMP src2);
5944   ins_cost(DEFAULT_COST);
5945 
5946   format %{ "ORI     $dst, $src1, $src2 \t// narrow klass lo" %}
5947   size(4);
5948   ins_encode %{
5949     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
5950     intptr_t Csrc = Klass::encode_klass((Klass *)$src1$$constant);
5951     assert(__ oop_recorder() != NULL, "this assembler needs an OopRecorder");
5952     int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
5953     RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5954 
5955     __ relocate(rspec, 1);
5956     __ ori($dst$$Register, $src2$$Register, Csrc &amp; 0xffff);
5957   %}
5958   ins_pipe(pipe_class_default);
5959 %}
5960 
5961 // Loading ConNKlass must be postalloc expanded so that edges between
5962 // the nodes are safe. They may not interfere with a safepoint.
5963 instruct loadConNKlass_Ex(iRegNdst dst, immNKlass src) %{
5964   match(Set dst src);
5965   ins_cost(DEFAULT_COST*2);
5966 
5967   format %{ "LoadN   $dst, $src \t// postalloc expanded" %} // mask
5968   postalloc_expand %{
5969     // Load high bits into register. Sign extended.
5970     MachNode *m1 = new loadConNKlass_hiNode();
5971     m1-&gt;add_req(NULL);
5972     m1-&gt;_opnds[0] = op_dst;
5973     m1-&gt;_opnds[1] = op_src;
5974     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5975     nodes-&gt;push(m1);
5976 
5977     MachNode *m2 = m1;
5978     if (!Assembler::is_uimm((jlong)Klass::encode_klass((Klass *)op_src-&gt;constant()), 31)) {
5979       // Value might be 1-extended. Mask out these bits.
5980       m2 = new loadConNKlass_maskNode();
5981       m2-&gt;add_req(NULL, m1);
5982       m2-&gt;_opnds[0] = op_dst;
5983       m2-&gt;_opnds[1] = op_src;
5984       m2-&gt;_opnds[2] = op_dst;
5985       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5986       nodes-&gt;push(m2);
5987     }
5988 
5989     MachNode *m3 = new loadConNKlass_loNode();
5990     m3-&gt;add_req(NULL, m2);
5991     m3-&gt;_opnds[0] = op_dst;
5992     m3-&gt;_opnds[1] = op_src;
5993     m3-&gt;_opnds[2] = op_dst;
5994     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5995     nodes-&gt;push(m3);
5996   %}
5997 %}
5998 
5999 // 0x1 is used in object initialization (initial object header).
6000 // No constant pool entries required.
6001 instruct loadConP0or1(iRegPdst dst, immP_0or1 src) %{
6002   match(Set dst src);
6003 
6004   format %{ "LI      $dst, $src \t// ptr" %}
6005   size(4);
6006   ins_encode %{
6007     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
6008     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
6009   %}
6010   ins_pipe(pipe_class_default);
6011 %}
6012 
6013 // Expand node for constant pool load: small offset.
6014 // The match rule is needed to generate the correct bottom_type(),
6015 // however this node should never match. The use of predicate is not
6016 // possible since ADLC forbids predicates for chain rules. The higher
6017 // costs do not prevent matching in this case. For that reason the
6018 // operand immP_NM with predicate(false) is used.
6019 instruct loadConP(iRegPdst dst, immP_NM src, iRegLdst toc) %{
6020   match(Set dst src);
6021   effect(TEMP toc);
6022 
6023   ins_num_consts(1);
6024 
6025   format %{ "LD      $dst, offset, $toc \t// load ptr $src from TOC" %}
6026   size(4);
6027   ins_encode( enc_load_long_constP(dst, src, toc) );
6028   ins_pipe(pipe_class_memory);
6029 %}
6030 
6031 // Expand node for constant pool load: large offset.
6032 instruct loadConP_hi(iRegPdst dst, immP_NM src, iRegLdst toc) %{
6033   effect(DEF dst, USE src, USE toc);
6034   predicate(false);
6035 
6036   ins_num_consts(1);
6037   ins_field_const_toc_offset(int);
6038 
6039   format %{ "ADDIS   $dst, $toc, offset \t// load ptr $src from TOC (hi)" %}
6040   size(4);
6041   ins_encode( enc_load_long_constP_hi(dst, src, toc) );
6042   ins_pipe(pipe_class_default);
6043 %}
6044 
6045 // Expand node for constant pool load: large offset.
6046 instruct loadConP_lo(iRegPdst dst, immP_NM src, iRegLdst base) %{
6047   match(Set dst src);
6048   effect(TEMP base);
6049 
6050   ins_field_const_toc_offset_hi_node(loadConP_hiNode*);
6051 
6052   format %{ "LD      $dst, offset, $base \t// load ptr $src from TOC (lo)" %}
6053   size(4);
6054   ins_encode %{
6055     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
6056     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;
6057     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
6058   %}
6059   ins_pipe(pipe_class_memory);
6060 %}
6061 
6062 // Load pointer constant from constant table. Expand in case an
6063 // offset &gt; 16 bit is needed.
6064 // Adlc adds toc node MachConstantTableBase.
6065 instruct loadConP_Ex(iRegPdst dst, immP src) %{
6066   match(Set dst src);
6067   ins_cost(MEMORY_REF_COST);
6068 
6069   // This rule does not use "expand" because then
6070   // the result type is not known to be an Oop.  An ADLC
6071   // enhancement will be needed to make that work - not worth it!
6072 
6073   // If this instruction rematerializes, it prolongs the live range
6074   // of the toc node, causing illegal graphs.
6075   // assert(edge_from_to(_reg_node[reg_lo],def)) fails in verify_good_schedule().
6076   ins_cannot_rematerialize(true);
6077 
6078   format %{ "LD    $dst, offset, $constanttablebase \t//  load ptr $src from table, postalloc expanded" %}
6079   postalloc_expand( postalloc_expand_load_ptr_constant(dst, src, constanttablebase) );
6080 %}
6081 
6082 // Expand node for constant pool load: small offset.
6083 instruct loadConF(regF dst, immF src, iRegLdst toc) %{
6084   effect(DEF dst, USE src, USE toc);
6085   ins_cost(MEMORY_REF_COST);
6086 
6087   ins_num_consts(1);
6088 
6089   format %{ "LFS     $dst, offset, $toc \t// load float $src from TOC" %}
6090   size(4);
6091   ins_encode %{
6092     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
6093     address float_address = __ float_constant($src$$constant);
6094     if (float_address == NULL) {
6095       ciEnv::current()-&gt;record_out_of_memory_failure();
6096       return;
6097     }
6098     __ lfs($dst$$FloatRegister, __ offset_to_method_toc(float_address), $toc$$Register);
6099   %}
6100   ins_pipe(pipe_class_memory);
6101 %}
6102 
6103 // Expand node for constant pool load: large offset.
6104 instruct loadConFComp(regF dst, immF src, iRegLdst toc) %{
6105   effect(DEF dst, USE src, USE toc);
6106   ins_cost(MEMORY_REF_COST);
6107 
6108   ins_num_consts(1);
6109 
6110   format %{ "ADDIS   $toc, $toc, offset_hi\n\t"
6111             "LFS     $dst, offset_lo, $toc \t// load float $src from TOC (hi/lo)\n\t"
6112             "ADDIS   $toc, $toc, -offset_hi"%}
6113   size(12);
6114   ins_encode %{
6115     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6116     FloatRegister Rdst    = $dst$$FloatRegister;
6117     Register Rtoc         = $toc$$Register;
6118     address float_address = __ float_constant($src$$constant);
6119     if (float_address == NULL) {
6120       ciEnv::current()-&gt;record_out_of_memory_failure();
6121       return;
6122     }
6123     int offset            = __ offset_to_method_toc(float_address);
6124     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
6125     int lo = offset - hi * (1&lt;&lt;16);
6126 
6127     __ addis(Rtoc, Rtoc, hi);
6128     __ lfs(Rdst, lo, Rtoc);
6129     __ addis(Rtoc, Rtoc, -hi);
6130   %}
6131   ins_pipe(pipe_class_memory);
6132 %}
6133 
6134 // Adlc adds toc node MachConstantTableBase.
6135 instruct loadConF_Ex(regF dst, immF src) %{
6136   match(Set dst src);
6137   ins_cost(MEMORY_REF_COST);
6138 
6139   // See loadConP.
6140   ins_cannot_rematerialize(true);
6141 
6142   format %{ "LFS     $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded" %}
6143   postalloc_expand( postalloc_expand_load_float_constant(dst, src, constanttablebase) );
6144 %}
6145 
6146 // Expand node for constant pool load: small offset.
6147 instruct loadConD(regD dst, immD src, iRegLdst toc) %{
6148   effect(DEF dst, USE src, USE toc);
6149   ins_cost(MEMORY_REF_COST);
6150 
6151   ins_num_consts(1);
6152 
6153   format %{ "LFD     $dst, offset, $toc \t// load double $src from TOC" %}
6154   size(4);
6155   ins_encode %{
6156     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
6157     address float_address = __ double_constant($src$$constant);
6158     if (float_address == NULL) {
6159       ciEnv::current()-&gt;record_out_of_memory_failure();
6160       return;
6161     }
6162     int offset =  __ offset_to_method_toc(float_address);
6163     __ lfd($dst$$FloatRegister, offset, $toc$$Register);
6164   %}
6165   ins_pipe(pipe_class_memory);
6166 %}
6167 
6168 // Expand node for constant pool load: large offset.
6169 instruct loadConDComp(regD dst, immD src, iRegLdst toc) %{
6170   effect(DEF dst, USE src, USE toc);
6171   ins_cost(MEMORY_REF_COST);
6172 
6173   ins_num_consts(1);
6174 
6175   format %{ "ADDIS   $toc, $toc, offset_hi\n\t"
6176             "LFD     $dst, offset_lo, $toc \t// load double $src from TOC (hi/lo)\n\t"
6177             "ADDIS   $toc, $toc, -offset_hi" %}
6178   size(12);
6179   ins_encode %{
6180     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6181     FloatRegister Rdst    = $dst$$FloatRegister;
6182     Register      Rtoc    = $toc$$Register;
6183     address float_address = __ double_constant($src$$constant);
6184     if (float_address == NULL) {
6185       ciEnv::current()-&gt;record_out_of_memory_failure();
6186       return;
6187     }
6188     int offset = __ offset_to_method_toc(float_address);
6189     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
6190     int lo = offset - hi * (1&lt;&lt;16);
6191 
6192     __ addis(Rtoc, Rtoc, hi);
6193     __ lfd(Rdst, lo, Rtoc);
6194     __ addis(Rtoc, Rtoc, -hi);
6195   %}
6196   ins_pipe(pipe_class_memory);
6197 %}
6198 
6199 // Adlc adds toc node MachConstantTableBase.
6200 instruct loadConD_Ex(regD dst, immD src) %{
6201   match(Set dst src);
6202   ins_cost(MEMORY_REF_COST);
6203 
6204   // See loadConP.
6205   ins_cannot_rematerialize(true);
6206 
6207   format %{ "ConD    $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded" %}
6208   postalloc_expand( postalloc_expand_load_double_constant(dst, src, constanttablebase) );
6209 %}
6210 
6211 // Prefetch instructions.
6212 // Must be safe to execute with invalid address (cannot fault).
6213 
6214 // Special prefetch versions which use the dcbz instruction.
6215 instruct prefetch_alloc_zero(indirectMemory mem, iRegLsrc src) %{
6216   match(PrefetchAllocation (AddP mem src));
6217   predicate(AllocatePrefetchStyle == 3);
6218   ins_cost(MEMORY_REF_COST);
6219 
6220   format %{ "PREFETCH $mem, 2, $src \t// Prefetch write-many with zero" %}
6221   size(4);
6222   ins_encode %{
6223     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
6224     __ dcbz($src$$Register, $mem$$base$$Register);
6225   %}
6226   ins_pipe(pipe_class_memory);
6227 %}
6228 
6229 instruct prefetch_alloc_zero_no_offset(indirectMemory mem) %{
6230   match(PrefetchAllocation mem);
6231   predicate(AllocatePrefetchStyle == 3);
6232   ins_cost(MEMORY_REF_COST);
6233 
6234   format %{ "PREFETCH $mem, 2 \t// Prefetch write-many with zero" %}
6235   size(4);
6236   ins_encode %{
6237     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
6238     __ dcbz($mem$$base$$Register);
6239   %}
6240   ins_pipe(pipe_class_memory);
6241 %}
6242 
6243 instruct prefetch_alloc(indirectMemory mem, iRegLsrc src) %{
6244   match(PrefetchAllocation (AddP mem src));
6245   predicate(AllocatePrefetchStyle != 3);
6246   ins_cost(MEMORY_REF_COST);
6247 
6248   format %{ "PREFETCH $mem, 2, $src \t// Prefetch write-many" %}
6249   size(4);
6250   ins_encode %{
6251     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
6252     __ dcbtst($src$$Register, $mem$$base$$Register);
6253   %}
6254   ins_pipe(pipe_class_memory);
6255 %}
6256 
6257 instruct prefetch_alloc_no_offset(indirectMemory mem) %{
6258   match(PrefetchAllocation mem);
6259   predicate(AllocatePrefetchStyle != 3);
6260   ins_cost(MEMORY_REF_COST);
6261 
6262   format %{ "PREFETCH $mem, 2 \t// Prefetch write-many" %}
6263   size(4);
6264   ins_encode %{
6265     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
6266     __ dcbtst($mem$$base$$Register);
6267   %}
6268   ins_pipe(pipe_class_memory);
6269 %}
6270 
6271 //----------Store Instructions-------------------------------------------------
6272 
6273 // Store Byte
6274 instruct storeB(memory mem, iRegIsrc src) %{
6275   match(Set mem (StoreB mem src));
6276   ins_cost(MEMORY_REF_COST);
6277 
6278   format %{ "STB     $src, $mem \t// byte" %}
6279   size(4);
6280   ins_encode %{
6281     // TODO: PPC port $archOpcode(ppc64Opcode_stb);
6282     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6283     __ stb($src$$Register, Idisp, $mem$$base$$Register);
6284   %}
6285   ins_pipe(pipe_class_memory);
6286 %}
6287 
6288 // Store Char/Short
6289 instruct storeC(memory mem, iRegIsrc src) %{
6290   match(Set mem (StoreC mem src));
6291   ins_cost(MEMORY_REF_COST);
6292 
6293   format %{ "STH     $src, $mem \t// short" %}
6294   size(4);
6295   ins_encode %{
6296     // TODO: PPC port $archOpcode(ppc64Opcode_sth);
6297     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6298     __ sth($src$$Register, Idisp, $mem$$base$$Register);
6299   %}
6300   ins_pipe(pipe_class_memory);
6301 %}
6302 
6303 // Store Integer
6304 instruct storeI(memory mem, iRegIsrc src) %{
6305   match(Set mem (StoreI mem src));
6306   ins_cost(MEMORY_REF_COST);
6307 
6308   format %{ "STW     $src, $mem" %}
6309   size(4);
6310   ins_encode( enc_stw(src, mem) );
6311   ins_pipe(pipe_class_memory);
6312 %}
6313 
6314 // ConvL2I + StoreI.
6315 instruct storeI_convL2I(memory mem, iRegLsrc src) %{
6316   match(Set mem (StoreI mem (ConvL2I src)));
6317   ins_cost(MEMORY_REF_COST);
6318 
6319   format %{ "STW     l2i($src), $mem" %}
6320   size(4);
6321   ins_encode( enc_stw(src, mem) );
6322   ins_pipe(pipe_class_memory);
6323 %}
6324 
6325 // Store Long
6326 instruct storeL(memoryAlg4 mem, iRegLsrc src) %{
6327   match(Set mem (StoreL mem src));
6328   ins_cost(MEMORY_REF_COST);
6329 
6330   format %{ "STD     $src, $mem \t// long" %}
6331   size(4);
6332   ins_encode( enc_std(src, mem) );
6333   ins_pipe(pipe_class_memory);
6334 %}
6335 
6336 // Store super word nodes.
6337 
6338 // Store Aligned Packed Byte long register to memory
6339 instruct storeA8B(memoryAlg4 mem, iRegLsrc src) %{
6340   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
6341   match(Set mem (StoreVector mem src));
6342   ins_cost(MEMORY_REF_COST);
6343 
6344   format %{ "STD     $mem, $src \t// packed8B" %}
6345   size(4);
6346   ins_encode( enc_std(src, mem) );
6347   ins_pipe(pipe_class_memory);
6348 %}
6349 
6350 // Store Compressed OOPs with narrow_oop_shift == 0.
6351 // shift == 0, base == 0
6352 instruct storeEncodeP_narrow_oop_shift_0(memory dst, iRegPsrc src) %{
6353   match(Set dst (StoreN dst (EncodeP src)));
6354   ins_cost(MEMORY_REF_COST);
6355   predicate(Universe::narrow_oop_shift() == 0);
6356 
6357   format %{ "STW     $src, $dst \t// compressed oop" %}
6358   size(4);
6359   ins_encode( enc_stw(src, dst) );
6360   ins_pipe(pipe_class_memory);
6361 %}
6362 
6363 // Store Compressed Oop
6364 instruct storeN(memory dst, iRegN_P2N src) %{
6365   match(Set dst (StoreN dst src));
6366   ins_cost(MEMORY_REF_COST);
6367 
6368   format %{ "STW     $src, $dst \t// compressed oop" %}
6369   size(4);
6370   ins_encode( enc_stw(src, dst) );
6371   ins_pipe(pipe_class_memory);
6372 %}
6373 
6374 // Store Compressed KLass
6375 instruct storeNKlass(memory dst, iRegN_P2N src) %{
6376   match(Set dst (StoreNKlass dst src));
6377   ins_cost(MEMORY_REF_COST);
6378 
6379   format %{ "STW     $src, $dst \t// compressed klass" %}
6380   size(4);
6381   ins_encode( enc_stw(src, dst) );
6382   ins_pipe(pipe_class_memory);
6383 %}
6384 
6385 // Store Pointer
6386 instruct storeP(memoryAlg4 dst, iRegPsrc src) %{
6387   match(Set dst (StoreP dst src));
6388   ins_cost(MEMORY_REF_COST);
6389 
6390   format %{ "STD     $src, $dst \t// ptr" %}
6391   size(4);
6392   ins_encode( enc_std(src, dst) );
6393   ins_pipe(pipe_class_memory);
6394 %}
6395 
6396 // Store Float
6397 instruct storeF(memory mem, regF src) %{
6398   match(Set mem (StoreF mem src));
6399   ins_cost(MEMORY_REF_COST);
6400 
6401   format %{ "STFS    $src, $mem" %}
6402   size(4);
6403   ins_encode( enc_stfs(src, mem) );
6404   ins_pipe(pipe_class_memory);
6405 %}
6406 
6407 // Store Double
6408 instruct storeD(memory mem, regD src) %{
6409   match(Set mem (StoreD mem src));
6410   ins_cost(MEMORY_REF_COST);
6411 
6412   format %{ "STFD    $src, $mem" %}
6413   size(4);
6414   ins_encode( enc_stfd(src, mem) );
6415   ins_pipe(pipe_class_memory);
6416 %}
6417 
6418 //----------Store Instructions With Zeros--------------------------------------
6419 
6420 // Card-mark for CMS garbage collection.
6421 // This cardmark does an optimization so that it must not always
6422 // do a releasing store. For this, it gets the address of
6423 // CMSCollectorCardTableModRefBSExt::_requires_release as input.
6424 // (Using releaseFieldAddr in the match rule is a hack.)
6425 instruct storeCM_CMS(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
6426   match(Set mem (StoreCM mem releaseFieldAddr));
6427   effect(TEMP crx);
6428   predicate(false);
6429   ins_cost(MEMORY_REF_COST);
6430 
6431   // See loadConP.
6432   ins_cannot_rematerialize(true);
6433 
6434   format %{ "STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]" %}
6435   ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
6436   ins_pipe(pipe_class_memory);
6437 %}
6438 
6439 // Card-mark for CMS garbage collection.
6440 // This cardmark does an optimization so that it must not always
6441 // do a releasing store. For this, it needs the constant address of
6442 // CMSCollectorCardTableModRefBSExt::_requires_release.
6443 // This constant address is split off here by expand so we can use
6444 // adlc / matcher functionality to load it from the constant section.
6445 instruct storeCM_CMS_ExEx(memory mem, immI_0 zero) %{
6446   match(Set mem (StoreCM mem zero));
6447   predicate(UseConcMarkSweepGC);
6448 
6449   expand %{
6450     immL baseImm %{ 0 /* TODO: PPC port (jlong)CMSCollectorCardTableModRefBSExt::requires_release_address() */ %}
6451     iRegLdst releaseFieldAddress;
6452     flagsReg crx;
6453     loadConL_Ex(releaseFieldAddress, baseImm);
6454     storeCM_CMS(mem, releaseFieldAddress, crx);
6455   %}
6456 %}
6457 
6458 instruct storeCM_G1(memory mem, immI_0 zero) %{
6459   match(Set mem (StoreCM mem zero));
6460   predicate(UseG1GC);
6461   ins_cost(MEMORY_REF_COST);
6462 
6463   ins_cannot_rematerialize(true);
6464 
6465   format %{ "STB     #0, $mem \t// CMS card-mark byte store (G1)" %}
6466   size(8);
6467   ins_encode %{
6468     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6469     __ li(R0, 0);
6470     //__ release(); // G1: oops are allowed to get visible after dirty marking
6471     guarantee($mem$$base$$Register != R1_SP, "use frame_slots_bias");
6472     __ stb(R0, $mem$$disp, $mem$$base$$Register);
6473   %}
6474   ins_pipe(pipe_class_memory);
6475 %}
6476 
6477 // Convert oop pointer into compressed form.
6478 
6479 // Nodes for postalloc expand.
6480 
6481 // Shift node for expand.
6482 instruct encodeP_shift(iRegNdst dst, iRegNsrc src) %{
6483   // The match rule is needed to make it a 'MachTypeNode'!
6484   match(Set dst (EncodeP src));
6485   predicate(false);
6486 
6487   format %{ "SRDI    $dst, $src, 3 \t// encode" %}
6488   size(4);
6489   ins_encode %{
6490     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
6491     __ srdi($dst$$Register, $src$$Register, Universe::narrow_oop_shift() &amp; 0x3f);
6492   %}
6493   ins_pipe(pipe_class_default);
6494 %}
6495 
6496 // Add node for expand.
6497 instruct encodeP_sub(iRegPdst dst, iRegPdst src) %{
6498   // The match rule is needed to make it a 'MachTypeNode'!
6499   match(Set dst (EncodeP src));
6500   predicate(false);
6501 
6502   format %{ "SUB     $dst, $src, oop_base \t// encode" %}
6503   ins_encode %{
6504     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6505     __ sub_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);
6506   %}
6507   ins_pipe(pipe_class_default);
6508 %}
6509 
6510 // Conditional sub base.
6511 instruct cond_sub_base(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
6512   // The match rule is needed to make it a 'MachTypeNode'!
6513   match(Set dst (EncodeP (Binary crx src1)));
6514   predicate(false);
6515 
6516   format %{ "BEQ     $crx, done\n\t"
6517             "SUB     $dst, $src1, heapbase \t// encode: subtract base if != NULL\n"
6518             "done:" %}
6519   ins_encode %{
6520     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6521     Label done;
6522     __ beq($crx$$CondRegister, done);
6523     __ sub_const_optimized($dst$$Register, $src1$$Register, Universe::narrow_oop_base(), R0);
6524     __ bind(done);
6525   %}
6526   ins_pipe(pipe_class_default);
6527 %}
6528 
6529 // Power 7 can use isel instruction
6530 instruct cond_set_0_oop(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
6531   // The match rule is needed to make it a 'MachTypeNode'!
6532   match(Set dst (EncodeP (Binary crx src1)));
6533   predicate(false);
6534 
6535   format %{ "CMOVE   $dst, $crx eq, 0, $src1 \t// encode: preserve 0" %}
6536   size(4);
6537   ins_encode %{
6538     // This is a Power7 instruction for which no machine description exists.
6539     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6540     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
6541   %}
6542   ins_pipe(pipe_class_default);
6543 %}
6544 
6545 // Disjoint narrow oop base.
6546 instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
6547   match(Set dst (EncodeP src));
6548   predicate(Universe::narrow_oop_base_disjoint());
6549 
6550   format %{ "EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base" %}
6551   size(4);
6552   ins_encode %{
6553     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
6554     __ rldicl($dst$$Register, $src$$Register, 64-Universe::narrow_oop_shift(), 32);
6555   %}
6556   ins_pipe(pipe_class_default);
6557 %}
6558 
6559 // shift != 0, base != 0
6560 instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
6561   match(Set dst (EncodeP src));
6562   effect(TEMP crx);
6563   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6564             Universe::narrow_oop_shift() != 0 &amp;&amp;
6565             Universe::narrow_oop_base_overlaps());
6566 
6567   format %{ "EncodeP $dst, $crx, $src \t// postalloc expanded" %}
6568   postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
6569 %}
6570 
6571 // shift != 0, base != 0
6572 instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
6573   match(Set dst (EncodeP src));
6574   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
6575             Universe::narrow_oop_shift() != 0 &amp;&amp;
6576             Universe::narrow_oop_base_overlaps());
6577 
6578   format %{ "EncodeP $dst, $src\t// $src != Null, postalloc expanded" %}
6579   postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
6580 %}
6581 
6582 // shift != 0, base == 0
6583 // TODO: This is the same as encodeP_shift. Merge!
6584 instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
6585   match(Set dst (EncodeP src));
6586   predicate(Universe::narrow_oop_shift() != 0 &amp;&amp;
6587             Universe::narrow_oop_base() ==0);
6588 
6589   format %{ "SRDI    $dst, $src, #3 \t// encodeP, $src != NULL" %}
6590   size(4);
6591   ins_encode %{
6592     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
6593     __ srdi($dst$$Register, $src$$Register, Universe::narrow_oop_shift() &amp; 0x3f);
6594   %}
6595   ins_pipe(pipe_class_default);
6596 %}
6597 
6598 // Compressed OOPs with narrow_oop_shift == 0.
6599 // shift == 0, base == 0
6600 instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
6601   match(Set dst (EncodeP src));
6602   predicate(Universe::narrow_oop_shift() == 0);
6603 
6604   format %{ "MR      $dst, $src \t// Ptr-&gt;Narrow" %}
6605   // variable size, 0 or 4.
6606   ins_encode %{
6607     // TODO: PPC port $archOpcode(ppc64Opcode_or);
6608     __ mr_if_needed($dst$$Register, $src$$Register);
6609   %}
6610   ins_pipe(pipe_class_default);
6611 %}
6612 
6613 // Decode nodes.
6614 
6615 // Shift node for expand.
6616 instruct decodeN_shift(iRegPdst dst, iRegPsrc src) %{
6617   // The match rule is needed to make it a 'MachTypeNode'!
6618   match(Set dst (DecodeN src));
6619   predicate(false);
6620 
6621   format %{ "SLDI    $dst, $src, #3 \t// DecodeN" %}
6622   size(4);
6623   ins_encode %{
6624     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
6625     __ sldi($dst$$Register, $src$$Register, Universe::narrow_oop_shift());
6626   %}
6627   ins_pipe(pipe_class_default);
6628 %}
6629 
6630 // Add node for expand.
6631 instruct decodeN_add(iRegPdst dst, iRegPdst src) %{
6632   // The match rule is needed to make it a 'MachTypeNode'!
6633   match(Set dst (DecodeN src));
6634   predicate(false);
6635 
6636   format %{ "ADD     $dst, $src, heapbase \t// DecodeN, add oop base" %}
6637   ins_encode %{
6638     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6639     __ add_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);
6640   %}
6641   ins_pipe(pipe_class_default);
6642 %}
6643 
6644 // conditianal add base for expand
6645 instruct cond_add_base(iRegPdst dst, flagsRegSrc crx, iRegPsrc src) %{
6646   // The match rule is needed to make it a 'MachTypeNode'!
6647   // NOTICE that the rule is nonsense - we just have to make sure that:
6648   //  - _matrule-&gt;_rChild-&gt;_opType == "DecodeN" (see InstructForm::captures_bottom_type() in formssel.cpp)
6649   //  - we have to match 'crx' to avoid an "illegal USE of non-input: flagsReg crx" error in ADLC.
6650   match(Set dst (DecodeN (Binary crx src)));
6651   predicate(false);
6652 
6653   format %{ "BEQ     $crx, done\n\t"
6654             "ADD     $dst, $src, heapbase \t// DecodeN: add oop base if $src != NULL\n"
6655             "done:" %}
6656   ins_encode %{
6657     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6658     Label done;
6659     __ beq($crx$$CondRegister, done);
6660     __ add_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);
6661     __ bind(done);
6662   %}
6663   ins_pipe(pipe_class_default);
6664 %}
6665 
6666 instruct cond_set_0_ptr(iRegPdst dst, flagsRegSrc crx, iRegPsrc src1) %{
6667   // The match rule is needed to make it a 'MachTypeNode'!
6668   // NOTICE that the rule is nonsense - we just have to make sure that:
6669   //  - _matrule-&gt;_rChild-&gt;_opType == "DecodeN" (see InstructForm::captures_bottom_type() in formssel.cpp)
6670   //  - we have to match 'crx' to avoid an "illegal USE of non-input: flagsReg crx" error in ADLC.
6671   match(Set dst (DecodeN (Binary crx src1)));
6672   predicate(false);
6673 
6674   format %{ "CMOVE   $dst, $crx eq, 0, $src1 \t// decode: preserve 0" %}
6675   size(4);
6676   ins_encode %{
6677     // This is a Power7 instruction for which no machine description exists.
6678     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6679     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
6680   %}
6681   ins_pipe(pipe_class_default);
6682 %}
6683 
6684 //  shift != 0, base != 0
6685 instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
6686   match(Set dst (DecodeN src));
6687   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6688              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
6689             Universe::narrow_oop_shift() != 0 &amp;&amp;
6690             Universe::narrow_oop_base() != 0);
6691   ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
6692   effect(TEMP crx);
6693 
6694   format %{ "DecodeN $dst, $src \t// Kills $crx, postalloc expanded" %}
6695   postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
6696 %}
6697 
6698 // shift != 0, base == 0
6699 instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
6700   match(Set dst (DecodeN src));
6701   predicate(Universe::narrow_oop_shift() != 0 &amp;&amp;
6702             Universe::narrow_oop_base() == 0);
6703 
6704   format %{ "SLDI    $dst, $src, #3 \t// DecodeN (zerobased)" %}
6705   size(4);
6706   ins_encode %{
6707     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
6708     __ sldi($dst$$Register, $src$$Register, Universe::narrow_oop_shift());
6709   %}
6710   ins_pipe(pipe_class_default);
6711 %}
6712 
6713 // Optimize DecodeN for disjoint base.
6714 // Shift narrow oop and or it into register that already contains the heap base.
6715 // Base == dst must hold, and is assured by construction in postaloc_expand.
6716 instruct decodeN_mergeDisjoint(iRegPdst dst, iRegNsrc src, iRegLsrc base) %{
6717   match(Set dst (DecodeN src));
6718   effect(TEMP base);
6719   predicate(false);
6720 
6721   format %{ "RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)" %}
6722   size(4);
6723   ins_encode %{
6724     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
6725     __ rldimi($dst$$Register, $src$$Register, Universe::narrow_oop_shift(), 32-Universe::narrow_oop_shift());
6726   %}
6727   ins_pipe(pipe_class_default);
6728 %}
6729 
6730 // Optimize DecodeN for disjoint base.
6731 // This node requires only one cycle on the critical path.
6732 // We must postalloc_expand as we can not express use_def effects where
6733 // the used register is L and the def'ed register P.
6734 instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
6735   match(Set dst (DecodeN src));
6736   effect(TEMP_DEF dst);
6737   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
6738              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
6739             Universe::narrow_oop_base_disjoint());
6740   ins_cost(DEFAULT_COST);
6741 
6742   format %{ "MOV     $dst, heapbase \t\n"
6743             "RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base" %}
6744   postalloc_expand %{
6745     loadBaseNode *n1 = new loadBaseNode();
6746     n1-&gt;add_req(NULL);
6747     n1-&gt;_opnds[0] = op_dst;
6748 
6749     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
6750     n2-&gt;add_req(n_region, n_src, n1);
6751     n2-&gt;_opnds[0] = op_dst;
6752     n2-&gt;_opnds[1] = op_src;
6753     n2-&gt;_opnds[2] = op_dst;
6754     n2-&gt;_bottom_type = _bottom_type;
6755 
6756     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6757     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6758 
6759     nodes-&gt;push(n1);
6760     nodes-&gt;push(n2);
6761   %}
6762 %}
6763 
6764 instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
6765   match(Set dst (DecodeN src));
6766   effect(TEMP_DEF dst, TEMP crx);
6767   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6768              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
6769             Universe::narrow_oop_base_disjoint() &amp;&amp; VM_Version::has_isel());
6770   ins_cost(3 * DEFAULT_COST);
6771 
6772   format %{ "DecodeN  $dst, $src \t// decode with disjoint base using isel" %}
6773   postalloc_expand %{
6774     loadBaseNode *n1 = new loadBaseNode();
6775     n1-&gt;add_req(NULL);
6776     n1-&gt;_opnds[0] = op_dst;
6777 
6778     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
6779     n_compare-&gt;add_req(n_region, n_src);
6780     n_compare-&gt;_opnds[0] = op_crx;
6781     n_compare-&gt;_opnds[1] = op_src;
6782     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
6783 
6784     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
6785     n2-&gt;add_req(n_region, n_src, n1);
6786     n2-&gt;_opnds[0] = op_dst;
6787     n2-&gt;_opnds[1] = op_src;
6788     n2-&gt;_opnds[2] = op_dst;
6789     n2-&gt;_bottom_type = _bottom_type;
6790 
6791     cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
6792     n_cond_set-&gt;add_req(n_region, n_compare, n2);
6793     n_cond_set-&gt;_opnds[0] = op_dst;
6794     n_cond_set-&gt;_opnds[1] = op_crx;
6795     n_cond_set-&gt;_opnds[2] = op_dst;
6796     n_cond_set-&gt;_bottom_type = _bottom_type;
6797 
6798     assert(ra_-&gt;is_oop(this) == true, "A decodeN node must produce an oop!");
6799     ra_-&gt;set_oop(n_cond_set, true);
6800 
6801     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6802     ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
6803     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6804     ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6805 
6806     nodes-&gt;push(n1);
6807     nodes-&gt;push(n_compare);
6808     nodes-&gt;push(n2);
6809     nodes-&gt;push(n_cond_set);
6810   %}
6811 %}
6812 
6813 // src != 0, shift != 0, base != 0
6814 instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
6815   match(Set dst (DecodeN src));
6816   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
6817              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
6818             Universe::narrow_oop_shift() != 0 &amp;&amp;
6819             Universe::narrow_oop_base() != 0);
6820   ins_cost(2 * DEFAULT_COST);
6821 
6822   format %{ "DecodeN $dst, $src \t// $src != NULL, postalloc expanded" %}
6823   postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
6824 %}
6825 
6826 // Compressed OOPs with narrow_oop_shift == 0.
6827 instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
6828   match(Set dst (DecodeN src));
6829   predicate(Universe::narrow_oop_shift() == 0);
6830   ins_cost(DEFAULT_COST);
6831 
6832   format %{ "MR      $dst, $src \t// DecodeN (unscaled)" %}
6833   // variable size, 0 or 4.
6834   ins_encode %{
6835     // TODO: PPC port $archOpcode(ppc64Opcode_or);
6836     __ mr_if_needed($dst$$Register, $src$$Register);
6837   %}
6838   ins_pipe(pipe_class_default);
6839 %}
6840 
6841 // Convert compressed oop into int for vectors alignment masking.
6842 instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
6843   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
6844   predicate(Universe::narrow_oop_shift() == 0);
6845   ins_cost(DEFAULT_COST);
6846 
6847   format %{ "MR      $dst, $src \t// (int)DecodeN (unscaled)" %}
6848   // variable size, 0 or 4.
6849   ins_encode %{
6850     // TODO: PPC port $archOpcode(ppc64Opcode_or);
6851     __ mr_if_needed($dst$$Register, $src$$Register);
6852   %}
6853   ins_pipe(pipe_class_default);
6854 %}
6855 
6856 // Convert klass pointer into compressed form.
6857 
6858 // Nodes for postalloc expand.
6859 
6860 // Shift node for expand.
6861 instruct encodePKlass_shift(iRegNdst dst, iRegNsrc src) %{
6862   // The match rule is needed to make it a 'MachTypeNode'!
6863   match(Set dst (EncodePKlass src));
6864   predicate(false);
6865 
6866   format %{ "SRDI    $dst, $src, 3 \t// encode" %}
6867   size(4);
6868   ins_encode %{
6869     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
6870     __ srdi($dst$$Register, $src$$Register, Universe::narrow_klass_shift());
6871   %}
6872   ins_pipe(pipe_class_default);
6873 %}
6874 
6875 // Add node for expand.
6876 instruct encodePKlass_sub_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
6877   // The match rule is needed to make it a 'MachTypeNode'!
6878   match(Set dst (EncodePKlass (Binary base src)));
6879   predicate(false);
6880 
6881   format %{ "SUB     $dst, $base, $src \t// encode" %}
6882   size(4);
6883   ins_encode %{
6884     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
6885     __ subf($dst$$Register, $base$$Register, $src$$Register);
6886   %}
6887   ins_pipe(pipe_class_default);
6888 %}
6889 
6890 // Disjoint narrow oop base.
6891 instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
6892   match(Set dst (EncodePKlass src));
6893   predicate(false /* TODO: PPC port Universe::narrow_klass_base_disjoint()*/);
6894 
6895   format %{ "EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base" %}
6896   size(4);
6897   ins_encode %{
6898     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
6899     __ rldicl($dst$$Register, $src$$Register, 64-Universe::narrow_klass_shift(), 32);
6900   %}
6901   ins_pipe(pipe_class_default);
6902 %}
6903 
6904 // shift != 0, base != 0
6905 instruct encodePKlass_not_null_Ex(iRegNdst dst, iRegLsrc base, iRegPsrc src) %{
6906   match(Set dst (EncodePKlass (Binary base src)));
6907   predicate(false);
6908 
6909   format %{ "EncodePKlass $dst, $src\t// $src != Null, postalloc expanded" %}
6910   postalloc_expand %{
6911     encodePKlass_sub_baseNode *n1 = new encodePKlass_sub_baseNode();
6912     n1-&gt;add_req(n_region, n_base, n_src);
6913     n1-&gt;_opnds[0] = op_dst;
6914     n1-&gt;_opnds[1] = op_base;
6915     n1-&gt;_opnds[2] = op_src;
6916     n1-&gt;_bottom_type = _bottom_type;
6917 
6918     encodePKlass_shiftNode *n2 = new encodePKlass_shiftNode();
6919     n2-&gt;add_req(n_region, n1);
6920     n2-&gt;_opnds[0] = op_dst;
6921     n2-&gt;_opnds[1] = op_dst;
6922     n2-&gt;_bottom_type = _bottom_type;
6923     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6924     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6925 
6926     nodes-&gt;push(n1);
6927     nodes-&gt;push(n2);
6928   %}
6929 %}
6930 
6931 // shift != 0, base != 0
6932 instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
6933   match(Set dst (EncodePKlass src));
6934   //predicate(Universe::narrow_klass_shift() != 0 &amp;&amp;
6935   //          true /* TODO: PPC port Universe::narrow_klass_base_overlaps()*/);
6936 
6937   //format %{ "EncodePKlass $dst, $src\t// $src != Null, postalloc expanded" %}
6938   ins_cost(DEFAULT_COST*2);  // Don't count constant.
6939   expand %{
6940     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_klass_base() %}
6941     iRegLdst base;
6942     loadConL_Ex(base, baseImm);
6943     encodePKlass_not_null_Ex(dst, base, src);
6944   %}
6945 %}
6946 
6947 // Decode nodes.
6948 
6949 // Shift node for expand.
6950 instruct decodeNKlass_shift(iRegPdst dst, iRegPsrc src) %{
6951   // The match rule is needed to make it a 'MachTypeNode'!
6952   match(Set dst (DecodeNKlass src));
6953   predicate(false);
6954 
6955   format %{ "SLDI    $dst, $src, #3 \t// DecodeNKlass" %}
6956   size(4);
6957   ins_encode %{
6958     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
6959     __ sldi($dst$$Register, $src$$Register, Universe::narrow_klass_shift());
6960   %}
6961   ins_pipe(pipe_class_default);
6962 %}
6963 
6964 // Add node for expand.
6965 
6966 instruct decodeNKlass_add_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
6967   // The match rule is needed to make it a 'MachTypeNode'!
6968   match(Set dst (DecodeNKlass (Binary base src)));
6969   predicate(false);
6970 
6971   format %{ "ADD     $dst, $base, $src \t// DecodeNKlass, add klass base" %}
6972   size(4);
6973   ins_encode %{
6974     // TODO: PPC port $archOpcode(ppc64Opcode_add);
6975     __ add($dst$$Register, $base$$Register, $src$$Register);
6976   %}
6977   ins_pipe(pipe_class_default);
6978 %}
6979 
6980 // src != 0, shift != 0, base != 0
6981 instruct decodeNKlass_notNull_addBase_Ex(iRegPdst dst, iRegLsrc base, iRegNsrc src) %{
6982   match(Set dst (DecodeNKlass (Binary base src)));
6983   //effect(kill src); // We need a register for the immediate result after shifting.
6984   predicate(false);
6985 
6986   format %{ "DecodeNKlass $dst =  $base + ($src &lt;&lt; 3) \t// $src != NULL, postalloc expanded" %}
6987   postalloc_expand %{
6988     decodeNKlass_add_baseNode *n1 = new decodeNKlass_add_baseNode();
6989     n1-&gt;add_req(n_region, n_base, n_src);
6990     n1-&gt;_opnds[0] = op_dst;
6991     n1-&gt;_opnds[1] = op_base;
6992     n1-&gt;_opnds[2] = op_src;
6993     n1-&gt;_bottom_type = _bottom_type;
6994 
6995     decodeNKlass_shiftNode *n2 = new decodeNKlass_shiftNode();
6996     n2-&gt;add_req(n_region, n1);
6997     n2-&gt;_opnds[0] = op_dst;
6998     n2-&gt;_opnds[1] = op_dst;
6999     n2-&gt;_bottom_type = _bottom_type;
7000 
7001     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
7002     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
7003 
7004     nodes-&gt;push(n1);
7005     nodes-&gt;push(n2);
7006   %}
7007 %}
7008 
7009 // src != 0, shift != 0, base != 0
7010 instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
7011   match(Set dst (DecodeNKlass src));
7012   // predicate(Universe::narrow_klass_shift() != 0 &amp;&amp;
7013   //           Universe::narrow_klass_base() != 0);
7014 
7015   //format %{ "DecodeNKlass $dst, $src \t// $src != NULL, expanded" %}
7016 
7017   ins_cost(DEFAULT_COST*2);  // Don't count constant.
7018   expand %{
7019     // We add first, then we shift. Like this, we can get along with one register less.
7020     // But we have to load the base pre-shifted.
7021     immL baseImm %{ (jlong)((intptr_t)Universe::narrow_klass_base() &gt;&gt; Universe::narrow_klass_shift()) %}
7022     iRegLdst base;
7023     loadConL_Ex(base, baseImm);
7024     decodeNKlass_notNull_addBase_Ex(dst, base, src);
7025   %}
7026 %}
7027 
7028 //----------MemBar Instructions-----------------------------------------------
7029 // Memory barrier flavors
7030 
7031 instruct membar_acquire() %{
7032   match(LoadFence);
7033   ins_cost(4*MEMORY_REF_COST);
7034 
7035   format %{ "MEMBAR-acquire" %}
7036   size(4);
7037   ins_encode %{
7038     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
7039     __ acquire();
7040   %}
7041   ins_pipe(pipe_class_default);
7042 %}
7043 
7044 instruct unnecessary_membar_acquire() %{
7045   match(MemBarAcquire);
7046   ins_cost(0);
7047 
7048   format %{ " -- \t// redundant MEMBAR-acquire - empty" %}
7049   size(0);
7050   ins_encode( /*empty*/ );
7051   ins_pipe(pipe_class_default);
7052 %}
7053 
7054 instruct membar_acquire_lock() %{
7055   match(MemBarAcquireLock);
7056   ins_cost(0);
7057 
7058   format %{ " -- \t// redundant MEMBAR-acquire - empty (acquire as part of CAS in prior FastLock)" %}
7059   size(0);
7060   ins_encode( /*empty*/ );
7061   ins_pipe(pipe_class_default);
7062 %}
7063 
7064 instruct membar_release() %{
7065   match(MemBarRelease);
7066   match(StoreFence);
7067   ins_cost(4*MEMORY_REF_COST);
7068 
7069   format %{ "MEMBAR-release" %}
7070   size(4);
7071   ins_encode %{
7072     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
7073     __ release();
7074   %}
7075   ins_pipe(pipe_class_default);
7076 %}
7077 
7078 instruct membar_storestore() %{
7079   match(MemBarStoreStore);
7080   ins_cost(4*MEMORY_REF_COST);
7081 
7082   format %{ "MEMBAR-store-store" %}
7083   size(4);
7084   ins_encode %{
7085     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
7086     __ membar(Assembler::StoreStore);
7087   %}
7088   ins_pipe(pipe_class_default);
7089 %}
7090 
7091 instruct membar_release_lock() %{
7092   match(MemBarReleaseLock);
7093   ins_cost(0);
7094 
7095   format %{ " -- \t// redundant MEMBAR-release - empty (release in FastUnlock)" %}
7096   size(0);
7097   ins_encode( /*empty*/ );
7098   ins_pipe(pipe_class_default);
7099 %}
7100 
7101 instruct membar_volatile() %{
7102   match(MemBarVolatile);
7103   ins_cost(4*MEMORY_REF_COST);
7104 
7105   format %{ "MEMBAR-volatile" %}
7106   size(4);
7107   ins_encode %{
7108     // TODO: PPC port $archOpcode(ppc64Opcode_sync);
7109     __ fence();
7110   %}
7111   ins_pipe(pipe_class_default);
7112 %}
7113 
7114 // This optimization is wrong on PPC. The following pattern is not supported:
7115 //  MemBarVolatile
7116 //   ^        ^
7117 //   |        |
7118 //  CtrlProj MemProj
7119 //   ^        ^
7120 //   |        |
7121 //   |       Load
7122 //   |
7123 //  MemBarVolatile
7124 //
7125 //  The first MemBarVolatile could get optimized out! According to
7126 //  Vladimir, this pattern can not occur on Oracle platforms.
7127 //  However, it does occur on PPC64 (because of membars in
7128 //  inline_unsafe_load_store).
7129 //
7130 // Add this node again if we found a good solution for inline_unsafe_load_store().
7131 // Don't forget to look at the implementation of post_store_load_barrier again,
7132 // we did other fixes in that method.
7133 //instruct unnecessary_membar_volatile() %{
7134 //  match(MemBarVolatile);
7135 //  predicate(Matcher::post_store_load_barrier(n));
7136 //  ins_cost(0);
7137 //
7138 //  format %{ " -- \t// redundant MEMBAR-volatile - empty" %}
7139 //  size(0);
7140 //  ins_encode( /*empty*/ );
7141 //  ins_pipe(pipe_class_default);
7142 //%}
7143 
7144 instruct membar_CPUOrder() %{
7145   match(MemBarCPUOrder);
7146   ins_cost(0);
7147 
7148   format %{ " -- \t// MEMBAR-CPUOrder - empty: PPC64 processors are self-consistent." %}
7149   size(0);
7150   ins_encode( /*empty*/ );
7151   ins_pipe(pipe_class_default);
7152 %}
7153 
7154 //----------Conditional Move---------------------------------------------------
7155 
7156 // Cmove using isel.
7157 instruct cmovI_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
7158   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
7159   predicate(VM_Version::has_isel());
7160   ins_cost(DEFAULT_COST);
7161 
7162   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7163   size(4);
7164   ins_encode %{
7165     // This is a Power7 instruction for which no machine description
7166     // exists. Anyways, the scheduler should be off on Power7.
7167     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7168     int cc        = $cmp$$cmpcode;
7169     __ isel($dst$$Register, $crx$$CondRegister,
7170             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
7171   %}
7172   ins_pipe(pipe_class_default);
7173 %}
7174 
7175 instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
7176   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
7177   predicate(!VM_Version::has_isel());
7178   ins_cost(DEFAULT_COST+BRANCH_COST);
7179 
7180   ins_variable_size_depending_on_alignment(true);
7181 
7182   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7183   // Worst case is branch + move + stop, no stop without scheduler
7184   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7185   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
7186   ins_pipe(pipe_class_default);
7187 %}
7188 
7189 instruct cmovI_imm(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, immI16 src) %{
7190   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
7191   ins_cost(DEFAULT_COST+BRANCH_COST);
7192 
7193   ins_variable_size_depending_on_alignment(true);
7194 
7195   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7196   // Worst case is branch + move + stop, no stop without scheduler
7197   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7198   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
7199   ins_pipe(pipe_class_default);
7200 %}
7201 
7202 // Cmove using isel.
7203 instruct cmovL_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
7204   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
7205   predicate(VM_Version::has_isel());
7206   ins_cost(DEFAULT_COST);
7207 
7208   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7209   size(4);
7210   ins_encode %{
7211     // This is a Power7 instruction for which no machine description
7212     // exists. Anyways, the scheduler should be off on Power7.
7213     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7214     int cc        = $cmp$$cmpcode;
7215     __ isel($dst$$Register, $crx$$CondRegister,
7216             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
7217   %}
7218   ins_pipe(pipe_class_default);
7219 %}
7220 
7221 instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
7222   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
7223   predicate(!VM_Version::has_isel());
7224   ins_cost(DEFAULT_COST+BRANCH_COST);
7225 
7226   ins_variable_size_depending_on_alignment(true);
7227 
7228   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7229   // Worst case is branch + move + stop, no stop without scheduler.
7230   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7231   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
7232   ins_pipe(pipe_class_default);
7233 %}
7234 
7235 instruct cmovL_imm(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, immL16 src) %{
7236   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
7237   ins_cost(DEFAULT_COST+BRANCH_COST);
7238 
7239   ins_variable_size_depending_on_alignment(true);
7240 
7241   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7242   // Worst case is branch + move + stop, no stop without scheduler.
7243   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7244   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
7245   ins_pipe(pipe_class_default);
7246 %}
7247 
7248 // Cmove using isel.
7249 instruct cmovN_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
7250   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
7251   predicate(VM_Version::has_isel());
7252   ins_cost(DEFAULT_COST);
7253 
7254   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7255   size(4);
7256   ins_encode %{
7257     // This is a Power7 instruction for which no machine description
7258     // exists. Anyways, the scheduler should be off on Power7.
7259     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7260     int cc        = $cmp$$cmpcode;
7261     __ isel($dst$$Register, $crx$$CondRegister,
7262             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
7263   %}
7264   ins_pipe(pipe_class_default);
7265 %}
7266 
7267 // Conditional move for RegN. Only cmov(reg, reg).
7268 instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
7269   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
7270   predicate(!VM_Version::has_isel());
7271   ins_cost(DEFAULT_COST+BRANCH_COST);
7272 
7273   ins_variable_size_depending_on_alignment(true);
7274 
7275   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7276   // Worst case is branch + move + stop, no stop without scheduler.
7277   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7278   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
7279   ins_pipe(pipe_class_default);
7280 %}
7281 
7282 instruct cmovN_imm(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, immN_0 src) %{
7283   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
7284   ins_cost(DEFAULT_COST+BRANCH_COST);
7285 
7286   ins_variable_size_depending_on_alignment(true);
7287 
7288   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7289   // Worst case is branch + move + stop, no stop without scheduler.
7290   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7291   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
7292   ins_pipe(pipe_class_default);
7293 %}
7294 
7295 // Cmove using isel.
7296 instruct cmovP_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegPsrc src) %{
7297   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
7298   predicate(VM_Version::has_isel());
7299   ins_cost(DEFAULT_COST);
7300 
7301   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7302   size(4);
7303   ins_encode %{
7304     // This is a Power7 instruction for which no machine description
7305     // exists. Anyways, the scheduler should be off on Power7.
7306     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7307     int cc        = $cmp$$cmpcode;
7308     __ isel($dst$$Register, $crx$$CondRegister,
7309             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
7310   %}
7311   ins_pipe(pipe_class_default);
7312 %}
7313 
7314 instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{
7315   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
7316   predicate(!VM_Version::has_isel());
7317   ins_cost(DEFAULT_COST+BRANCH_COST);
7318 
7319   ins_variable_size_depending_on_alignment(true);
7320 
7321   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7322   // Worst case is branch + move + stop, no stop without scheduler.
7323   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7324   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
7325   ins_pipe(pipe_class_default);
7326 %}
7327 
7328 instruct cmovP_imm(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, immP_0 src) %{
7329   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
7330   ins_cost(DEFAULT_COST+BRANCH_COST);
7331 
7332   ins_variable_size_depending_on_alignment(true);
7333 
7334   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7335   // Worst case is branch + move + stop, no stop without scheduler.
7336   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7337   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
7338   ins_pipe(pipe_class_default);
7339 %}
7340 
7341 instruct cmovF_reg(cmpOp cmp, flagsRegSrc crx, regF dst, regF src) %{
7342   match(Set dst (CMoveF (Binary cmp crx) (Binary dst src)));
7343   ins_cost(DEFAULT_COST+BRANCH_COST);
7344 
7345   ins_variable_size_depending_on_alignment(true);
7346 
7347   format %{ "CMOVEF  $cmp, $crx, $dst, $src\n\t" %}
7348   // Worst case is branch + move + stop, no stop without scheduler.
7349   size(false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8);
7350   ins_encode %{
7351     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
7352     Label done;
7353     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, "check encoding");
7354     // Branch if not (cmp crx).
7355     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
7356     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
7357     // TODO PPC port __ endgroup_if_needed(_size == 12);
7358     __ bind(done);
7359   %}
7360   ins_pipe(pipe_class_default);
7361 %}
7362 
7363 instruct cmovD_reg(cmpOp cmp, flagsRegSrc crx, regD dst, regD src) %{
7364   match(Set dst (CMoveD (Binary cmp crx) (Binary dst src)));
7365   ins_cost(DEFAULT_COST+BRANCH_COST);
7366 
7367   ins_variable_size_depending_on_alignment(true);
7368 
7369   format %{ "CMOVEF  $cmp, $crx, $dst, $src\n\t" %}
7370   // Worst case is branch + move + stop, no stop without scheduler.
7371   size(false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8);
7372   ins_encode %{
7373     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
7374     Label done;
7375     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, "check encoding");
7376     // Branch if not (cmp crx).
7377     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
7378     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
7379     // TODO PPC port __ endgroup_if_needed(_size == 12);
7380     __ bind(done);
7381   %}
7382   ins_pipe(pipe_class_default);
7383 %}
7384 
7385 //----------Conditional_store--------------------------------------------------
7386 // Conditional-store of the updated heap-top.
7387 // Used during allocation of the shared heap.
7388 // Sets flags (EQ) on success. Implemented with a CASA on Sparc.
7389 
7390 // As compareAndSwapL, but return flag register instead of boolean value in
7391 // int register.
7392 // Used by sun/misc/AtomicLongCSImpl.java.
7393 // Mem_ptr must be a memory operand, else this node does not get
7394 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
7395 // can be rematerialized which leads to errors.
7396 instruct storeLConditional_regP_regL_regL(flagsReg crx, indirect mem_ptr, iRegLsrc oldVal, iRegLsrc newVal, flagsRegCR0 cr0) %{
7397   match(Set crx (StoreLConditional mem_ptr (Binary oldVal newVal)));
7398   effect(TEMP cr0);
7399   format %{ "CMPXCHGD if ($crx = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool" %}
7400   ins_encode %{
7401     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7402     __ cmpxchgd($crx$$CondRegister, R0, $oldVal$$Register, $newVal$$Register, $mem_ptr$$Register,
7403                 MacroAssembler::MemBarAcq, MacroAssembler::cmpxchgx_hint_atomic_update(),
7404                 noreg, NULL, true);
7405   %}
7406   ins_pipe(pipe_class_default);
7407 %}
7408 
7409 // As compareAndSwapP, but return flag register instead of boolean value in
7410 // int register.
7411 // This instruction is matched if UseTLAB is off.
7412 // Mem_ptr must be a memory operand, else this node does not get
7413 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
7414 // can be rematerialized which leads to errors.
7415 instruct storePConditional_regP_regP_regP(flagsRegCR0 cr0, indirect mem_ptr, iRegPsrc oldVal, iRegPsrc newVal) %{
7416   match(Set cr0 (StorePConditional mem_ptr (Binary oldVal newVal)));
7417   ins_cost(2*MEMORY_REF_COST);
7418 
7419   format %{ "STDCX_  if ($cr0 = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool" %}
7420   ins_encode %{
7421     // TODO: PPC port $archOpcode(ppc64Opcode_stdcx_);
7422     __ stdcx_($newVal$$Register, $mem_ptr$$Register);
7423   %}
7424   ins_pipe(pipe_class_memory);
7425 %}
7426 
7427 // Implement LoadPLocked. Must be ordered against changes of the memory location
7428 // by storePConditional.
7429 // Don't know whether this is ever used.
7430 instruct loadPLocked(iRegPdst dst, memory mem) %{
7431   match(Set dst (LoadPLocked mem));
7432   ins_cost(2*MEMORY_REF_COST);
7433 
7434   format %{ "LDARX   $dst, $mem \t// loadPLocked\n\t" %}
7435   size(4);
7436   ins_encode %{
7437     // TODO: PPC port $archOpcode(ppc64Opcode_ldarx);
7438     __ ldarx($dst$$Register, $mem$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
7439   %}
7440   ins_pipe(pipe_class_memory);
7441 %}
7442 
7443 //----------Compare-And-Swap---------------------------------------------------
7444 
7445 // CompareAndSwap{P,I,L} have more than one output, therefore "CmpI
7446 // (CompareAndSwap ...)" or "If (CmpI (CompareAndSwap ..))"  cannot be
7447 // matched.
7448 
7449 // Strong versions:
7450 
7451 instruct compareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7452   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
7453   predicate(VM_Version::has_lqarx());
7454   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7455   format %{ "CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool" %}
7456   ins_encode %{
7457     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7458     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7459     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7460                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7461                 $res$$Register, true);
7462     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7463       __ isync();
7464     } else {
7465       __ sync();
7466     }
7467   %}
7468   ins_pipe(pipe_class_default);
7469 %}
7470 
7471 instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7472   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
7473   predicate(!VM_Version::has_lqarx());
7474   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7475   format %{ "CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool" %}
7476   ins_encode %{
7477     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7478     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7479     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7480                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7481                 $res$$Register, true);
7482     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7483       __ isync();
7484     } else {
7485       __ sync();
7486     }
7487   %}
7488   ins_pipe(pipe_class_default);
7489 %}
7490 
7491 instruct compareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7492   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
7493   predicate(VM_Version::has_lqarx());
7494   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7495   format %{ "CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool" %}
7496   ins_encode %{
7497     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7498     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7499     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7500                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7501                 $res$$Register, true);
7502     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7503       __ isync();
7504     } else {
7505       __ sync();
7506     }
7507   %}
7508   ins_pipe(pipe_class_default);
7509 %}
7510 
7511 instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7512   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
7513   predicate(!VM_Version::has_lqarx());
7514   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7515   format %{ "CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool" %}
7516   ins_encode %{
7517     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7518     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7519     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7520                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7521                 $res$$Register, true);
7522     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7523       __ isync();
7524     } else {
7525       __ sync();
7526     }
7527   %}
7528   ins_pipe(pipe_class_default);
7529 %}
7530 
7531 instruct compareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7532   match(Set res (CompareAndSwapI mem_ptr (Binary src1 src2)));
7533   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7534   format %{ "CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool" %}
7535   ins_encode %{
7536     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7537     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7538     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7539                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7540                 $res$$Register, true);
7541     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7542       __ isync();
7543     } else {
7544       __ sync();
7545     }
7546   %}
7547   ins_pipe(pipe_class_default);
7548 %}
7549 
7550 instruct compareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
7551   match(Set res (CompareAndSwapN mem_ptr (Binary src1 src2)));
7552   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7553   format %{ "CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool" %}
7554   ins_encode %{
7555     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7556     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7557     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7558                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7559                 $res$$Register, true);
7560     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7561       __ isync();
7562     } else {
7563       __ sync();
7564     }
7565   %}
7566   ins_pipe(pipe_class_default);
7567 %}
7568 
7569 instruct compareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
7570   match(Set res (CompareAndSwapL mem_ptr (Binary src1 src2)));
7571   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7572   format %{ "CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool" %}
7573   ins_encode %{
7574     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7575     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7576     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7577                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7578                 $res$$Register, NULL, true);
7579     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7580       __ isync();
7581     } else {
7582       __ sync();
7583     }
7584   %}
7585   ins_pipe(pipe_class_default);
7586 %}
7587 
7588 instruct compareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
7589   match(Set res (CompareAndSwapP mem_ptr (Binary src1 src2)));
7590   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7591   format %{ "CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr" %}
7592   ins_encode %{
7593     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7594     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7595     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7596                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7597                 $res$$Register, NULL, true);
7598     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7599       __ isync();
7600     } else {
7601       __ sync();
7602     }
7603   %}
7604   ins_pipe(pipe_class_default);
7605 %}
7606 
7607 // Weak versions:
7608 
7609 instruct weakCompareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7610   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
7611   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
7612   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7613   format %{ "weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool" %}
7614   ins_encode %{
7615     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7616     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7617     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7618                 MacroAssembler::MemBarNone,
7619                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7620   %}
7621   ins_pipe(pipe_class_default);
7622 %}
7623 
7624 instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7625   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
7626   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
7627   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7628   format %{ "weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool" %}
7629   ins_encode %{
7630     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7631     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7632     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7633                 MacroAssembler::MemBarNone,
7634                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7635   %}
7636   ins_pipe(pipe_class_default);
7637 %}
7638 
7639 instruct weakCompareAndSwapB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7640   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
7641   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
7642   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7643   format %{ "weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool" %}
7644   ins_encode %{
7645     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7646     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7647     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7648                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7649                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7650   %}
7651   ins_pipe(pipe_class_default);
7652 %}
7653 
7654 instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7655   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
7656   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
7657   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7658   format %{ "weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool" %}
7659   ins_encode %{
7660     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7661     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7662     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7663                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7664                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7665   %}
7666   ins_pipe(pipe_class_default);
7667 %}
7668 
7669 instruct weakCompareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7670   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
7671   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
7672   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7673   format %{ "weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool" %}
7674   ins_encode %{
7675     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7676     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7677     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7678                 MacroAssembler::MemBarNone,
7679                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7680   %}
7681   ins_pipe(pipe_class_default);
7682 %}
7683 
7684 instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7685   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
7686   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
7687   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7688   format %{ "weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool" %}
7689   ins_encode %{
7690     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7691     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7692     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7693                 MacroAssembler::MemBarNone,
7694                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7695   %}
7696   ins_pipe(pipe_class_default);
7697 %}
7698 
7699 instruct weakCompareAndSwapS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7700   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
7701   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
7702   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7703   format %{ "weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool" %}
7704   ins_encode %{
7705     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7706     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7707     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7708                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7709                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7710   %}
7711   ins_pipe(pipe_class_default);
7712 %}
7713 
7714 instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7715   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
7716   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
7717   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7718   format %{ "weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool" %}
7719   ins_encode %{
7720     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7721     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7722     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7723                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7724                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7725   %}
7726   ins_pipe(pipe_class_default);
7727 %}
7728 
7729 instruct weakCompareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7730   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
7731   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
7732   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7733   format %{ "weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool" %}
7734   ins_encode %{
7735     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7736     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7737     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7738                 MacroAssembler::MemBarNone,
7739                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7740   %}
7741   ins_pipe(pipe_class_default);
7742 %}
7743 
7744 instruct weakCompareAndSwapI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7745   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
7746   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
7747   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7748   format %{ "weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool" %}
7749   ins_encode %{
7750     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7751     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7752     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
7753     // value is never passed to caller.
7754     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7755                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7756                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7757   %}
7758   ins_pipe(pipe_class_default);
7759 %}
7760 
7761 instruct weakCompareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
7762   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
7763   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
7764   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7765   format %{ "weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool" %}
7766   ins_encode %{
7767     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7768     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7769     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7770                 MacroAssembler::MemBarNone,
7771                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7772   %}
7773   ins_pipe(pipe_class_default);
7774 %}
7775 
7776 instruct weakCompareAndSwapN_acq_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
7777   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
7778   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
7779   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7780   format %{ "weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool" %}
7781   ins_encode %{
7782     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7783     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7784     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
7785     // value is never passed to caller.
7786     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7787                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7788                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7789   %}
7790   ins_pipe(pipe_class_default);
7791 %}
7792 
7793 instruct weakCompareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
7794   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
7795   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
7796   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7797   format %{ "weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool" %}
7798   ins_encode %{
7799     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7800     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7801     // value is never passed to caller.
7802     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7803                 MacroAssembler::MemBarNone,
7804                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
7805   %}
7806   ins_pipe(pipe_class_default);
7807 %}
7808 
7809 instruct weakCompareAndSwapL_acq_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
7810   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
7811   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
7812   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7813   format %{ "weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool" %}
7814   ins_encode %{
7815     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7816     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7817     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
7818     // value is never passed to caller.
7819     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7820                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7821                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
7822   %}
7823   ins_pipe(pipe_class_default);
7824 %}
7825 
7826 instruct weakCompareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
7827   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
7828   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
7829   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7830   format %{ "weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr" %}
7831   ins_encode %{
7832     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7833     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7834     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7835                 MacroAssembler::MemBarNone,
7836                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
7837   %}
7838   ins_pipe(pipe_class_default);
7839 %}
7840 
7841 instruct weakCompareAndSwapP_acq_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
7842   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
7843   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
7844   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7845   format %{ "weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool; ptr" %}
7846   ins_encode %{
7847     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7848     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7849     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
7850     // value is never passed to caller.
7851     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7852                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7853                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
7854   %}
7855   ins_pipe(pipe_class_default);
7856 %}
7857 
7858 // CompareAndExchange
7859 
7860 instruct compareAndExchangeB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7861   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
7862   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
7863   effect(TEMP_DEF res, TEMP cr0);
7864   format %{ "CMPXCHGB $res, $mem_ptr, $src1, $src2; as int" %}
7865   ins_encode %{
7866     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7867     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7868     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7869                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7870                 noreg, true);
7871   %}
7872   ins_pipe(pipe_class_default);
7873 %}
7874 
7875 instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
7876   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
7877   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
7878   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
7879   format %{ "CMPXCHGB $res, $mem_ptr, $src1, $src2; as int" %}
7880   ins_encode %{
7881     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7882     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7883     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
7884                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7885                 noreg, true);
7886   %}
7887   ins_pipe(pipe_class_default);
7888 %}
7889 
7890 instruct compareAndExchangeB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7891   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
7892   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
7893   effect(TEMP_DEF res, TEMP cr0);
7894   format %{ "CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int" %}
7895   ins_encode %{
7896     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7897     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7898     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7899                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7900                 noreg, true);
7901     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7902       __ isync();
7903     } else {
7904       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
7905       __ sync();
7906     }
7907   %}
7908   ins_pipe(pipe_class_default);
7909 %}
7910 
7911 instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
7912   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
7913   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
7914   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
7915   format %{ "CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int" %}
7916   ins_encode %{
7917     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7918     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7919     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
7920                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7921                 noreg, true);
7922     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7923       __ isync();
7924     } else {
7925       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
7926       __ sync();
7927     }
7928   %}
7929   ins_pipe(pipe_class_default);
7930 %}
7931 
7932 instruct compareAndExchangeS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7933   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
7934   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
7935   effect(TEMP_DEF res, TEMP cr0);
7936   format %{ "CMPXCHGH $res, $mem_ptr, $src1, $src2; as int" %}
7937   ins_encode %{
7938     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7939     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7940     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7941                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7942                 noreg, true);
7943   %}
7944   ins_pipe(pipe_class_default);
7945 %}
7946 
7947 instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
7948   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
7949   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
7950   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
7951   format %{ "CMPXCHGH $res, $mem_ptr, $src1, $src2; as int" %}
7952   ins_encode %{
7953     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7954     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7955     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
7956                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7957                 noreg, true);
7958   %}
7959   ins_pipe(pipe_class_default);
7960 %}
7961 
7962 instruct compareAndExchangeS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7963   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
7964   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
7965   effect(TEMP_DEF res, TEMP cr0);
7966   format %{ "CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int" %}
7967   ins_encode %{
7968     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7969     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7970     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7971                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7972                 noreg, true);
7973     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7974       __ isync();
7975     } else {
7976       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
7977       __ sync();
7978     }
7979   %}
7980   ins_pipe(pipe_class_default);
7981 %}
7982 
7983 instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
7984   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
7985   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
7986   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
7987   format %{ "CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int" %}
7988   ins_encode %{
7989     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7990     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7991     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
7992                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7993                 noreg, true);
7994     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7995       __ isync();
7996     } else {
7997       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
7998       __ sync();
7999     }
8000   %}
8001   ins_pipe(pipe_class_default);
8002 %}
8003 
8004 instruct compareAndExchangeI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
8005   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
8006   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
8007   effect(TEMP_DEF res, TEMP cr0);
8008   format %{ "CMPXCHGW $res, $mem_ptr, $src1, $src2; as int" %}
8009   ins_encode %{
8010     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8011     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8012     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8013                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8014                 noreg, true);
8015   %}
8016   ins_pipe(pipe_class_default);
8017 %}
8018 
8019 instruct compareAndExchangeI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
8020   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
8021   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
8022   effect(TEMP_DEF res, TEMP cr0);
8023   format %{ "CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as int" %}
8024   ins_encode %{
8025     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8026     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8027     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8028                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8029                 noreg, true);
8030     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8031       __ isync();
8032     } else {
8033       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
8034       __ sync();
8035     }
8036   %}
8037   ins_pipe(pipe_class_default);
8038 %}
8039 
8040 instruct compareAndExchangeN_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
8041   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
8042   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
8043   effect(TEMP_DEF res, TEMP cr0);
8044   format %{ "CMPXCHGW $res, $mem_ptr, $src1, $src2; as narrow oop" %}
8045   ins_encode %{
8046     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8047     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8048     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8049                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8050                 noreg, true);
8051   %}
8052   ins_pipe(pipe_class_default);
8053 %}
8054 
8055 instruct compareAndExchangeN_acq_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
8056   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
8057   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
8058   effect(TEMP_DEF res, TEMP cr0);
8059   format %{ "CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as narrow oop" %}
8060   ins_encode %{
8061     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8062     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8063     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8064                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8065                 noreg, true);
8066     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8067       __ isync();
8068     } else {
8069       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
8070       __ sync();
8071     }
8072   %}
8073   ins_pipe(pipe_class_default);
8074 %}
8075 
8076 instruct compareAndExchangeL_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
8077   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
8078   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
8079   effect(TEMP_DEF res, TEMP cr0);
8080   format %{ "CMPXCHGD $res, $mem_ptr, $src1, $src2; as long" %}
8081   ins_encode %{
8082     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8083     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8084     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8085                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8086                 noreg, NULL, true);
8087   %}
8088   ins_pipe(pipe_class_default);
8089 %}
8090 
8091 instruct compareAndExchangeL_acq_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
8092   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
8093   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
8094   effect(TEMP_DEF res, TEMP cr0);
8095   format %{ "CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as long" %}
8096   ins_encode %{
8097     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8098     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8099     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8100                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8101                 noreg, NULL, true);
8102     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8103       __ isync();
8104     } else {
8105       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
8106       __ sync();
8107     }
8108   %}
8109   ins_pipe(pipe_class_default);
8110 %}
8111 
8112 instruct compareAndExchangeP_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
8113   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
8114   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
8115   effect(TEMP_DEF res, TEMP cr0);
8116   format %{ "CMPXCHGD $res, $mem_ptr, $src1, $src2; as ptr; ptr" %}
8117   ins_encode %{
8118     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8119     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8120     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8121                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8122                 noreg, NULL, true);
8123   %}
8124   ins_pipe(pipe_class_default);
8125 %}
8126 
8127 instruct compareAndExchangeP_acq_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
8128   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
8129   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
8130   effect(TEMP_DEF res, TEMP cr0);
8131   format %{ "CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as ptr; ptr" %}
8132   ins_encode %{
8133     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8134     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8135     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8136                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8137                 noreg, NULL, true);
8138     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8139       __ isync();
8140     } else {
8141       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
8142       __ sync();
8143     }
8144   %}
8145   ins_pipe(pipe_class_default);
8146 %}
8147 
8148 // Special RMW
8149 
8150 instruct getAndAddB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8151   match(Set res (GetAndAddB mem_ptr src));
8152   predicate(VM_Version::has_lqarx());
8153   effect(TEMP_DEF res, TEMP cr0);
8154   format %{ "GetAndAddB $res, $mem_ptr, $src" %}
8155   ins_encode %{
8156     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
8157                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
8158     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8159       __ isync();
8160     } else {
8161       __ sync();
8162     }
8163   %}
8164   ins_pipe(pipe_class_default);
8165 %}
8166 
8167 instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
8168   match(Set res (GetAndAddB mem_ptr src));
8169   predicate(!VM_Version::has_lqarx());
8170   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
8171   format %{ "GetAndAddB $res, $mem_ptr, $src" %}
8172   ins_encode %{
8173     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
8174                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
8175     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8176       __ isync();
8177     } else {
8178       __ sync();
8179     }
8180   %}
8181   ins_pipe(pipe_class_default);
8182 %}
8183 
8184 instruct getAndAddS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8185   match(Set res (GetAndAddS mem_ptr src));
8186   predicate(VM_Version::has_lqarx());
8187   effect(TEMP_DEF res, TEMP cr0);
8188   format %{ "GetAndAddS $res, $mem_ptr, $src" %}
8189   ins_encode %{
8190     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
8191                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
8192     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8193       __ isync();
8194     } else {
8195       __ sync();
8196     }
8197   %}
8198   ins_pipe(pipe_class_default);
8199 %}
8200 
8201 instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
8202   match(Set res (GetAndAddS mem_ptr src));
8203   predicate(!VM_Version::has_lqarx());
8204   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
8205   format %{ "GetAndAddS $res, $mem_ptr, $src" %}
8206   ins_encode %{
8207     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
8208                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
8209     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8210       __ isync();
8211     } else {
8212       __ sync();
8213     }
8214   %}
8215   ins_pipe(pipe_class_default);
8216 %}
8217 
8218 instruct getAndAddI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8219   match(Set res (GetAndAddI mem_ptr src));
8220   effect(TEMP_DEF res, TEMP cr0);
8221   format %{ "GetAndAddI $res, $mem_ptr, $src" %}
8222   ins_encode %{
8223     __ getandaddw($res$$Register, $src$$Register, $mem_ptr$$Register,
8224                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
8225     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8226       __ isync();
8227     } else {
8228       __ sync();
8229     }
8230   %}
8231   ins_pipe(pipe_class_default);
8232 %}
8233 
8234 instruct getAndAddL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
8235   match(Set res (GetAndAddL mem_ptr src));
8236   effect(TEMP_DEF res, TEMP cr0);
8237   format %{ "GetAndAddL $res, $mem_ptr, $src" %}
8238   ins_encode %{
8239     __ getandaddd($res$$Register, $src$$Register, $mem_ptr$$Register,
8240                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
8241     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8242       __ isync();
8243     } else {
8244       __ sync();
8245     }
8246   %}
8247   ins_pipe(pipe_class_default);
8248 %}
8249 
8250 instruct getAndSetB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8251   match(Set res (GetAndSetB mem_ptr src));
8252   predicate(VM_Version::has_lqarx());
8253   effect(TEMP_DEF res, TEMP cr0);
8254   format %{ "GetAndSetB $res, $mem_ptr, $src" %}
8255   ins_encode %{
8256     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
8257                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
8258     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8259       __ isync();
8260     } else {
8261       __ sync();
8262     }
8263   %}
8264   ins_pipe(pipe_class_default);
8265 %}
8266 
8267 instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
8268   match(Set res (GetAndSetB mem_ptr src));
8269   predicate(!VM_Version::has_lqarx());
8270   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
8271   format %{ "GetAndSetB $res, $mem_ptr, $src" %}
8272   ins_encode %{
8273     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
8274                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
8275     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8276       __ isync();
8277     } else {
8278       __ sync();
8279     }
8280   %}
8281   ins_pipe(pipe_class_default);
8282 %}
8283 
8284 instruct getAndSetS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8285   match(Set res (GetAndSetS mem_ptr src));
8286   predicate(VM_Version::has_lqarx());
8287   effect(TEMP_DEF res, TEMP cr0);
8288   format %{ "GetAndSetS $res, $mem_ptr, $src" %}
8289   ins_encode %{
8290     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
8291                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
8292     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8293       __ isync();
8294     } else {
8295       __ sync();
8296     }
8297   %}
8298   ins_pipe(pipe_class_default);
8299 %}
8300 
8301 instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
8302   match(Set res (GetAndSetS mem_ptr src));
8303   predicate(!VM_Version::has_lqarx());
8304   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
8305   format %{ "GetAndSetS $res, $mem_ptr, $src" %}
8306   ins_encode %{
8307     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
8308                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
8309     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8310       __ isync();
8311     } else {
8312       __ sync();
8313     }
8314   %}
8315   ins_pipe(pipe_class_default);
8316 %}
8317 
8318 instruct getAndSetI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8319   match(Set res (GetAndSetI mem_ptr src));
8320   effect(TEMP_DEF res, TEMP cr0);
8321   format %{ "GetAndSetI $res, $mem_ptr, $src" %}
8322   ins_encode %{
8323     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
8324                   MacroAssembler::cmpxchgx_hint_atomic_update());
8325     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8326       __ isync();
8327     } else {
8328       __ sync();
8329     }
8330   %}
8331   ins_pipe(pipe_class_default);
8332 %}
8333 
8334 instruct getAndSetL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
8335   match(Set res (GetAndSetL mem_ptr src));
8336   effect(TEMP_DEF res, TEMP cr0);
8337   format %{ "GetAndSetL $res, $mem_ptr, $src" %}
8338   ins_encode %{
8339     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
8340                   MacroAssembler::cmpxchgx_hint_atomic_update());
8341     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8342       __ isync();
8343     } else {
8344       __ sync();
8345     }
8346   %}
8347   ins_pipe(pipe_class_default);
8348 %}
8349 
8350 instruct getAndSetP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src, flagsRegCR0 cr0) %{
8351   match(Set res (GetAndSetP mem_ptr src));
8352   effect(TEMP_DEF res, TEMP cr0);
8353   format %{ "GetAndSetP $res, $mem_ptr, $src" %}
8354   ins_encode %{
8355     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
8356                   MacroAssembler::cmpxchgx_hint_atomic_update());
8357     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8358       __ isync();
8359     } else {
8360       __ sync();
8361     }
8362   %}
8363   ins_pipe(pipe_class_default);
8364 %}
8365 
8366 instruct getAndSetN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src, flagsRegCR0 cr0) %{
8367   match(Set res (GetAndSetN mem_ptr src));
8368   effect(TEMP_DEF res, TEMP cr0);
8369   format %{ "GetAndSetN $res, $mem_ptr, $src" %}
8370   ins_encode %{
8371     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
8372                   MacroAssembler::cmpxchgx_hint_atomic_update());
8373     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8374       __ isync();
8375     } else {
8376       __ sync();
8377     }
8378   %}
8379   ins_pipe(pipe_class_default);
8380 %}
8381 
8382 //----------Arithmetic Instructions--------------------------------------------
8383 // Addition Instructions
8384 
8385 // Register Addition
8386 instruct addI_reg_reg(iRegIdst dst, iRegIsrc_iRegL2Isrc src1, iRegIsrc_iRegL2Isrc src2) %{
8387   match(Set dst (AddI src1 src2));
8388   format %{ "ADD     $dst, $src1, $src2" %}
8389   size(4);
8390   ins_encode %{
8391     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8392     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8393   %}
8394   ins_pipe(pipe_class_default);
8395 %}
8396 
8397 // Expand does not work with above instruct. (??)
8398 instruct addI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8399   // no match-rule
8400   effect(DEF dst, USE src1, USE src2);
8401   format %{ "ADD     $dst, $src1, $src2" %}
8402   size(4);
8403   ins_encode %{
8404     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8405     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8406   %}
8407   ins_pipe(pipe_class_default);
8408 %}
8409 
8410 instruct tree_addI_addI_addI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
8411   match(Set dst (AddI (AddI (AddI src1 src2) src3) src4));
8412   ins_cost(DEFAULT_COST*3);
8413 
8414   expand %{
8415     // FIXME: we should do this in the ideal world.
8416     iRegIdst tmp1;
8417     iRegIdst tmp2;
8418     addI_reg_reg(tmp1, src1, src2);
8419     addI_reg_reg_2(tmp2, src3, src4); // Adlc complains about addI_reg_reg.
8420     addI_reg_reg(dst, tmp1, tmp2);
8421   %}
8422 %}
8423 
8424 // Immediate Addition
8425 instruct addI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
8426   match(Set dst (AddI src1 src2));
8427   format %{ "ADDI    $dst, $src1, $src2" %}
8428   size(4);
8429   ins_encode %{
8430     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
8431     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
8432   %}
8433   ins_pipe(pipe_class_default);
8434 %}
8435 
8436 // Immediate Addition with 16-bit shifted operand
8437 instruct addI_reg_immhi16(iRegIdst dst, iRegIsrc src1, immIhi16 src2) %{
8438   match(Set dst (AddI src1 src2));
8439   format %{ "ADDIS   $dst, $src1, $src2" %}
8440   size(4);
8441   ins_encode %{
8442     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
8443     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
8444   %}
8445   ins_pipe(pipe_class_default);
8446 %}
8447 
8448 // Long Addition
8449 instruct addL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8450   match(Set dst (AddL src1 src2));
8451   format %{ "ADD     $dst, $src1, $src2 \t// long" %}
8452   size(4);
8453   ins_encode %{
8454     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8455     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8456   %}
8457   ins_pipe(pipe_class_default);
8458 %}
8459 
8460 // Expand does not work with above instruct. (??)
8461 instruct addL_reg_reg_2(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8462   // no match-rule
8463   effect(DEF dst, USE src1, USE src2);
8464   format %{ "ADD     $dst, $src1, $src2 \t// long" %}
8465   size(4);
8466   ins_encode %{
8467     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8468     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8469   %}
8470   ins_pipe(pipe_class_default);
8471 %}
8472 
8473 instruct tree_addL_addL_addL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2, iRegLsrc src3, iRegLsrc src4) %{
8474   match(Set dst (AddL (AddL (AddL src1 src2) src3) src4));
8475   ins_cost(DEFAULT_COST*3);
8476 
8477   expand %{
8478     // FIXME: we should do this in the ideal world.
8479     iRegLdst tmp1;
8480     iRegLdst tmp2;
8481     addL_reg_reg(tmp1, src1, src2);
8482     addL_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
8483     addL_reg_reg(dst, tmp1, tmp2);
8484   %}
8485 %}
8486 
8487 // AddL + ConvL2I.
8488 instruct addI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
8489   match(Set dst (ConvL2I (AddL src1 src2)));
8490 
8491   format %{ "ADD     $dst, $src1, $src2 \t// long + l2i" %}
8492   size(4);
8493   ins_encode %{
8494     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8495     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8496   %}
8497   ins_pipe(pipe_class_default);
8498 %}
8499 
8500 // No constant pool entries required.
8501 instruct addL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
8502   match(Set dst (AddL src1 src2));
8503 
8504   format %{ "ADDI    $dst, $src1, $src2" %}
8505   size(4);
8506   ins_encode %{
8507     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
8508     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
8509   %}
8510   ins_pipe(pipe_class_default);
8511 %}
8512 
8513 // Long Immediate Addition with 16-bit shifted operand.
8514 // No constant pool entries required.
8515 instruct addL_reg_immhi16(iRegLdst dst, iRegLsrc src1, immL32hi16 src2) %{
8516   match(Set dst (AddL src1 src2));
8517 
8518   format %{ "ADDIS   $dst, $src1, $src2" %}
8519   size(4);
8520   ins_encode %{
8521     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
8522     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
8523   %}
8524   ins_pipe(pipe_class_default);
8525 %}
8526 
8527 // Pointer Register Addition
8528 instruct addP_reg_reg(iRegPdst dst, iRegP_N2P src1, iRegLsrc src2) %{
8529   match(Set dst (AddP src1 src2));
8530   format %{ "ADD     $dst, $src1, $src2" %}
8531   size(4);
8532   ins_encode %{
8533     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8534     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8535   %}
8536   ins_pipe(pipe_class_default);
8537 %}
8538 
8539 // Pointer Immediate Addition
8540 // No constant pool entries required.
8541 instruct addP_reg_imm16(iRegPdst dst, iRegP_N2P src1, immL16 src2) %{
8542   match(Set dst (AddP src1 src2));
8543 
8544   format %{ "ADDI    $dst, $src1, $src2" %}
8545   size(4);
8546   ins_encode %{
8547     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
8548     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
8549   %}
8550   ins_pipe(pipe_class_default);
8551 %}
8552 
8553 // Pointer Immediate Addition with 16-bit shifted operand.
8554 // No constant pool entries required.
8555 instruct addP_reg_immhi16(iRegPdst dst, iRegP_N2P src1, immL32hi16 src2) %{
8556   match(Set dst (AddP src1 src2));
8557 
8558   format %{ "ADDIS   $dst, $src1, $src2" %}
8559   size(4);
8560   ins_encode %{
8561     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
8562     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
8563   %}
8564   ins_pipe(pipe_class_default);
8565 %}
8566 
8567 //---------------------
8568 // Subtraction Instructions
8569 
8570 // Register Subtraction
8571 instruct subI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8572   match(Set dst (SubI src1 src2));
8573   format %{ "SUBF    $dst, $src2, $src1" %}
8574   size(4);
8575   ins_encode %{
8576     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
8577     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
8578   %}
8579   ins_pipe(pipe_class_default);
8580 %}
8581 
8582 // Immediate Subtraction
8583 // Immediate Subtraction: The compiler converts "x-c0" into "x+ -c0" (see SubLNode::Ideal),
8584 // Don't try to use addi with - $src2$$constant since it can overflow when $src2$$constant == minI16.
8585 
8586 // SubI from constant (using subfic).
8587 instruct subI_imm16_reg(iRegIdst dst, immI16 src1, iRegIsrc src2) %{
8588   match(Set dst (SubI src1 src2));
8589   format %{ "SUBI    $dst, $src1, $src2" %}
8590 
8591   size(4);
8592   ins_encode %{
8593     // TODO: PPC port $archOpcode(ppc64Opcode_subfic);
8594     __ subfic($dst$$Register, $src2$$Register, $src1$$constant);
8595   %}
8596   ins_pipe(pipe_class_default);
8597 %}
8598 
8599 // Turn the sign-bit of an integer into a 32-bit mask, 0x0...0 for
8600 // positive integers and 0xF...F for negative ones.
8601 instruct signmask32I_regI(iRegIdst dst, iRegIsrc src) %{
8602   // no match-rule, false predicate
8603   effect(DEF dst, USE src);
8604   predicate(false);
8605 
8606   format %{ "SRAWI   $dst, $src, #31" %}
8607   size(4);
8608   ins_encode %{
8609     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
8610     __ srawi($dst$$Register, $src$$Register, 0x1f);
8611   %}
8612   ins_pipe(pipe_class_default);
8613 %}
8614 
8615 instruct absI_reg_Ex(iRegIdst dst, iRegIsrc src) %{
8616   match(Set dst (AbsI src));
8617   ins_cost(DEFAULT_COST*3);
8618 
8619   expand %{
8620     iRegIdst tmp1;
8621     iRegIdst tmp2;
8622     signmask32I_regI(tmp1, src);
8623     xorI_reg_reg(tmp2, tmp1, src);
8624     subI_reg_reg(dst, tmp2, tmp1);
8625   %}
8626 %}
8627 
8628 instruct negI_regI(iRegIdst dst, immI_0 zero, iRegIsrc src2) %{
8629   match(Set dst (SubI zero src2));
8630   format %{ "NEG     $dst, $src2" %}
8631   size(4);
8632   ins_encode %{
8633     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
8634     __ neg($dst$$Register, $src2$$Register);
8635   %}
8636   ins_pipe(pipe_class_default);
8637 %}
8638 
8639 // Long subtraction
8640 instruct subL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8641   match(Set dst (SubL src1 src2));
8642   format %{ "SUBF    $dst, $src2, $src1 \t// long" %}
8643   size(4);
8644   ins_encode %{
8645     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
8646     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
8647   %}
8648   ins_pipe(pipe_class_default);
8649 %}
8650 
8651 // SubL + convL2I.
8652 instruct subI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
8653   match(Set dst (ConvL2I (SubL src1 src2)));
8654 
8655   format %{ "SUBF    $dst, $src2, $src1 \t// long + l2i" %}
8656   size(4);
8657   ins_encode %{
8658     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
8659     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
8660   %}
8661   ins_pipe(pipe_class_default);
8662 %}
8663 
8664 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
8665 // positive longs and 0xF...F for negative ones.
8666 instruct signmask64I_regL(iRegIdst dst, iRegLsrc src) %{
8667   // no match-rule, false predicate
8668   effect(DEF dst, USE src);
8669   predicate(false);
8670 
8671   format %{ "SRADI   $dst, $src, #63" %}
8672   size(4);
8673   ins_encode %{
8674     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
8675     __ sradi($dst$$Register, $src$$Register, 0x3f);
8676   %}
8677   ins_pipe(pipe_class_default);
8678 %}
8679 
8680 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
8681 // positive longs and 0xF...F for negative ones.
8682 instruct signmask64L_regL(iRegLdst dst, iRegLsrc src) %{
8683   // no match-rule, false predicate
8684   effect(DEF dst, USE src);
8685   predicate(false);
8686 
8687   format %{ "SRADI   $dst, $src, #63" %}
8688   size(4);
8689   ins_encode %{
8690     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
8691     __ sradi($dst$$Register, $src$$Register, 0x3f);
8692   %}
8693   ins_pipe(pipe_class_default);
8694 %}
8695 
8696 // Long negation
8697 instruct negL_reg_reg(iRegLdst dst, immL_0 zero, iRegLsrc src2) %{
8698   match(Set dst (SubL zero src2));
8699   format %{ "NEG     $dst, $src2 \t// long" %}
8700   size(4);
8701   ins_encode %{
8702     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
8703     __ neg($dst$$Register, $src2$$Register);
8704   %}
8705   ins_pipe(pipe_class_default);
8706 %}
8707 
8708 // NegL + ConvL2I.
8709 instruct negI_con0_regL(iRegIdst dst, immL_0 zero, iRegLsrc src2) %{
8710   match(Set dst (ConvL2I (SubL zero src2)));
8711 
8712   format %{ "NEG     $dst, $src2 \t// long + l2i" %}
8713   size(4);
8714   ins_encode %{
8715     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
8716     __ neg($dst$$Register, $src2$$Register);
8717   %}
8718   ins_pipe(pipe_class_default);
8719 %}
8720 
8721 // Multiplication Instructions
8722 // Integer Multiplication
8723 
8724 // Register Multiplication
8725 instruct mulI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8726   match(Set dst (MulI src1 src2));
8727   ins_cost(DEFAULT_COST);
8728 
8729   format %{ "MULLW   $dst, $src1, $src2" %}
8730   size(4);
8731   ins_encode %{
8732     // TODO: PPC port $archOpcode(ppc64Opcode_mullw);
8733     __ mullw($dst$$Register, $src1$$Register, $src2$$Register);
8734   %}
8735   ins_pipe(pipe_class_default);
8736 %}
8737 
8738 // Immediate Multiplication
8739 instruct mulI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
8740   match(Set dst (MulI src1 src2));
8741   ins_cost(DEFAULT_COST);
8742 
8743   format %{ "MULLI   $dst, $src1, $src2" %}
8744   size(4);
8745   ins_encode %{
8746     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
8747     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
8748   %}
8749   ins_pipe(pipe_class_default);
8750 %}
8751 
8752 instruct mulL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8753   match(Set dst (MulL src1 src2));
8754   ins_cost(DEFAULT_COST);
8755 
8756   format %{ "MULLD   $dst $src1, $src2 \t// long" %}
8757   size(4);
8758   ins_encode %{
8759     // TODO: PPC port $archOpcode(ppc64Opcode_mulld);
8760     __ mulld($dst$$Register, $src1$$Register, $src2$$Register);
8761   %}
8762   ins_pipe(pipe_class_default);
8763 %}
8764 
8765 // Multiply high for optimized long division by constant.
8766 instruct mulHighL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8767   match(Set dst (MulHiL src1 src2));
8768   ins_cost(DEFAULT_COST);
8769 
8770   format %{ "MULHD   $dst $src1, $src2 \t// long" %}
8771   size(4);
8772   ins_encode %{
8773     // TODO: PPC port $archOpcode(ppc64Opcode_mulhd);
8774     __ mulhd($dst$$Register, $src1$$Register, $src2$$Register);
8775   %}
8776   ins_pipe(pipe_class_default);
8777 %}
8778 
8779 // Immediate Multiplication
8780 instruct mulL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
8781   match(Set dst (MulL src1 src2));
8782   ins_cost(DEFAULT_COST);
8783 
8784   format %{ "MULLI   $dst, $src1, $src2" %}
8785   size(4);
8786   ins_encode %{
8787     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
8788     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
8789   %}
8790   ins_pipe(pipe_class_default);
8791 %}
8792 
8793 // Integer Division with Immediate -1: Negate.
8794 instruct divI_reg_immIvalueMinus1(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
8795   match(Set dst (DivI src1 src2));
8796   ins_cost(DEFAULT_COST);
8797 
8798   format %{ "NEG     $dst, $src1 \t// /-1" %}
8799   size(4);
8800   ins_encode %{
8801     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
8802     __ neg($dst$$Register, $src1$$Register);
8803   %}
8804   ins_pipe(pipe_class_default);
8805 %}
8806 
8807 // Integer Division with constant, but not -1.
8808 // We should be able to improve this by checking the type of src2.
8809 // It might well be that src2 is known to be positive.
8810 instruct divI_reg_regnotMinus1(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8811   match(Set dst (DivI src1 src2));
8812   predicate(n-&gt;in(2)-&gt;find_int_con(-1) != -1); // src2 is a constant, but not -1
8813   ins_cost(2*DEFAULT_COST);
8814 
8815   format %{ "DIVW    $dst, $src1, $src2 \t// /not-1" %}
8816   size(4);
8817   ins_encode %{
8818     // TODO: PPC port $archOpcode(ppc64Opcode_divw);
8819     __ divw($dst$$Register, $src1$$Register, $src2$$Register);
8820   %}
8821   ins_pipe(pipe_class_default);
8822 %}
8823 
8824 instruct cmovI_bne_negI_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src1) %{
8825   effect(USE_DEF dst, USE src1, USE crx);
8826   predicate(false);
8827 
8828   ins_variable_size_depending_on_alignment(true);
8829 
8830   format %{ "CMOVE   $dst, neg($src1), $crx" %}
8831   // Worst case is branch + move + stop, no stop without scheduler.
8832   size(false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8);
8833   ins_encode %{
8834     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
8835     Label done;
8836     __ bne($crx$$CondRegister, done);
8837     __ neg($dst$$Register, $src1$$Register);
8838     // TODO PPC port __ endgroup_if_needed(_size == 12);
8839     __ bind(done);
8840   %}
8841   ins_pipe(pipe_class_default);
8842 %}
8843 
8844 // Integer Division with Registers not containing constants.
8845 instruct divI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8846   match(Set dst (DivI src1 src2));
8847   ins_cost(10*DEFAULT_COST);
8848 
8849   expand %{
8850     immI16 imm %{ (int)-1 %}
8851     flagsReg tmp1;
8852     cmpI_reg_imm16(tmp1, src2, imm);          // check src2 == -1
8853     divI_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
8854     cmovI_bne_negI_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
8855   %}
8856 %}
8857 
8858 // Long Division with Immediate -1: Negate.
8859 instruct divL_reg_immLvalueMinus1(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
8860   match(Set dst (DivL src1 src2));
8861   ins_cost(DEFAULT_COST);
8862 
8863   format %{ "NEG     $dst, $src1 \t// /-1, long" %}
8864   size(4);
8865   ins_encode %{
8866     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
8867     __ neg($dst$$Register, $src1$$Register);
8868   %}
8869   ins_pipe(pipe_class_default);
8870 %}
8871 
8872 // Long Division with constant, but not -1.
8873 instruct divL_reg_regnotMinus1(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8874   match(Set dst (DivL src1 src2));
8875   predicate(n-&gt;in(2)-&gt;find_long_con(-1L) != -1L); // Src2 is a constant, but not -1.
8876   ins_cost(2*DEFAULT_COST);
8877 
8878   format %{ "DIVD    $dst, $src1, $src2 \t// /not-1, long" %}
8879   size(4);
8880   ins_encode %{
8881     // TODO: PPC port $archOpcode(ppc64Opcode_divd);
8882     __ divd($dst$$Register, $src1$$Register, $src2$$Register);
8883   %}
8884   ins_pipe(pipe_class_default);
8885 %}
8886 
8887 instruct cmovL_bne_negL_reg(iRegLdst dst, flagsRegSrc crx, iRegLsrc src1) %{
8888   effect(USE_DEF dst, USE src1, USE crx);
8889   predicate(false);
8890 
8891   ins_variable_size_depending_on_alignment(true);
8892 
8893   format %{ "CMOVE   $dst, neg($src1), $crx" %}
8894   // Worst case is branch + move + stop, no stop without scheduler.
8895   size(false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8);
8896   ins_encode %{
8897     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
8898     Label done;
8899     __ bne($crx$$CondRegister, done);
8900     __ neg($dst$$Register, $src1$$Register);
8901     // TODO PPC port __ endgroup_if_needed(_size == 12);
8902     __ bind(done);
8903   %}
8904   ins_pipe(pipe_class_default);
8905 %}
8906 
8907 // Long Division with Registers not containing constants.
8908 instruct divL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8909   match(Set dst (DivL src1 src2));
8910   ins_cost(10*DEFAULT_COST);
8911 
8912   expand %{
8913     immL16 imm %{ (int)-1 %}
8914     flagsReg tmp1;
8915     cmpL_reg_imm16(tmp1, src2, imm);          // check src2 == -1
8916     divL_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
8917     cmovL_bne_negL_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
8918   %}
8919 %}
8920 
8921 // Integer Remainder with registers.
8922 instruct modI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8923   match(Set dst (ModI src1 src2));
8924   ins_cost(10*DEFAULT_COST);
8925 
8926   expand %{
8927     immI16 imm %{ (int)-1 %}
8928     flagsReg tmp1;
8929     iRegIdst tmp2;
8930     iRegIdst tmp3;
8931     cmpI_reg_imm16(tmp1, src2, imm);           // check src2 == -1
8932     divI_reg_regnotMinus1(tmp2, src1, src2);   // tmp2 = src1 / src2
8933     cmovI_bne_negI_reg(tmp2, tmp1, src1);      // cmove tmp2 = neg(src1) if src2 == -1
8934     mulI_reg_reg(tmp3, src2, tmp2);            // tmp3 = src2 * tmp2
8935     subI_reg_reg(dst, src1, tmp3);             // dst = src1 - tmp3
8936   %}
8937 %}
8938 
8939 // Long Remainder with registers
8940 instruct modL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8941   match(Set dst (ModL src1 src2));
8942   ins_cost(10*DEFAULT_COST);
8943 
8944   expand %{
8945     immL16 imm %{ (int)-1 %}
8946     flagsReg tmp1;
8947     iRegLdst tmp2;
8948     iRegLdst tmp3;
8949     cmpL_reg_imm16(tmp1, src2, imm);             // check src2 == -1
8950     divL_reg_regnotMinus1(tmp2, src1, src2);     // tmp2 = src1 / src2
8951     cmovL_bne_negL_reg(tmp2, tmp1, src1);        // cmove tmp2 = neg(src1) if src2 == -1
8952     mulL_reg_reg(tmp3, src2, tmp2);              // tmp3 = src2 * tmp2
8953     subL_reg_reg(dst, src1, tmp3);               // dst = src1 - tmp3
8954   %}
8955 %}
8956 
8957 // Integer Shift Instructions
8958 
8959 // Register Shift Left
8960 
8961 // Clear all but the lowest #mask bits.
8962 // Used to normalize shift amounts in registers.
8963 instruct maskI_reg_imm(iRegIdst dst, iRegIsrc src, uimmI6 mask) %{
8964   // no match-rule, false predicate
8965   effect(DEF dst, USE src, USE mask);
8966   predicate(false);
8967 
8968   format %{ "MASK    $dst, $src, $mask \t// clear $mask upper bits" %}
8969   size(4);
8970   ins_encode %{
8971     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
8972     __ clrldi($dst$$Register, $src$$Register, $mask$$constant);
8973   %}
8974   ins_pipe(pipe_class_default);
8975 %}
8976 
8977 instruct lShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8978   // no match-rule, false predicate
8979   effect(DEF dst, USE src1, USE src2);
8980   predicate(false);
8981 
8982   format %{ "SLW     $dst, $src1, $src2" %}
8983   size(4);
8984   ins_encode %{
8985     // TODO: PPC port $archOpcode(ppc64Opcode_slw);
8986     __ slw($dst$$Register, $src1$$Register, $src2$$Register);
8987   %}
8988   ins_pipe(pipe_class_default);
8989 %}
8990 
8991 instruct lShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8992   match(Set dst (LShiftI src1 src2));
8993   ins_cost(DEFAULT_COST*2);
8994   expand %{
8995     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
8996     iRegIdst tmpI;
8997     maskI_reg_imm(tmpI, src2, mask);
8998     lShiftI_reg_reg(dst, src1, tmpI);
8999   %}
9000 %}
9001 
9002 // Register Shift Left Immediate
9003 instruct lShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
9004   match(Set dst (LShiftI src1 src2));
9005 
9006   format %{ "SLWI    $dst, $src1, ($src2 &amp; 0x1f)" %}
9007   size(4);
9008   ins_encode %{
9009     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
9010     __ slwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
9011   %}
9012   ins_pipe(pipe_class_default);
9013 %}
9014 
9015 // AndI with negpow2-constant + LShiftI
9016 instruct lShiftI_andI_immInegpow2_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
9017   match(Set dst (LShiftI (AndI src1 src2) src3));
9018   predicate(UseRotateAndMaskInstructionsPPC64);
9019 
9020   format %{ "RLWINM  $dst, lShiftI(AndI($src1, $src2), $src3)" %}
9021   size(4);
9022   ins_encode %{
9023     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
9024     long src2      = $src2$$constant;
9025     long src3      = $src3$$constant;
9026     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
9027     if (maskbits &gt;= 32) {
9028       __ li($dst$$Register, 0); // addi
9029     } else {
9030       __ rlwinm($dst$$Register, $src1$$Register, src3 &amp; 0x1f, 0, (31-maskbits) &amp; 0x1f);
9031     }
9032   %}
9033   ins_pipe(pipe_class_default);
9034 %}
9035 
9036 // RShiftI + AndI with negpow2-constant + LShiftI
9037 instruct lShiftI_andI_immInegpow2_rShiftI_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
9038   match(Set dst (LShiftI (AndI (RShiftI src1 src3) src2) src3));
9039   predicate(UseRotateAndMaskInstructionsPPC64);
9040 
9041   format %{ "RLWINM  $dst, lShiftI(AndI(RShiftI($src1, $src3), $src2), $src3)" %}
9042   size(4);
9043   ins_encode %{
9044     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
9045     long src2      = $src2$$constant;
9046     long src3      = $src3$$constant;
9047     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
9048     if (maskbits &gt;= 32) {
9049       __ li($dst$$Register, 0); // addi
9050     } else {
9051       __ rlwinm($dst$$Register, $src1$$Register, 0, 0, (31-maskbits) &amp; 0x1f);
9052     }
9053   %}
9054   ins_pipe(pipe_class_default);
9055 %}
9056 
9057 instruct lShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9058   // no match-rule, false predicate
9059   effect(DEF dst, USE src1, USE src2);
9060   predicate(false);
9061 
9062   format %{ "SLD     $dst, $src1, $src2" %}
9063   size(4);
9064   ins_encode %{
9065     // TODO: PPC port $archOpcode(ppc64Opcode_sld);
9066     __ sld($dst$$Register, $src1$$Register, $src2$$Register);
9067   %}
9068   ins_pipe(pipe_class_default);
9069 %}
9070 
9071 // Register Shift Left
9072 instruct lShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9073   match(Set dst (LShiftL src1 src2));
9074   ins_cost(DEFAULT_COST*2);
9075   expand %{
9076     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
9077     iRegIdst tmpI;
9078     maskI_reg_imm(tmpI, src2, mask);
9079     lShiftL_regL_regI(dst, src1, tmpI);
9080   %}
9081 %}
9082 
9083 // Register Shift Left Immediate
9084 instruct lshiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
9085   match(Set dst (LShiftL src1 src2));
9086   format %{ "SLDI    $dst, $src1, ($src2 &amp; 0x3f)" %}
9087   size(4);
9088   ins_encode %{
9089     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
9090     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9091   %}
9092   ins_pipe(pipe_class_default);
9093 %}
9094 
9095 // If we shift more than 32 bits, we need not convert I2L.
9096 instruct lShiftL_regI_immGE32(iRegLdst dst, iRegIsrc src1, uimmI6_ge32 src2) %{
9097   match(Set dst (LShiftL (ConvI2L src1) src2));
9098   ins_cost(DEFAULT_COST);
9099 
9100   size(4);
9101   format %{ "SLDI    $dst, i2l($src1), $src2" %}
9102   ins_encode %{
9103     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
9104     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9105   %}
9106   ins_pipe(pipe_class_default);
9107 %}
9108 
9109 // Shift a postivie int to the left.
9110 // Clrlsldi clears the upper 32 bits and shifts.
9111 instruct scaledPositiveI2L_lShiftL_convI2L_reg_imm6(iRegLdst dst, iRegIsrc src1, uimmI6 src2) %{
9112   match(Set dst (LShiftL (ConvI2L src1) src2));
9113   predicate(((ConvI2LNode*)(_kids[0]-&gt;_leaf))-&gt;type()-&gt;is_long()-&gt;is_positive_int());
9114 
9115   format %{ "SLDI    $dst, i2l(positive_int($src1)), $src2" %}
9116   size(4);
9117   ins_encode %{
9118     // TODO: PPC port $archOpcode(ppc64Opcode_rldic);
9119     __ clrlsldi($dst$$Register, $src1$$Register, 0x20, $src2$$constant);
9120   %}
9121   ins_pipe(pipe_class_default);
9122 %}
9123 
9124 instruct arShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9125   // no match-rule, false predicate
9126   effect(DEF dst, USE src1, USE src2);
9127   predicate(false);
9128 
9129   format %{ "SRAW    $dst, $src1, $src2" %}
9130   size(4);
9131   ins_encode %{
9132     // TODO: PPC port $archOpcode(ppc64Opcode_sraw);
9133     __ sraw($dst$$Register, $src1$$Register, $src2$$Register);
9134   %}
9135   ins_pipe(pipe_class_default);
9136 %}
9137 
9138 // Register Arithmetic Shift Right
9139 instruct arShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9140   match(Set dst (RShiftI src1 src2));
9141   ins_cost(DEFAULT_COST*2);
9142   expand %{
9143     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
9144     iRegIdst tmpI;
9145     maskI_reg_imm(tmpI, src2, mask);
9146     arShiftI_reg_reg(dst, src1, tmpI);
9147   %}
9148 %}
9149 
9150 // Register Arithmetic Shift Right Immediate
9151 instruct arShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
9152   match(Set dst (RShiftI src1 src2));
9153 
9154   format %{ "SRAWI   $dst, $src1, ($src2 &amp; 0x1f)" %}
9155   size(4);
9156   ins_encode %{
9157     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
9158     __ srawi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
9159   %}
9160   ins_pipe(pipe_class_default);
9161 %}
9162 
9163 instruct arShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9164   // no match-rule, false predicate
9165   effect(DEF dst, USE src1, USE src2);
9166   predicate(false);
9167 
9168   format %{ "SRAD    $dst, $src1, $src2" %}
9169   size(4);
9170   ins_encode %{
9171     // TODO: PPC port $archOpcode(ppc64Opcode_srad);
9172     __ srad($dst$$Register, $src1$$Register, $src2$$Register);
9173   %}
9174   ins_pipe(pipe_class_default);
9175 %}
9176 
9177 // Register Shift Right Arithmetic Long
9178 instruct arShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9179   match(Set dst (RShiftL src1 src2));
9180   ins_cost(DEFAULT_COST*2);
9181 
9182   expand %{
9183     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
9184     iRegIdst tmpI;
9185     maskI_reg_imm(tmpI, src2, mask);
9186     arShiftL_regL_regI(dst, src1, tmpI);
9187   %}
9188 %}
9189 
9190 // Register Shift Right Immediate
9191 instruct arShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
9192   match(Set dst (RShiftL src1 src2));
9193 
9194   format %{ "SRADI   $dst, $src1, ($src2 &amp; 0x3f)" %}
9195   size(4);
9196   ins_encode %{
9197     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
9198     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9199   %}
9200   ins_pipe(pipe_class_default);
9201 %}
9202 
9203 // RShiftL + ConvL2I
9204 instruct convL2I_arShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
9205   match(Set dst (ConvL2I (RShiftL src1 src2)));
9206 
9207   format %{ "SRADI   $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i" %}
9208   size(4);
9209   ins_encode %{
9210     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
9211     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9212   %}
9213   ins_pipe(pipe_class_default);
9214 %}
9215 
9216 instruct urShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9217   // no match-rule, false predicate
9218   effect(DEF dst, USE src1, USE src2);
9219   predicate(false);
9220 
9221   format %{ "SRW     $dst, $src1, $src2" %}
9222   size(4);
9223   ins_encode %{
9224     // TODO: PPC port $archOpcode(ppc64Opcode_srw);
9225     __ srw($dst$$Register, $src1$$Register, $src2$$Register);
9226   %}
9227   ins_pipe(pipe_class_default);
9228 %}
9229 
9230 // Register Shift Right
9231 instruct urShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9232   match(Set dst (URShiftI src1 src2));
9233   ins_cost(DEFAULT_COST*2);
9234 
9235   expand %{
9236     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
9237     iRegIdst tmpI;
9238     maskI_reg_imm(tmpI, src2, mask);
9239     urShiftI_reg_reg(dst, src1, tmpI);
9240   %}
9241 %}
9242 
9243 // Register Shift Right Immediate
9244 instruct urShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
9245   match(Set dst (URShiftI src1 src2));
9246 
9247   format %{ "SRWI    $dst, $src1, ($src2 &amp; 0x1f)" %}
9248   size(4);
9249   ins_encode %{
9250     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
9251     __ srwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
9252   %}
9253   ins_pipe(pipe_class_default);
9254 %}
9255 
9256 instruct urShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9257   // no match-rule, false predicate
9258   effect(DEF dst, USE src1, USE src2);
9259   predicate(false);
9260 
9261   format %{ "SRD     $dst, $src1, $src2" %}
9262   size(4);
9263   ins_encode %{
9264     // TODO: PPC port $archOpcode(ppc64Opcode_srd);
9265     __ srd($dst$$Register, $src1$$Register, $src2$$Register);
9266   %}
9267   ins_pipe(pipe_class_default);
9268 %}
9269 
9270 // Register Shift Right
9271 instruct urShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9272   match(Set dst (URShiftL src1 src2));
9273   ins_cost(DEFAULT_COST*2);
9274 
9275   expand %{
9276     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
9277     iRegIdst tmpI;
9278     maskI_reg_imm(tmpI, src2, mask);
9279     urShiftL_regL_regI(dst, src1, tmpI);
9280   %}
9281 %}
9282 
9283 // Register Shift Right Immediate
9284 instruct urShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
9285   match(Set dst (URShiftL src1 src2));
9286 
9287   format %{ "SRDI    $dst, $src1, ($src2 &amp; 0x3f)" %}
9288   size(4);
9289   ins_encode %{
9290     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9291     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9292   %}
9293   ins_pipe(pipe_class_default);
9294 %}
9295 
9296 // URShiftL + ConvL2I.
9297 instruct convL2I_urShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
9298   match(Set dst (ConvL2I (URShiftL src1 src2)));
9299 
9300   format %{ "SRDI    $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i" %}
9301   size(4);
9302   ins_encode %{
9303     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9304     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9305   %}
9306   ins_pipe(pipe_class_default);
9307 %}
9308 
9309 // Register Shift Right Immediate with a CastP2X
9310 instruct shrP_convP2X_reg_imm6(iRegLdst dst, iRegP_N2P src1, uimmI6 src2) %{
9311   match(Set dst (URShiftL (CastP2X src1) src2));
9312 
9313   format %{ "SRDI    $dst, $src1, $src2 \t// Cast ptr $src1 to long and shift" %}
9314   size(4);
9315   ins_encode %{
9316     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9317     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9318   %}
9319   ins_pipe(pipe_class_default);
9320 %}
9321 
9322 instruct sxtI_reg(iRegIdst dst, iRegIsrc src) %{
9323   match(Set dst (ConvL2I (ConvI2L src)));
9324 
9325   format %{ "EXTSW   $dst, $src \t// int-&gt;int" %}
9326   size(4);
9327   ins_encode %{
9328     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
9329     __ extsw($dst$$Register, $src$$Register);
9330   %}
9331   ins_pipe(pipe_class_default);
9332 %}
9333 
9334 //----------Rotate Instructions------------------------------------------------
9335 
9336 // Rotate Left by 8-bit immediate
9337 instruct rotlI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 lshift, immI8 rshift) %{
9338   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
9339   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
9340 
9341   format %{ "ROTLWI  $dst, $src, $lshift" %}
9342   size(4);
9343   ins_encode %{
9344     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
9345     __ rotlwi($dst$$Register, $src$$Register, $lshift$$constant);
9346   %}
9347   ins_pipe(pipe_class_default);
9348 %}
9349 
9350 // Rotate Right by 8-bit immediate
9351 instruct rotrI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 rshift, immI8 lshift) %{
9352   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
9353   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
9354 
9355   format %{ "ROTRWI  $dst, $rshift" %}
9356   size(4);
9357   ins_encode %{
9358     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
9359     __ rotrwi($dst$$Register, $src$$Register, $rshift$$constant);
9360   %}
9361   ins_pipe(pipe_class_default);
9362 %}
9363 
9364 //----------Floating Point Arithmetic Instructions-----------------------------
9365 
9366 // Add float single precision
9367 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
9368   match(Set dst (AddF src1 src2));
9369 
9370   format %{ "FADDS   $dst, $src1, $src2" %}
9371   size(4);
9372   ins_encode %{
9373     // TODO: PPC port $archOpcode(ppc64Opcode_fadds);
9374     __ fadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9375   %}
9376   ins_pipe(pipe_class_default);
9377 %}
9378 
9379 // Add float double precision
9380 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
9381   match(Set dst (AddD src1 src2));
9382 
9383   format %{ "FADD    $dst, $src1, $src2" %}
9384   size(4);
9385   ins_encode %{
9386     // TODO: PPC port $archOpcode(ppc64Opcode_fadd);
9387     __ fadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9388   %}
9389   ins_pipe(pipe_class_default);
9390 %}
9391 
9392 // Sub float single precision
9393 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
9394   match(Set dst (SubF src1 src2));
9395 
9396   format %{ "FSUBS   $dst, $src1, $src2" %}
9397   size(4);
9398   ins_encode %{
9399     // TODO: PPC port $archOpcode(ppc64Opcode_fsubs);
9400     __ fsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9401   %}
9402   ins_pipe(pipe_class_default);
9403 %}
9404 
9405 // Sub float double precision
9406 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
9407   match(Set dst (SubD src1 src2));
9408   format %{ "FSUB    $dst, $src1, $src2" %}
9409   size(4);
9410   ins_encode %{
9411     // TODO: PPC port $archOpcode(ppc64Opcode_fsub);
9412     __ fsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9413   %}
9414   ins_pipe(pipe_class_default);
9415 %}
9416 
9417 // Mul float single precision
9418 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
9419   match(Set dst (MulF src1 src2));
9420   format %{ "FMULS   $dst, $src1, $src2" %}
9421   size(4);
9422   ins_encode %{
9423     // TODO: PPC port $archOpcode(ppc64Opcode_fmuls);
9424     __ fmuls($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9425   %}
9426   ins_pipe(pipe_class_default);
9427 %}
9428 
9429 // Mul float double precision
9430 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
9431   match(Set dst (MulD src1 src2));
9432   format %{ "FMUL    $dst, $src1, $src2" %}
9433   size(4);
9434   ins_encode %{
9435     // TODO: PPC port $archOpcode(ppc64Opcode_fmul);
9436     __ fmul($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9437   %}
9438   ins_pipe(pipe_class_default);
9439 %}
9440 
9441 // Div float single precision
9442 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
9443   match(Set dst (DivF src1 src2));
9444   format %{ "FDIVS   $dst, $src1, $src2" %}
9445   size(4);
9446   ins_encode %{
9447     // TODO: PPC port $archOpcode(ppc64Opcode_fdivs);
9448     __ fdivs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9449   %}
9450   ins_pipe(pipe_class_default);
9451 %}
9452 
9453 // Div float double precision
9454 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
9455   match(Set dst (DivD src1 src2));
9456   format %{ "FDIV    $dst, $src1, $src2" %}
9457   size(4);
9458   ins_encode %{
9459     // TODO: PPC port $archOpcode(ppc64Opcode_fdiv);
9460     __ fdiv($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9461   %}
9462   ins_pipe(pipe_class_default);
9463 %}
9464 
9465 // Absolute float single precision
9466 instruct absF_reg(regF dst, regF src) %{
9467   match(Set dst (AbsF src));
9468   format %{ "FABS    $dst, $src \t// float" %}
9469   size(4);
9470   ins_encode %{
9471     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
9472     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
9473   %}
9474   ins_pipe(pipe_class_default);
9475 %}
9476 
9477 // Absolute float double precision
9478 instruct absD_reg(regD dst, regD src) %{
9479   match(Set dst (AbsD src));
9480   format %{ "FABS    $dst, $src \t// double" %}
9481   size(4);
9482   ins_encode %{
9483     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
9484     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
9485   %}
9486   ins_pipe(pipe_class_default);
9487 %}
9488 
9489 instruct negF_reg(regF dst, regF src) %{
9490   match(Set dst (NegF src));
9491   format %{ "FNEG    $dst, $src \t// float" %}
9492   size(4);
9493   ins_encode %{
9494     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
9495     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
9496   %}
9497   ins_pipe(pipe_class_default);
9498 %}
9499 
9500 instruct negD_reg(regD dst, regD src) %{
9501   match(Set dst (NegD src));
9502   format %{ "FNEG    $dst, $src \t// double" %}
9503   size(4);
9504   ins_encode %{
9505     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
9506     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
9507   %}
9508   ins_pipe(pipe_class_default);
9509 %}
9510 
9511 // AbsF + NegF.
9512 instruct negF_absF_reg(regF dst, regF src) %{
9513   match(Set dst (NegF (AbsF src)));
9514   format %{ "FNABS   $dst, $src \t// float" %}
9515   size(4);
9516   ins_encode %{
9517     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
9518     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
9519   %}
9520   ins_pipe(pipe_class_default);
9521 %}
9522 
9523 // AbsD + NegD.
9524 instruct negD_absD_reg(regD dst, regD src) %{
9525   match(Set dst (NegD (AbsD src)));
9526   format %{ "FNABS   $dst, $src \t// double" %}
9527   size(4);
9528   ins_encode %{
9529     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
9530     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
9531   %}
9532   ins_pipe(pipe_class_default);
9533 %}
9534 
9535 // VM_Version::has_fsqrt() decides if this node will be used.
9536 // Sqrt float double precision
9537 instruct sqrtD_reg(regD dst, regD src) %{
9538   match(Set dst (SqrtD src));
9539   format %{ "FSQRT   $dst, $src" %}
9540   size(4);
9541   ins_encode %{
9542     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrt);
9543     __ fsqrt($dst$$FloatRegister, $src$$FloatRegister);
9544   %}
9545   ins_pipe(pipe_class_default);
9546 %}
9547 
9548 // Single-precision sqrt.
9549 instruct sqrtF_reg(regF dst, regF src) %{
9550   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
9551   predicate(VM_Version::has_fsqrts());
9552   ins_cost(DEFAULT_COST);
9553 
9554   format %{ "FSQRTS  $dst, $src" %}
9555   size(4);
9556   ins_encode %{
9557     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrts);
9558     __ fsqrts($dst$$FloatRegister, $src$$FloatRegister);
9559   %}
9560   ins_pipe(pipe_class_default);
9561 %}
9562 
9563 instruct roundDouble_nop(regD dst) %{
9564   match(Set dst (RoundDouble dst));
9565   ins_cost(0);
9566 
9567   format %{ " -- \t// RoundDouble not needed - empty" %}
9568   size(0);
9569   // PPC results are already "rounded" (i.e., normal-format IEEE).
9570   ins_encode( /*empty*/ );
9571   ins_pipe(pipe_class_default);
9572 %}
9573 
9574 instruct roundFloat_nop(regF dst) %{
9575   match(Set dst (RoundFloat dst));
9576   ins_cost(0);
9577 
9578   format %{ " -- \t// RoundFloat not needed - empty" %}
9579   size(0);
9580   // PPC results are already "rounded" (i.e., normal-format IEEE).
9581   ins_encode( /*empty*/ );
9582   ins_pipe(pipe_class_default);
9583 %}
9584 
9585 
9586 // Multiply-Accumulate
9587 // src1 * src2 + src3
9588 instruct maddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
9589   match(Set dst (FmaF src3 (Binary src1 src2)));
9590 
9591   format %{ "FMADDS  $dst, $src1, $src2, $src3" %}
9592   size(4);
9593   ins_encode %{
9594     // TODO: PPC port $archOpcode(ppc64Opcode_fmadds);
9595     __ fmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
9596   %}
9597   ins_pipe(pipe_class_default);
9598 %}
9599 
9600 // src1 * src2 + src3
9601 instruct maddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
9602   match(Set dst (FmaD src3 (Binary src1 src2)));
9603 
9604   format %{ "FMADD   $dst, $src1, $src2, $src3" %}
9605   size(4);
9606   ins_encode %{
9607     // TODO: PPC port $archOpcode(ppc64Opcode_fmadd);
9608     __ fmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
9609   %}
9610   ins_pipe(pipe_class_default);
9611 %}
9612 
9613 // -src1 * src2 + src3 = -(src1*src2-src3)
9614 instruct mnsubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
9615   match(Set dst (FmaF src3 (Binary (NegF src1) src2)));
9616   match(Set dst (FmaF src3 (Binary src1 (NegF src2))));
9617 
9618   format %{ "FNMSUBS $dst, $src1, $src2, $src3" %}
9619   size(4);
9620   ins_encode %{
9621     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsubs);
9622     __ fnmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
9623   %}
9624   ins_pipe(pipe_class_default);
9625 %}
9626 
9627 // -src1 * src2 + src3 = -(src1*src2-src3)
9628 instruct mnsubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
9629   match(Set dst (FmaD src3 (Binary (NegD src1) src2)));
9630   match(Set dst (FmaD src3 (Binary src1 (NegD src2))));
9631 
9632   format %{ "FNMSUB  $dst, $src1, $src2, $src3" %}
9633   size(4);
9634   ins_encode %{
9635     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsub);
9636     __ fnmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
9637   %}
9638   ins_pipe(pipe_class_default);
9639 %}
9640 
9641 // -src1 * src2 - src3 = -(src1*src2+src3)
9642 instruct mnaddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
9643   match(Set dst (FmaF (NegF src3) (Binary (NegF src1) src2)));
9644   match(Set dst (FmaF (NegF src3) (Binary src1 (NegF src2))));
9645 
9646   format %{ "FNMADDS $dst, $src1, $src2, $src3" %}
9647   size(4);
9648   ins_encode %{
9649     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadds);
9650     __ fnmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
9651   %}
9652   ins_pipe(pipe_class_default);
9653 %}
9654 
9655 // -src1 * src2 - src3 = -(src1*src2+src3)
9656 instruct mnaddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
9657   match(Set dst (FmaD (NegD src3) (Binary (NegD src1) src2)));
9658   match(Set dst (FmaD (NegD src3) (Binary src1 (NegD src2))));
9659 
9660   format %{ "FNMADD  $dst, $src1, $src2, $src3" %}
9661   size(4);
9662   ins_encode %{
9663     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadd);
9664     __ fnmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
9665   %}
9666   ins_pipe(pipe_class_default);
9667 %}
9668 
9669 // src1 * src2 - src3
9670 instruct msubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
9671   match(Set dst (FmaF (NegF src3) (Binary src1 src2)));
9672 
9673   format %{ "FMSUBS  $dst, $src1, $src2, $src3" %}
9674   size(4);
9675   ins_encode %{
9676     // TODO: PPC port $archOpcode(ppc64Opcode_fmsubs);
9677     __ fmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
9678   %}
9679   ins_pipe(pipe_class_default);
9680 %}
9681 
9682 // src1 * src2 - src3
9683 instruct msubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
9684   match(Set dst (FmaD (NegD src3) (Binary src1 src2)));
9685 
9686   format %{ "FMSUB   $dst, $src1, $src2, $src3" %}
9687   size(4);
9688   ins_encode %{
9689     // TODO: PPC port $archOpcode(ppc64Opcode_fmsub);
9690     __ fmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
9691   %}
9692   ins_pipe(pipe_class_default);
9693 %}
9694 
9695 
9696 //----------Logical Instructions-----------------------------------------------
9697 
9698 // And Instructions
9699 
9700 // Register And
9701 instruct andI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9702   match(Set dst (AndI src1 src2));
9703   format %{ "AND     $dst, $src1, $src2" %}
9704   size(4);
9705   ins_encode %{
9706     // TODO: PPC port $archOpcode(ppc64Opcode_and);
9707     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
9708   %}
9709   ins_pipe(pipe_class_default);
9710 %}
9711 
9712 // Left shifted Immediate And
9713 instruct andI_reg_immIhi16(iRegIdst dst, iRegIsrc src1, immIhi16  src2, flagsRegCR0 cr0) %{
9714   match(Set dst (AndI src1 src2));
9715   effect(KILL cr0);
9716   format %{ "ANDIS   $dst, $src1, $src2.hi" %}
9717   size(4);
9718   ins_encode %{
9719     // TODO: PPC port $archOpcode(ppc64Opcode_andis_);
9720     __ andis_($dst$$Register, $src1$$Register, (int)((unsigned short)(($src2$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
9721   %}
9722   ins_pipe(pipe_class_default);
9723 %}
9724 
9725 // Immediate And
9726 instruct andI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2, flagsRegCR0 cr0) %{
9727   match(Set dst (AndI src1 src2));
9728   effect(KILL cr0);
9729 
9730   format %{ "ANDI    $dst, $src1, $src2" %}
9731   size(4);
9732   ins_encode %{
9733     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
9734     // FIXME: avoid andi_ ?
9735     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
9736   %}
9737   ins_pipe(pipe_class_default);
9738 %}
9739 
9740 // Immediate And where the immediate is a negative power of 2.
9741 instruct andI_reg_immInegpow2(iRegIdst dst, iRegIsrc src1, immInegpow2 src2) %{
9742   match(Set dst (AndI src1 src2));
9743   format %{ "ANDWI   $dst, $src1, $src2" %}
9744   size(4);
9745   ins_encode %{
9746     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
9747     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)(julong)(juint)-($src2$$constant)));
9748   %}
9749   ins_pipe(pipe_class_default);
9750 %}
9751 
9752 instruct andI_reg_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immIpow2minus1 src2) %{
9753   match(Set dst (AndI src1 src2));
9754   format %{ "ANDWI   $dst, $src1, $src2" %}
9755   size(4);
9756   ins_encode %{
9757     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9758     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
9759   %}
9760   ins_pipe(pipe_class_default);
9761 %}
9762 
9763 instruct andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src1, immIpowerOf2 src2) %{
9764   match(Set dst (AndI src1 src2));
9765   predicate(UseRotateAndMaskInstructionsPPC64);
9766   format %{ "ANDWI   $dst, $src1, $src2" %}
9767   size(4);
9768   ins_encode %{
9769     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
9770     __ rlwinm($dst$$Register, $src1$$Register, 0,
9771               (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f, (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f);
9772   %}
9773   ins_pipe(pipe_class_default);
9774 %}
9775 
9776 // Register And Long
9777 instruct andL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
9778   match(Set dst (AndL src1 src2));
9779   ins_cost(DEFAULT_COST);
9780 
9781   format %{ "AND     $dst, $src1, $src2 \t// long" %}
9782   size(4);
9783   ins_encode %{
9784     // TODO: PPC port $archOpcode(ppc64Opcode_and);
9785     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
9786   %}
9787   ins_pipe(pipe_class_default);
9788 %}
9789 
9790 // Immediate And long
9791 instruct andL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2, flagsRegCR0 cr0) %{
9792   match(Set dst (AndL src1 src2));
9793   effect(KILL cr0);
9794 
9795   format %{ "ANDI    $dst, $src1, $src2 \t// long" %}
9796   size(4);
9797   ins_encode %{
9798     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
9799     // FIXME: avoid andi_ ?
9800     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
9801   %}
9802   ins_pipe(pipe_class_default);
9803 %}
9804 
9805 // Immediate And Long where the immediate is a negative power of 2.
9806 instruct andL_reg_immLnegpow2(iRegLdst dst, iRegLsrc src1, immLnegpow2 src2) %{
9807   match(Set dst (AndL src1 src2));
9808   format %{ "ANDDI   $dst, $src1, $src2" %}
9809   size(4);
9810   ins_encode %{
9811     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
9812     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)-$src2$$constant));
9813   %}
9814   ins_pipe(pipe_class_default);
9815 %}
9816 
9817 instruct andL_reg_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
9818   match(Set dst (AndL src1 src2));
9819   format %{ "ANDDI   $dst, $src1, $src2" %}
9820   size(4);
9821   ins_encode %{
9822     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9823     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
9824   %}
9825   ins_pipe(pipe_class_default);
9826 %}
9827 
9828 // AndL + ConvL2I.
9829 instruct convL2I_andL_reg_immLpow2minus1(iRegIdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
9830   match(Set dst (ConvL2I (AndL src1 src2)));
9831   ins_cost(DEFAULT_COST);
9832 
9833   format %{ "ANDDI   $dst, $src1, $src2 \t// long + l2i" %}
9834   size(4);
9835   ins_encode %{
9836     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9837     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
9838   %}
9839   ins_pipe(pipe_class_default);
9840 %}
9841 
9842 // Or Instructions
9843 
9844 // Register Or
9845 instruct orI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9846   match(Set dst (OrI src1 src2));
9847   format %{ "OR      $dst, $src1, $src2" %}
9848   size(4);
9849   ins_encode %{
9850     // TODO: PPC port $archOpcode(ppc64Opcode_or);
9851     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
9852   %}
9853   ins_pipe(pipe_class_default);
9854 %}
9855 
9856 // Expand does not work with above instruct. (??)
9857 instruct orI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9858   // no match-rule
9859   effect(DEF dst, USE src1, USE src2);
9860   format %{ "OR      $dst, $src1, $src2" %}
9861   size(4);
9862   ins_encode %{
9863     // TODO: PPC port $archOpcode(ppc64Opcode_or);
9864     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
9865   %}
9866   ins_pipe(pipe_class_default);
9867 %}
9868 
9869 instruct tree_orI_orI_orI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
9870   match(Set dst (OrI (OrI (OrI src1 src2) src3) src4));
9871   ins_cost(DEFAULT_COST*3);
9872 
9873   expand %{
9874     // FIXME: we should do this in the ideal world.
9875     iRegIdst tmp1;
9876     iRegIdst tmp2;
9877     orI_reg_reg(tmp1, src1, src2);
9878     orI_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
9879     orI_reg_reg(dst, tmp1, tmp2);
9880   %}
9881 %}
9882 
9883 // Immediate Or
9884 instruct orI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
9885   match(Set dst (OrI src1 src2));
9886   format %{ "ORI     $dst, $src1, $src2" %}
9887   size(4);
9888   ins_encode %{
9889     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
9890     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
9891   %}
9892   ins_pipe(pipe_class_default);
9893 %}
9894 
9895 // Register Or Long
9896 instruct orL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
9897   match(Set dst (OrL src1 src2));
9898   ins_cost(DEFAULT_COST);
9899 
9900   size(4);
9901   format %{ "OR      $dst, $src1, $src2 \t// long" %}
9902   ins_encode %{
9903     // TODO: PPC port $archOpcode(ppc64Opcode_or);
9904     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
9905   %}
9906   ins_pipe(pipe_class_default);
9907 %}
9908 
9909 // OrL + ConvL2I.
9910 instruct orI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
9911   match(Set dst (ConvL2I (OrL src1 src2)));
9912   ins_cost(DEFAULT_COST);
9913 
9914   format %{ "OR      $dst, $src1, $src2 \t// long + l2i" %}
9915   size(4);
9916   ins_encode %{
9917     // TODO: PPC port $archOpcode(ppc64Opcode_or);
9918     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
9919   %}
9920   ins_pipe(pipe_class_default);
9921 %}
9922 
9923 // Immediate Or long
9924 instruct orL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 con) %{
9925   match(Set dst (OrL src1 con));
9926   ins_cost(DEFAULT_COST);
9927 
9928   format %{ "ORI     $dst, $src1, $con \t// long" %}
9929   size(4);
9930   ins_encode %{
9931     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
9932     __ ori($dst$$Register, $src1$$Register, ($con$$constant) &amp; 0xFFFF);
9933   %}
9934   ins_pipe(pipe_class_default);
9935 %}
9936 
9937 // Xor Instructions
9938 
9939 // Register Xor
9940 instruct xorI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9941   match(Set dst (XorI src1 src2));
9942   format %{ "XOR     $dst, $src1, $src2" %}
9943   size(4);
9944   ins_encode %{
9945     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
9946     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
9947   %}
9948   ins_pipe(pipe_class_default);
9949 %}
9950 
9951 // Expand does not work with above instruct. (??)
9952 instruct xorI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9953   // no match-rule
9954   effect(DEF dst, USE src1, USE src2);
9955   format %{ "XOR     $dst, $src1, $src2" %}
9956   size(4);
9957   ins_encode %{
9958     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
9959     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
9960   %}
9961   ins_pipe(pipe_class_default);
9962 %}
9963 
9964 instruct tree_xorI_xorI_xorI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
9965   match(Set dst (XorI (XorI (XorI src1 src2) src3) src4));
9966   ins_cost(DEFAULT_COST*3);
9967 
9968   expand %{
9969     // FIXME: we should do this in the ideal world.
9970     iRegIdst tmp1;
9971     iRegIdst tmp2;
9972     xorI_reg_reg(tmp1, src1, src2);
9973     xorI_reg_reg_2(tmp2, src3, src4); // Adlc complains about xorI_reg_reg.
9974     xorI_reg_reg(dst, tmp1, tmp2);
9975   %}
9976 %}
9977 
9978 // Immediate Xor
9979 instruct xorI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
9980   match(Set dst (XorI src1 src2));
9981   format %{ "XORI    $dst, $src1, $src2" %}
9982   size(4);
9983   ins_encode %{
9984     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
9985     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
9986   %}
9987   ins_pipe(pipe_class_default);
9988 %}
9989 
9990 // Register Xor Long
9991 instruct xorL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
9992   match(Set dst (XorL src1 src2));
9993   ins_cost(DEFAULT_COST);
9994 
9995   format %{ "XOR     $dst, $src1, $src2 \t// long" %}
9996   size(4);
9997   ins_encode %{
9998     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
9999     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10000   %}
10001   ins_pipe(pipe_class_default);
10002 %}
10003 
10004 // XorL + ConvL2I.
10005 instruct xorI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10006   match(Set dst (ConvL2I (XorL src1 src2)));
10007   ins_cost(DEFAULT_COST);
10008 
10009   format %{ "XOR     $dst, $src1, $src2 \t// long + l2i" %}
10010   size(4);
10011   ins_encode %{
10012     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10013     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10014   %}
10015   ins_pipe(pipe_class_default);
10016 %}
10017 
10018 // Immediate Xor Long
10019 instruct xorL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2) %{
10020   match(Set dst (XorL src1 src2));
10021   ins_cost(DEFAULT_COST);
10022 
10023   format %{ "XORI    $dst, $src1, $src2 \t// long" %}
10024   size(4);
10025   ins_encode %{
10026     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10027     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10028   %}
10029   ins_pipe(pipe_class_default);
10030 %}
10031 
10032 instruct notI_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
10033   match(Set dst (XorI src1 src2));
10034   ins_cost(DEFAULT_COST);
10035 
10036   format %{ "NOT     $dst, $src1 ($src2)" %}
10037   size(4);
10038   ins_encode %{
10039     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10040     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10041   %}
10042   ins_pipe(pipe_class_default);
10043 %}
10044 
10045 instruct notL_reg(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
10046   match(Set dst (XorL src1 src2));
10047   ins_cost(DEFAULT_COST);
10048 
10049   format %{ "NOT     $dst, $src1 ($src2) \t// long" %}
10050   size(4);
10051   ins_encode %{
10052     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10053     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10054   %}
10055   ins_pipe(pipe_class_default);
10056 %}
10057 
10058 // And-complement
10059 instruct andcI_reg_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2, iRegIsrc src3) %{
10060   match(Set dst (AndI (XorI src1 src2) src3));
10061   ins_cost(DEFAULT_COST);
10062 
10063   format %{ "ANDW    $dst, xori($src1, $src2), $src3" %}
10064   size(4);
10065   ins_encode( enc_andc(dst, src3, src1) );
10066   ins_pipe(pipe_class_default);
10067 %}
10068 
10069 // And-complement
10070 instruct andcL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10071   // no match-rule, false predicate
10072   effect(DEF dst, USE src1, USE src2);
10073   predicate(false);
10074 
10075   format %{ "ANDC    $dst, $src1, $src2" %}
10076   size(4);
10077   ins_encode %{
10078     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
10079     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
10080   %}
10081   ins_pipe(pipe_class_default);
10082 %}
10083 
10084 //----------Moves between int/long and float/double----------------------------
10085 //
10086 // The following rules move values from int/long registers/stack-locations
10087 // to float/double registers/stack-locations and vice versa, without doing any
10088 // conversions. These rules are used to implement the bit-conversion methods
10089 // of java.lang.Float etc., e.g.
10090 //   int   floatToIntBits(float value)
10091 //   float intBitsToFloat(int bits)
10092 //
10093 // Notes on the implementation on ppc64:
10094 // We only provide rules which move between a register and a stack-location,
10095 // because we always have to go through memory when moving between a float
10096 // register and an integer register.
10097 
10098 //---------- Chain stack slots between similar types --------
10099 
10100 // These are needed so that the rules below can match.
10101 
10102 // Load integer from stack slot
10103 instruct stkI_to_regI(iRegIdst dst, stackSlotI src) %{
10104   match(Set dst src);
10105   ins_cost(MEMORY_REF_COST);
10106 
10107   format %{ "LWZ     $dst, $src" %}
10108   size(4);
10109   ins_encode( enc_lwz(dst, src) );
10110   ins_pipe(pipe_class_memory);
10111 %}
10112 
10113 // Store integer to stack slot
10114 instruct regI_to_stkI(stackSlotI dst, iRegIsrc src) %{
10115   match(Set dst src);
10116   ins_cost(MEMORY_REF_COST);
10117 
10118   format %{ "STW     $src, $dst \t// stk" %}
10119   size(4);
10120   ins_encode( enc_stw(src, dst) ); // rs=rt
10121   ins_pipe(pipe_class_memory);
10122 %}
10123 
10124 // Load long from stack slot
10125 instruct stkL_to_regL(iRegLdst dst, stackSlotL src) %{
10126   match(Set dst src);
10127   ins_cost(MEMORY_REF_COST);
10128 
10129   format %{ "LD      $dst, $src \t// long" %}
10130   size(4);
10131   ins_encode( enc_ld(dst, src) );
10132   ins_pipe(pipe_class_memory);
10133 %}
10134 
10135 // Store long to stack slot
10136 instruct regL_to_stkL(stackSlotL dst, iRegLsrc src) %{
10137   match(Set dst src);
10138   ins_cost(MEMORY_REF_COST);
10139 
10140   format %{ "STD     $src, $dst \t// long" %}
10141   size(4);
10142   ins_encode( enc_std(src, dst) ); // rs=rt
10143   ins_pipe(pipe_class_memory);
10144 %}
10145 
10146 //----------Moves between int and float
10147 
10148 // Move float value from float stack-location to integer register.
10149 instruct moveF2I_stack_reg(iRegIdst dst, stackSlotF src) %{
10150   match(Set dst (MoveF2I src));
10151   ins_cost(MEMORY_REF_COST);
10152 
10153   format %{ "LWZ     $dst, $src \t// MoveF2I" %}
10154   size(4);
10155   ins_encode( enc_lwz(dst, src) );
10156   ins_pipe(pipe_class_memory);
10157 %}
10158 
10159 // Move float value from float register to integer stack-location.
10160 instruct moveF2I_reg_stack(stackSlotI dst, regF src) %{
10161   match(Set dst (MoveF2I src));
10162   ins_cost(MEMORY_REF_COST);
10163 
10164   format %{ "STFS    $src, $dst \t// MoveF2I" %}
10165   size(4);
10166   ins_encode( enc_stfs(src, dst) );
10167   ins_pipe(pipe_class_memory);
10168 %}
10169 
10170 // Move integer value from integer stack-location to float register.
10171 instruct moveI2F_stack_reg(regF dst, stackSlotI src) %{
10172   match(Set dst (MoveI2F src));
10173   ins_cost(MEMORY_REF_COST);
10174 
10175   format %{ "LFS     $dst, $src \t// MoveI2F" %}
10176   size(4);
10177   ins_encode %{
10178     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
10179     int Idisp = $src$$disp + frame_slots_bias($src$$base, ra_);
10180     __ lfs($dst$$FloatRegister, Idisp, $src$$base$$Register);
10181   %}
10182   ins_pipe(pipe_class_memory);
10183 %}
10184 
10185 // Move integer value from integer register to float stack-location.
10186 instruct moveI2F_reg_stack(stackSlotF dst, iRegIsrc src) %{
10187   match(Set dst (MoveI2F src));
10188   ins_cost(MEMORY_REF_COST);
10189 
10190   format %{ "STW     $src, $dst \t// MoveI2F" %}
10191   size(4);
10192   ins_encode( enc_stw(src, dst) );
10193   ins_pipe(pipe_class_memory);
10194 %}
10195 
10196 //----------Moves between long and float
10197 
10198 instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{
10199   // no match-rule, false predicate
10200   effect(DEF dst, USE src);
10201   predicate(false);
10202 
10203   format %{ "storeD  $src, $dst \t// STACK" %}
10204   size(4);
10205   ins_encode( enc_stfd(src, dst) );
10206   ins_pipe(pipe_class_default);
10207 %}
10208 
10209 //----------Moves between long and double
10210 
10211 // Move double value from double stack-location to long register.
10212 instruct moveD2L_stack_reg(iRegLdst dst, stackSlotD src) %{
10213   match(Set dst (MoveD2L src));
10214   ins_cost(MEMORY_REF_COST);
10215   size(4);
10216   format %{ "LD      $dst, $src \t// MoveD2L" %}
10217   ins_encode( enc_ld(dst, src) );
10218   ins_pipe(pipe_class_memory);
10219 %}
10220 
10221 // Move double value from double register to long stack-location.
10222 instruct moveD2L_reg_stack(stackSlotL dst, regD src) %{
10223   match(Set dst (MoveD2L src));
10224   effect(DEF dst, USE src);
10225   ins_cost(MEMORY_REF_COST);
10226 
10227   format %{ "STFD    $src, $dst \t// MoveD2L" %}
10228   size(4);
10229   ins_encode( enc_stfd(src, dst) );
10230   ins_pipe(pipe_class_memory);
10231 %}
10232 
10233 // Move long value from long stack-location to double register.
10234 instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{
10235   match(Set dst (MoveL2D src));
10236   ins_cost(MEMORY_REF_COST);
10237 
10238   format %{ "LFD     $dst, $src \t// MoveL2D" %}
10239   size(4);
10240   ins_encode( enc_lfd(dst, src) );
10241   ins_pipe(pipe_class_memory);
10242 %}
10243 
10244 // Move long value from long register to double stack-location.
10245 instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{
10246   match(Set dst (MoveL2D src));
10247   ins_cost(MEMORY_REF_COST);
10248 
10249   format %{ "STD     $src, $dst \t// MoveL2D" %}
10250   size(4);
10251   ins_encode( enc_std(src, dst) );
10252   ins_pipe(pipe_class_memory);
10253 %}
10254 
10255 //----------Register Move Instructions-----------------------------------------
10256 
10257 // Replicate for Superword
10258 
10259 instruct moveReg(iRegLdst dst, iRegIsrc src) %{
10260   predicate(false);
10261   effect(DEF dst, USE src);
10262 
10263   format %{ "MR      $dst, $src \t// replicate " %}
10264   // variable size, 0 or 4.
10265   ins_encode %{
10266     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10267     __ mr_if_needed($dst$$Register, $src$$Register);
10268   %}
10269   ins_pipe(pipe_class_default);
10270 %}
10271 
10272 //----------Cast instructions (Java-level type cast)---------------------------
10273 
10274 // Cast Long to Pointer for unsafe natives.
10275 instruct castX2P(iRegPdst dst, iRegLsrc src) %{
10276   match(Set dst (CastX2P src));
10277 
10278   format %{ "MR      $dst, $src \t// Long-&gt;Ptr" %}
10279   // variable size, 0 or 4.
10280   ins_encode %{
10281     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10282     __ mr_if_needed($dst$$Register, $src$$Register);
10283   %}
10284  ins_pipe(pipe_class_default);
10285 %}
10286 
10287 // Cast Pointer to Long for unsafe natives.
10288 instruct castP2X(iRegLdst dst, iRegP_N2P src) %{
10289   match(Set dst (CastP2X src));
10290 
10291   format %{ "MR      $dst, $src \t// Ptr-&gt;Long" %}
10292   // variable size, 0 or 4.
10293   ins_encode %{
10294     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10295     __ mr_if_needed($dst$$Register, $src$$Register);
10296   %}
10297   ins_pipe(pipe_class_default);
10298 %}
10299 
10300 instruct castPP(iRegPdst dst) %{
10301   match(Set dst (CastPP dst));
10302   format %{ " -- \t// castPP of $dst" %}
10303   size(0);
10304   ins_encode( /*empty*/ );
10305   ins_pipe(pipe_class_default);
10306 %}
10307 
10308 instruct castII(iRegIdst dst) %{
10309   match(Set dst (CastII dst));
10310   format %{ " -- \t// castII of $dst" %}
10311   size(0);
10312   ins_encode( /*empty*/ );
10313   ins_pipe(pipe_class_default);
10314 %}
10315 
10316 instruct checkCastPP(iRegPdst dst) %{
10317   match(Set dst (CheckCastPP dst));
10318   format %{ " -- \t// checkcastPP of $dst" %}
10319   size(0);
10320   ins_encode( /*empty*/ );
10321   ins_pipe(pipe_class_default);
10322 %}
10323 
10324 //----------Convert instructions-----------------------------------------------
10325 
10326 // Convert to boolean.
10327 
10328 // int_to_bool(src) : { 1   if src != 0
10329 //                    { 0   else
10330 //
10331 // strategy:
10332 // 1) Count leading zeros of 32 bit-value src,
10333 //    this returns 32 (0b10.0000) iff src == 0 and &lt;32 otherwise.
10334 // 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10335 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10336 
10337 // convI2Bool
10338 instruct convI2Bool_reg__cntlz_Ex(iRegIdst dst, iRegIsrc src) %{
10339   match(Set dst (Conv2B src));
10340   predicate(UseCountLeadingZerosInstructionsPPC64);
10341   ins_cost(DEFAULT_COST);
10342 
10343   expand %{
10344     immI shiftAmount %{ 0x5 %}
10345     uimmI16 mask %{ 0x1 %}
10346     iRegIdst tmp1;
10347     iRegIdst tmp2;
10348     countLeadingZerosI(tmp1, src);
10349     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
10350     xorI_reg_uimm16(dst, tmp2, mask);
10351   %}
10352 %}
10353 
10354 instruct convI2Bool_reg__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx) %{
10355   match(Set dst (Conv2B src));
10356   effect(TEMP crx);
10357   predicate(!UseCountLeadingZerosInstructionsPPC64);
10358   ins_cost(DEFAULT_COST);
10359 
10360   format %{ "CMPWI   $crx, $src, #0 \t// convI2B"
10361             "LI      $dst, #0\n\t"
10362             "BEQ     $crx, done\n\t"
10363             "LI      $dst, #1\n"
10364             "done:" %}
10365   size(16);
10366   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x0, 0x1) );
10367   ins_pipe(pipe_class_compare);
10368 %}
10369 
10370 // ConvI2B + XorI
10371 instruct xorI_convI2Bool_reg_immIvalue1__cntlz_Ex(iRegIdst dst, iRegIsrc src, immI_1 mask) %{
10372   match(Set dst (XorI (Conv2B src) mask));
10373   predicate(UseCountLeadingZerosInstructionsPPC64);
10374   ins_cost(DEFAULT_COST);
10375 
10376   expand %{
10377     immI shiftAmount %{ 0x5 %}
10378     iRegIdst tmp1;
10379     countLeadingZerosI(tmp1, src);
10380     urShiftI_reg_imm(dst, tmp1, shiftAmount);
10381   %}
10382 %}
10383 
10384 instruct xorI_convI2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI_1 mask) %{
10385   match(Set dst (XorI (Conv2B src) mask));
10386   effect(TEMP crx);
10387   predicate(!UseCountLeadingZerosInstructionsPPC64);
10388   ins_cost(DEFAULT_COST);
10389 
10390   format %{ "CMPWI   $crx, $src, #0 \t// Xor(convI2B($src), $mask)"
10391             "LI      $dst, #1\n\t"
10392             "BEQ     $crx, done\n\t"
10393             "LI      $dst, #0\n"
10394             "done:" %}
10395   size(16);
10396   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x1, 0x0) );
10397   ins_pipe(pipe_class_compare);
10398 %}
10399 
10400 // AndI 0b0..010..0 + ConvI2B
10401 instruct convI2Bool_andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src, immIpowerOf2 mask) %{
10402   match(Set dst (Conv2B (AndI src mask)));
10403   predicate(UseRotateAndMaskInstructionsPPC64);
10404   ins_cost(DEFAULT_COST);
10405 
10406   format %{ "RLWINM  $dst, $src, $mask \t// convI2B(AndI($src, $mask))" %}
10407   size(4);
10408   ins_encode %{
10409     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10410     __ rlwinm($dst$$Register, $src$$Register, (32-log2_long((jlong)$mask$$constant)) &amp; 0x1f, 31, 31);
10411   %}
10412   ins_pipe(pipe_class_default);
10413 %}
10414 
10415 // Convert pointer to boolean.
10416 //
10417 // ptr_to_bool(src) : { 1   if src != 0
10418 //                    { 0   else
10419 //
10420 // strategy:
10421 // 1) Count leading zeros of 64 bit-value src,
10422 //    this returns 64 (0b100.0000) iff src == 0 and &lt;64 otherwise.
10423 // 2) Shift 6 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10424 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10425 
10426 // ConvP2B
10427 instruct convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src) %{
10428   match(Set dst (Conv2B src));
10429   predicate(UseCountLeadingZerosInstructionsPPC64);
10430   ins_cost(DEFAULT_COST);
10431 
10432   expand %{
10433     immI shiftAmount %{ 0x6 %}
10434     uimmI16 mask %{ 0x1 %}
10435     iRegIdst tmp1;
10436     iRegIdst tmp2;
10437     countLeadingZerosP(tmp1, src);
10438     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
10439     xorI_reg_uimm16(dst, tmp2, mask);
10440   %}
10441 %}
10442 
10443 instruct convP2Bool_reg__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx) %{
10444   match(Set dst (Conv2B src));
10445   effect(TEMP crx);
10446   predicate(!UseCountLeadingZerosInstructionsPPC64);
10447   ins_cost(DEFAULT_COST);
10448 
10449   format %{ "CMPDI   $crx, $src, #0 \t// convP2B"
10450             "LI      $dst, #0\n\t"
10451             "BEQ     $crx, done\n\t"
10452             "LI      $dst, #1\n"
10453             "done:" %}
10454   size(16);
10455   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x0, 0x1) );
10456   ins_pipe(pipe_class_compare);
10457 %}
10458 
10459 // ConvP2B + XorI
10460 instruct xorI_convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src, immI_1 mask) %{
10461   match(Set dst (XorI (Conv2B src) mask));
10462   predicate(UseCountLeadingZerosInstructionsPPC64);
10463   ins_cost(DEFAULT_COST);
10464 
10465   expand %{
10466     immI shiftAmount %{ 0x6 %}
10467     iRegIdst tmp1;
10468     countLeadingZerosP(tmp1, src);
10469     urShiftI_reg_imm(dst, tmp1, shiftAmount);
10470   %}
10471 %}
10472 
10473 instruct xorI_convP2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx, immI_1 mask) %{
10474   match(Set dst (XorI (Conv2B src) mask));
10475   effect(TEMP crx);
10476   predicate(!UseCountLeadingZerosInstructionsPPC64);
10477   ins_cost(DEFAULT_COST);
10478 
10479   format %{ "CMPDI   $crx, $src, #0 \t// XorI(convP2B($src), $mask)"
10480             "LI      $dst, #1\n\t"
10481             "BEQ     $crx, done\n\t"
10482             "LI      $dst, #0\n"
10483             "done:" %}
10484   size(16);
10485   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x1, 0x0) );
10486   ins_pipe(pipe_class_compare);
10487 %}
10488 
10489 // if src1 &lt; src2, return -1 else return 0
10490 instruct cmpLTMask_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10491   match(Set dst (CmpLTMask src1 src2));
10492   ins_cost(DEFAULT_COST*4);
10493 
10494   expand %{
10495     iRegLdst src1s;
10496     iRegLdst src2s;
10497     iRegLdst diff;
10498     convI2L_reg(src1s, src1); // Ensure proper sign extension.
10499     convI2L_reg(src2s, src2); // Ensure proper sign extension.
10500     subL_reg_reg(diff, src1s, src2s);
10501     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
10502     signmask64I_regL(dst, diff);
10503   %}
10504 %}
10505 
10506 instruct cmpLTMask_reg_immI0(iRegIdst dst, iRegIsrc src1, immI_0 src2) %{
10507   match(Set dst (CmpLTMask src1 src2)); // if src1 &lt; src2, return -1 else return 0
10508   format %{ "SRAWI   $dst, $src1, $src2 \t// CmpLTMask" %}
10509   size(4);
10510   ins_encode %{
10511     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
10512     __ srawi($dst$$Register, $src1$$Register, 0x1f);
10513   %}
10514   ins_pipe(pipe_class_default);
10515 %}
10516 
10517 //----------Arithmetic Conversion Instructions---------------------------------
10518 
10519 // Convert to Byte  -- nop
10520 // Convert to Short -- nop
10521 
10522 // Convert to Int
10523 
10524 instruct convB2I_reg(iRegIdst dst, iRegIsrc src, immI_24 amount) %{
10525   match(Set dst (RShiftI (LShiftI src amount) amount));
10526   format %{ "EXTSB   $dst, $src \t// byte-&gt;int" %}
10527   size(4);
10528   ins_encode %{
10529     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
10530     __ extsb($dst$$Register, $src$$Register);
10531   %}
10532   ins_pipe(pipe_class_default);
10533 %}
10534 
10535 // LShiftI 16 + RShiftI 16 converts short to int.
10536 instruct convS2I_reg(iRegIdst dst, iRegIsrc src, immI_16 amount) %{
10537   match(Set dst (RShiftI (LShiftI src amount) amount));
10538   format %{ "EXTSH   $dst, $src \t// short-&gt;int" %}
10539   size(4);
10540   ins_encode %{
10541     // TODO: PPC port $archOpcode(ppc64Opcode_extsh);
10542     __ extsh($dst$$Register, $src$$Register);
10543   %}
10544   ins_pipe(pipe_class_default);
10545 %}
10546 
10547 // ConvL2I + ConvI2L: Sign extend int in long register.
10548 instruct sxtI_L2L_reg(iRegLdst dst, iRegLsrc src) %{
10549   match(Set dst (ConvI2L (ConvL2I src)));
10550 
10551   format %{ "EXTSW   $dst, $src \t// long-&gt;long" %}
10552   size(4);
10553   ins_encode %{
10554     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
10555     __ extsw($dst$$Register, $src$$Register);
10556   %}
10557   ins_pipe(pipe_class_default);
10558 %}
10559 
10560 instruct convL2I_reg(iRegIdst dst, iRegLsrc src) %{
10561   match(Set dst (ConvL2I src));
10562   format %{ "MR      $dst, $src \t// long-&gt;int" %}
10563   // variable size, 0 or 4
10564   ins_encode %{
10565     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10566     __ mr_if_needed($dst$$Register, $src$$Register);
10567   %}
10568   ins_pipe(pipe_class_default);
10569 %}
10570 
10571 instruct convD2IRaw_regD(regD dst, regD src) %{
10572   // no match-rule, false predicate
10573   effect(DEF dst, USE src);
10574   predicate(false);
10575 
10576   format %{ "FCTIWZ $dst, $src \t// convD2I, $src != NaN" %}
10577   size(4);
10578   ins_encode %{
10579     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);;
10580     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
10581   %}
10582   ins_pipe(pipe_class_default);
10583 %}
10584 
10585 instruct cmovI_bso_stackSlotL(iRegIdst dst, flagsRegSrc crx, stackSlotL src) %{
10586   // no match-rule, false predicate
10587   effect(DEF dst, USE crx, USE src);
10588   predicate(false);
10589 
10590   ins_variable_size_depending_on_alignment(true);
10591 
10592   format %{ "cmovI   $crx, $dst, $src" %}
10593   // Worst case is branch + move + stop, no stop without scheduler.
10594   size(false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8);
10595   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
10596   ins_pipe(pipe_class_default);
10597 %}
10598 
10599 instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{
10600   // no match-rule, false predicate
10601   effect(DEF dst, USE crx, USE mem);
10602   predicate(false);
10603 
10604   format %{ "CmovI   $dst, $crx, $mem \t// postalloc expanded" %}
10605   postalloc_expand %{
10606     //
10607     // replaces
10608     //
10609     //   region  dst  crx  mem
10610     //    \       |    |   /
10611     //     dst=cmovI_bso_stackSlotL_conLvalue0
10612     //
10613     // with
10614     //
10615     //   region  dst
10616     //    \       /
10617     //     dst=loadConI16(0)
10618     //      |
10619     //      ^  region  dst  crx  mem
10620     //      |   \       |    |    /
10621     //      dst=cmovI_bso_stackSlotL
10622     //
10623 
10624     // Create new nodes.
10625     MachNode *m1 = new loadConI16Node();
10626     MachNode *m2 = new cmovI_bso_stackSlotLNode();
10627 
10628     // inputs for new nodes
10629     m1-&gt;add_req(n_region);
10630     m2-&gt;add_req(n_region, n_crx, n_mem);
10631 
10632     // precedences for new nodes
10633     m2-&gt;add_prec(m1);
10634 
10635     // operands for new nodes
10636     m1-&gt;_opnds[0] = op_dst;
10637     m1-&gt;_opnds[1] = new immI16Oper(0);
10638 
10639     m2-&gt;_opnds[0] = op_dst;
10640     m2-&gt;_opnds[1] = op_crx;
10641     m2-&gt;_opnds[2] = op_mem;
10642 
10643     // registers for new nodes
10644     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
10645     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
10646 
10647     // Insert new nodes.
10648     nodes-&gt;push(m1);
10649     nodes-&gt;push(m2);
10650   %}
10651 %}
10652 
10653 // Double to Int conversion, NaN is mapped to 0.
10654 instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{
10655   match(Set dst (ConvD2I src));
10656   ins_cost(DEFAULT_COST);
10657 
10658   expand %{
10659     regD tmpD;
10660     stackSlotL tmpS;
10661     flagsReg crx;
10662     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
10663     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
10664     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
10665     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
10666   %}
10667 %}
10668 
10669 instruct convF2IRaw_regF(regF dst, regF src) %{
10670   // no match-rule, false predicate
10671   effect(DEF dst, USE src);
10672   predicate(false);
10673 
10674   format %{ "FCTIWZ $dst, $src \t// convF2I, $src != NaN" %}
10675   size(4);
10676   ins_encode %{
10677     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
10678     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
10679   %}
10680   ins_pipe(pipe_class_default);
10681 %}
10682 
10683 // Float to Int conversion, NaN is mapped to 0.
10684 instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{
10685   match(Set dst (ConvF2I src));
10686   ins_cost(DEFAULT_COST);
10687 
10688   expand %{
10689     regF tmpF;
10690     stackSlotL tmpS;
10691     flagsReg crx;
10692     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
10693     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
10694     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
10695     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
10696   %}
10697 %}
10698 
10699 // Convert to Long
10700 
10701 instruct convI2L_reg(iRegLdst dst, iRegIsrc src) %{
10702   match(Set dst (ConvI2L src));
10703   format %{ "EXTSW   $dst, $src \t// int-&gt;long" %}
10704   size(4);
10705   ins_encode %{
10706     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
10707     __ extsw($dst$$Register, $src$$Register);
10708   %}
10709   ins_pipe(pipe_class_default);
10710 %}
10711 
10712 // Zero-extend: convert unsigned int to long (convUI2L).
10713 instruct zeroExtendL_regI(iRegLdst dst, iRegIsrc src, immL_32bits mask) %{
10714   match(Set dst (AndL (ConvI2L src) mask));
10715   ins_cost(DEFAULT_COST);
10716 
10717   format %{ "CLRLDI  $dst, $src, #32 \t// zero-extend int to long" %}
10718   size(4);
10719   ins_encode %{
10720     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10721     __ clrldi($dst$$Register, $src$$Register, 32);
10722   %}
10723   ins_pipe(pipe_class_default);
10724 %}
10725 
10726 // Zero-extend: convert unsigned int to long in long register.
10727 instruct zeroExtendL_regL(iRegLdst dst, iRegLsrc src, immL_32bits mask) %{
10728   match(Set dst (AndL src mask));
10729   ins_cost(DEFAULT_COST);
10730 
10731   format %{ "CLRLDI  $dst, $src, #32 \t// zero-extend int to long" %}
10732   size(4);
10733   ins_encode %{
10734     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10735     __ clrldi($dst$$Register, $src$$Register, 32);
10736   %}
10737   ins_pipe(pipe_class_default);
10738 %}
10739 
10740 instruct convF2LRaw_regF(regF dst, regF src) %{
10741   // no match-rule, false predicate
10742   effect(DEF dst, USE src);
10743   predicate(false);
10744 
10745   format %{ "FCTIDZ $dst, $src \t// convF2L, $src != NaN" %}
10746   size(4);
10747   ins_encode %{
10748     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
10749     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
10750   %}
10751   ins_pipe(pipe_class_default);
10752 %}
10753 
10754 instruct cmovL_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL src) %{
10755   // no match-rule, false predicate
10756   effect(DEF dst, USE crx, USE src);
10757   predicate(false);
10758 
10759   ins_variable_size_depending_on_alignment(true);
10760 
10761   format %{ "cmovL   $crx, $dst, $src" %}
10762   // Worst case is branch + move + stop, no stop without scheduler.
10763   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
10764   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
10765   ins_pipe(pipe_class_default);
10766 %}
10767 
10768 instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{
10769   // no match-rule, false predicate
10770   effect(DEF dst, USE crx, USE mem);
10771   predicate(false);
10772 
10773   format %{ "CmovL   $dst, $crx, $mem \t// postalloc expanded" %}
10774   postalloc_expand %{
10775     //
10776     // replaces
10777     //
10778     //   region  dst  crx  mem
10779     //    \       |    |   /
10780     //     dst=cmovL_bso_stackSlotL_conLvalue0
10781     //
10782     // with
10783     //
10784     //   region  dst
10785     //    \       /
10786     //     dst=loadConL16(0)
10787     //      |
10788     //      ^  region  dst  crx  mem
10789     //      |   \       |    |    /
10790     //      dst=cmovL_bso_stackSlotL
10791     //
10792 
10793     // Create new nodes.
10794     MachNode *m1 = new loadConL16Node();
10795     MachNode *m2 = new cmovL_bso_stackSlotLNode();
10796 
10797     // inputs for new nodes
10798     m1-&gt;add_req(n_region);
10799     m2-&gt;add_req(n_region, n_crx, n_mem);
10800     m2-&gt;add_prec(m1);
10801 
10802     // operands for new nodes
10803     m1-&gt;_opnds[0] = op_dst;
10804     m1-&gt;_opnds[1] = new immL16Oper(0);
10805     m2-&gt;_opnds[0] = op_dst;
10806     m2-&gt;_opnds[1] = op_crx;
10807     m2-&gt;_opnds[2] = op_mem;
10808 
10809     // registers for new nodes
10810     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
10811     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
10812 
10813     // Insert new nodes.
10814     nodes-&gt;push(m1);
10815     nodes-&gt;push(m2);
10816   %}
10817 %}
10818 
10819 // Float to Long conversion, NaN is mapped to 0.
10820 instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{
10821   match(Set dst (ConvF2L src));
10822   ins_cost(DEFAULT_COST);
10823 
10824   expand %{
10825     regF tmpF;
10826     stackSlotL tmpS;
10827     flagsReg crx;
10828     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
10829     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
10830     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
10831     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
10832   %}
10833 %}
10834 
10835 instruct convD2LRaw_regD(regD dst, regD src) %{
10836   // no match-rule, false predicate
10837   effect(DEF dst, USE src);
10838   predicate(false);
10839 
10840   format %{ "FCTIDZ $dst, $src \t// convD2L $src != NaN" %}
10841   size(4);
10842   ins_encode %{
10843     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
10844     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
10845   %}
10846   ins_pipe(pipe_class_default);
10847 %}
10848 
10849 // Double to Long conversion, NaN is mapped to 0.
10850 instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{
10851   match(Set dst (ConvD2L src));
10852   ins_cost(DEFAULT_COST);
10853 
10854   expand %{
10855     regD tmpD;
10856     stackSlotL tmpS;
10857     flagsReg crx;
10858     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
10859     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
10860     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
10861     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
10862   %}
10863 %}
10864 
10865 // Convert to Float
10866 
10867 // Placed here as needed in expand.
10868 instruct convL2DRaw_regD(regD dst, regD src) %{
10869   // no match-rule, false predicate
10870   effect(DEF dst, USE src);
10871   predicate(false);
10872 
10873   format %{ "FCFID $dst, $src \t// convL2D" %}
10874   size(4);
10875   ins_encode %{
10876     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
10877     __ fcfid($dst$$FloatRegister, $src$$FloatRegister);
10878   %}
10879   ins_pipe(pipe_class_default);
10880 %}
10881 
10882 // Placed here as needed in expand.
10883 instruct convD2F_reg(regF dst, regD src) %{
10884   match(Set dst (ConvD2F src));
10885   format %{ "FRSP    $dst, $src \t// convD2F" %}
10886   size(4);
10887   ins_encode %{
10888     // TODO: PPC port $archOpcode(ppc64Opcode_frsp);
10889     __ frsp($dst$$FloatRegister, $src$$FloatRegister);
10890   %}
10891   ins_pipe(pipe_class_default);
10892 %}
10893 
10894 // Integer to Float conversion.
10895 instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{
10896   match(Set dst (ConvI2F src));
10897   predicate(!VM_Version::has_fcfids());
10898   ins_cost(DEFAULT_COST);
10899 
10900   expand %{
10901     iRegLdst tmpL;
10902     stackSlotL tmpS;
10903     regD tmpD;
10904     regD tmpD2;
10905     convI2L_reg(tmpL, src);              // Sign-extension int to long.
10906     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
10907     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
10908     convL2DRaw_regD(tmpD2, tmpD);        // Convert to double.
10909     convD2F_reg(dst, tmpD2);             // Convert double to float.
10910   %}
10911 %}
10912 
10913 instruct convL2FRaw_regF(regF dst, regD src) %{
10914   // no match-rule, false predicate
10915   effect(DEF dst, USE src);
10916   predicate(false);
10917 
10918   format %{ "FCFIDS $dst, $src \t// convL2F" %}
10919   size(4);
10920   ins_encode %{
10921     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
10922     __ fcfids($dst$$FloatRegister, $src$$FloatRegister);
10923   %}
10924   ins_pipe(pipe_class_default);
10925 %}
10926 
10927 // Integer to Float conversion. Special version for Power7.
10928 instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{
10929   match(Set dst (ConvI2F src));
10930   predicate(VM_Version::has_fcfids());
10931   ins_cost(DEFAULT_COST);
10932 
10933   expand %{
10934     iRegLdst tmpL;
10935     stackSlotL tmpS;
10936     regD tmpD;
10937     convI2L_reg(tmpL, src);              // Sign-extension int to long.
10938     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
10939     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
10940     convL2FRaw_regF(dst, tmpD);          // Convert to float.
10941   %}
10942 %}
10943 
10944 // L2F to avoid runtime call.
10945 instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{
10946   match(Set dst (ConvL2F src));
10947   predicate(VM_Version::has_fcfids());
10948   ins_cost(DEFAULT_COST);
10949 
10950   expand %{
10951     stackSlotL tmpS;
10952     regD tmpD;
10953     regL_to_stkL(tmpS, src);             // Store long to stack.
10954     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
10955     convL2FRaw_regF(dst, tmpD);          // Convert to float.
10956   %}
10957 %}
10958 
10959 // Moved up as used in expand.
10960 //instruct convD2F_reg(regF dst, regD src) %{%}
10961 
10962 // Convert to Double
10963 
10964 // Integer to Double conversion.
10965 instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{
10966   match(Set dst (ConvI2D src));
10967   ins_cost(DEFAULT_COST);
10968 
10969   expand %{
10970     iRegLdst tmpL;
10971     stackSlotL tmpS;
10972     regD tmpD;
10973     convI2L_reg(tmpL, src);              // Sign-extension int to long.
10974     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
10975     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
10976     convL2DRaw_regD(dst, tmpD);          // Convert to double.
10977   %}
10978 %}
10979 
10980 // Long to Double conversion
10981 instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{
10982   match(Set dst (ConvL2D src));
10983   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
10984 
10985   expand %{
10986     regD tmpD;
10987     moveL2D_stack_reg(tmpD, src);
10988     convL2DRaw_regD(dst, tmpD);
10989   %}
10990 %}
10991 
10992 instruct convF2D_reg(regD dst, regF src) %{
10993   match(Set dst (ConvF2D src));
10994   format %{ "FMR     $dst, $src \t// float-&gt;double" %}
10995   // variable size, 0 or 4
10996   ins_encode %{
10997     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
10998     __ fmr_if_needed($dst$$FloatRegister, $src$$FloatRegister);
10999   %}
11000   ins_pipe(pipe_class_default);
11001 %}
11002 
11003 //----------Control Flow Instructions------------------------------------------
11004 // Compare Instructions
11005 
11006 // Compare Integers
11007 instruct cmpI_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
11008   match(Set crx (CmpI src1 src2));
11009   size(4);
11010   format %{ "CMPW    $crx, $src1, $src2" %}
11011   ins_encode %{
11012     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11013     __ cmpw($crx$$CondRegister, $src1$$Register, $src2$$Register);
11014   %}
11015   ins_pipe(pipe_class_compare);
11016 %}
11017 
11018 instruct cmpI_reg_imm16(flagsReg crx, iRegIsrc src1, immI16 src2) %{
11019   match(Set crx (CmpI src1 src2));
11020   format %{ "CMPWI   $crx, $src1, $src2" %}
11021   size(4);
11022   ins_encode %{
11023     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11024     __ cmpwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11025   %}
11026   ins_pipe(pipe_class_compare);
11027 %}
11028 
11029 // (src1 &amp; src2) == 0?
11030 instruct testI_reg_imm(flagsRegCR0 cr0, iRegIsrc src1, uimmI16 src2, immI_0 zero) %{
11031   match(Set cr0 (CmpI (AndI src1 src2) zero));
11032   // r0 is killed
11033   format %{ "ANDI    R0, $src1, $src2 \t// BTST int" %}
11034   size(4);
11035   ins_encode %{
11036     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11037     __ andi_(R0, $src1$$Register, $src2$$constant);
11038   %}
11039   ins_pipe(pipe_class_compare);
11040 %}
11041 
11042 instruct cmpL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11043   match(Set crx (CmpL src1 src2));
11044   format %{ "CMPD    $crx, $src1, $src2" %}
11045   size(4);
11046   ins_encode %{
11047     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11048     __ cmpd($crx$$CondRegister, $src1$$Register, $src2$$Register);
11049   %}
11050   ins_pipe(pipe_class_compare);
11051 %}
11052 
11053 instruct cmpL_reg_imm16(flagsReg crx, iRegLsrc src1, immL16 src2) %{
11054   match(Set crx (CmpL src1 src2));
11055   format %{ "CMPDI   $crx, $src1, $src2" %}
11056   size(4);
11057   ins_encode %{
11058     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11059     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11060   %}
11061   ins_pipe(pipe_class_compare);
11062 %}
11063 
11064 instruct testL_reg_reg(flagsRegCR0 cr0, iRegLsrc src1, iRegLsrc src2, immL_0 zero) %{
11065   match(Set cr0 (CmpL (AndL src1 src2) zero));
11066   // r0 is killed
11067   format %{ "AND     R0, $src1, $src2 \t// BTST long" %}
11068   size(4);
11069   ins_encode %{
11070     // TODO: PPC port $archOpcode(ppc64Opcode_and_);
11071     __ and_(R0, $src1$$Register, $src2$$Register);
11072   %}
11073   ins_pipe(pipe_class_compare);
11074 %}
11075 
11076 instruct testL_reg_imm(flagsRegCR0 cr0, iRegLsrc src1, uimmL16 src2, immL_0 zero) %{
11077   match(Set cr0 (CmpL (AndL src1 src2) zero));
11078   // r0 is killed
11079   format %{ "ANDI    R0, $src1, $src2 \t// BTST long" %}
11080   size(4);
11081   ins_encode %{
11082     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11083     __ andi_(R0, $src1$$Register, $src2$$constant);
11084   %}
11085   ins_pipe(pipe_class_compare);
11086 %}
11087 
11088 instruct cmovI_conIvalueMinus1_conIvalue1(iRegIdst dst, flagsRegSrc crx) %{
11089   // no match-rule, false predicate
11090   effect(DEF dst, USE crx);
11091   predicate(false);
11092 
11093   ins_variable_size_depending_on_alignment(true);
11094 
11095   format %{ "cmovI   $crx, $dst, -1, 0, +1" %}
11096   // Worst case is branch + move + branch + move + stop, no stop without scheduler.
11097   size(false /* TODO: PPC PORTInsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 20 : 16);
11098   ins_encode %{
11099     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
11100     Label done;
11101     // li(Rdst, 0);              // equal -&gt; 0
11102     __ beq($crx$$CondRegister, done);
11103     __ li($dst$$Register, 1);    // greater -&gt; +1
11104     __ bgt($crx$$CondRegister, done);
11105     __ li($dst$$Register, -1);   // unordered or less -&gt; -1
11106     // TODO: PPC port__ endgroup_if_needed(_size == 20);
11107     __ bind(done);
11108   %}
11109   ins_pipe(pipe_class_compare);
11110 %}
11111 
11112 instruct cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(iRegIdst dst, flagsRegSrc crx) %{
11113   // no match-rule, false predicate
11114   effect(DEF dst, USE crx);
11115   predicate(false);
11116 
11117   format %{ "CmovI    $crx, $dst, -1, 0, +1 \t// postalloc expanded" %}
11118   postalloc_expand %{
11119     //
11120     // replaces
11121     //
11122     //   region  crx
11123     //    \       |
11124     //     dst=cmovI_conIvalueMinus1_conIvalue0_conIvalue1
11125     //
11126     // with
11127     //
11128     //   region
11129     //    \
11130     //     dst=loadConI16(0)
11131     //      |
11132     //      ^  region  crx
11133     //      |   \       |
11134     //      dst=cmovI_conIvalueMinus1_conIvalue1
11135     //
11136 
11137     // Create new nodes.
11138     MachNode *m1 = new loadConI16Node();
11139     MachNode *m2 = new cmovI_conIvalueMinus1_conIvalue1Node();
11140 
11141     // inputs for new nodes
11142     m1-&gt;add_req(n_region);
11143     m2-&gt;add_req(n_region, n_crx);
11144     m2-&gt;add_prec(m1);
11145 
11146     // operands for new nodes
11147     m1-&gt;_opnds[0] = op_dst;
11148     m1-&gt;_opnds[1] = new immI16Oper(0);
11149     m2-&gt;_opnds[0] = op_dst;
11150     m2-&gt;_opnds[1] = op_crx;
11151 
11152     // registers for new nodes
11153     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11154     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11155 
11156     // Insert new nodes.
11157     nodes-&gt;push(m1);
11158     nodes-&gt;push(m2);
11159   %}
11160 %}
11161 
11162 // Manifest a CmpL3 result in an integer register. Very painful.
11163 // This is the test to avoid.
11164 // (src1 &lt; src2) ? -1 : ((src1 &gt; src2) ? 1 : 0)
11165 instruct cmpL3_reg_reg_ExEx(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
11166   match(Set dst (CmpL3 src1 src2));
11167   ins_cost(DEFAULT_COST*5+BRANCH_COST);
11168 
11169   expand %{
11170     flagsReg tmp1;
11171     cmpL_reg_reg(tmp1, src1, src2);
11172     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
11173   %}
11174 %}
11175 
11176 // Implicit range checks.
11177 // A range check in the ideal world has one of the following shapes:
11178 //  - (If le (CmpU length index)), (IfTrue  throw exception)
11179 //  - (If lt (CmpU index length)), (IfFalse throw exception)
11180 //
11181 // Match range check 'If le (CmpU length index)'.
11182 instruct rangeCheck_iReg_uimm15(cmpOp cmp, iRegIsrc src_length, uimmI15 index, label labl) %{
11183   match(If cmp (CmpU src_length index));
11184   effect(USE labl);
11185   predicate(TrapBasedRangeChecks &amp;&amp;
11186             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
11187             PROB_UNLIKELY(_leaf-&gt;as_If()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
11188             (Matcher::branches_to_uncommon_trap(_leaf)));
11189 
11190   ins_is_TrapBasedCheckNode(true);
11191 
11192   format %{ "TWI     $index $cmp $src_length \t// RangeCheck =&gt; trap $labl" %}
11193   size(4);
11194   ins_encode %{
11195     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
11196     if ($cmp$$cmpcode == 0x1 /* less_equal */) {
11197       __ trap_range_check_le($src_length$$Register, $index$$constant);
11198     } else {
11199       // Both successors are uncommon traps, probability is 0.
11200       // Node got flipped during fixup flow.
11201       assert($cmp$$cmpcode == 0x9, "must be greater");
11202       __ trap_range_check_g($src_length$$Register, $index$$constant);
11203     }
11204   %}
11205   ins_pipe(pipe_class_trap);
11206 %}
11207 
11208 // Match range check 'If lt (CmpU index length)'.
11209 instruct rangeCheck_iReg_iReg(cmpOp cmp, iRegIsrc src_index, iRegIsrc src_length, label labl) %{
11210   match(If cmp (CmpU src_index src_length));
11211   effect(USE labl);
11212   predicate(TrapBasedRangeChecks &amp;&amp;
11213             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
11214             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
11215             (Matcher::branches_to_uncommon_trap(_leaf)));
11216 
11217   ins_is_TrapBasedCheckNode(true);
11218 
11219   format %{ "TW      $src_index $cmp $src_length \t// RangeCheck =&gt; trap $labl" %}
11220   size(4);
11221   ins_encode %{
11222     // TODO: PPC port $archOpcode(ppc64Opcode_tw);
11223     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
11224       __ trap_range_check_ge($src_index$$Register, $src_length$$Register);
11225     } else {
11226       // Both successors are uncommon traps, probability is 0.
11227       // Node got flipped during fixup flow.
11228       assert($cmp$$cmpcode == 0x8, "must be less");
11229       __ trap_range_check_l($src_index$$Register, $src_length$$Register);
11230     }
11231   %}
11232   ins_pipe(pipe_class_trap);
11233 %}
11234 
11235 // Match range check 'If lt (CmpU index length)'.
11236 instruct rangeCheck_uimm15_iReg(cmpOp cmp, iRegIsrc src_index, uimmI15 length, label labl) %{
11237   match(If cmp (CmpU src_index length));
11238   effect(USE labl);
11239   predicate(TrapBasedRangeChecks &amp;&amp;
11240             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
11241             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
11242             (Matcher::branches_to_uncommon_trap(_leaf)));
11243 
11244   ins_is_TrapBasedCheckNode(true);
11245 
11246   format %{ "TWI     $src_index $cmp $length \t// RangeCheck =&gt; trap $labl" %}
11247   size(4);
11248   ins_encode %{
11249     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
11250     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
11251       __ trap_range_check_ge($src_index$$Register, $length$$constant);
11252     } else {
11253       // Both successors are uncommon traps, probability is 0.
11254       // Node got flipped during fixup flow.
11255       assert($cmp$$cmpcode == 0x8, "must be less");
11256       __ trap_range_check_l($src_index$$Register, $length$$constant);
11257     }
11258   %}
11259   ins_pipe(pipe_class_trap);
11260 %}
11261 
11262 instruct compU_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
11263   match(Set crx (CmpU src1 src2));
11264   format %{ "CMPLW   $crx, $src1, $src2 \t// unsigned" %}
11265   size(4);
11266   ins_encode %{
11267     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11268     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
11269   %}
11270   ins_pipe(pipe_class_compare);
11271 %}
11272 
11273 instruct compU_reg_uimm16(flagsReg crx, iRegIsrc src1, uimmI16 src2) %{
11274   match(Set crx (CmpU src1 src2));
11275   size(4);
11276   format %{ "CMPLWI  $crx, $src1, $src2" %}
11277   ins_encode %{
11278     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
11279     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11280   %}
11281   ins_pipe(pipe_class_compare);
11282 %}
11283 
11284 // Implicit zero checks (more implicit null checks).
11285 // No constant pool entries required.
11286 instruct zeroCheckN_iReg_imm0(cmpOp cmp, iRegNsrc value, immN_0 zero, label labl) %{
11287   match(If cmp (CmpN value zero));
11288   effect(USE labl);
11289   predicate(TrapBasedNullChecks &amp;&amp;
11290             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
11291             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
11292             Matcher::branches_to_uncommon_trap(_leaf));
11293   ins_cost(1);
11294 
11295   ins_is_TrapBasedCheckNode(true);
11296 
11297   format %{ "TDI     $value $cmp $zero \t// ZeroCheckN =&gt; trap $labl" %}
11298   size(4);
11299   ins_encode %{
11300     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
11301     if ($cmp$$cmpcode == 0xA) {
11302       __ trap_null_check($value$$Register);
11303     } else {
11304       // Both successors are uncommon traps, probability is 0.
11305       // Node got flipped during fixup flow.
11306       assert($cmp$$cmpcode == 0x2 , "must be equal(0xA) or notEqual(0x2)");
11307       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
11308     }
11309   %}
11310   ins_pipe(pipe_class_trap);
11311 %}
11312 
11313 // Compare narrow oops.
11314 instruct cmpN_reg_reg(flagsReg crx, iRegNsrc src1, iRegNsrc src2) %{
11315   match(Set crx (CmpN src1 src2));
11316 
11317   size(4);
11318   ins_cost(2);
11319   format %{ "CMPLW   $crx, $src1, $src2 \t// compressed ptr" %}
11320   ins_encode %{
11321     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11322     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
11323   %}
11324   ins_pipe(pipe_class_compare);
11325 %}
11326 
11327 instruct cmpN_reg_imm0(flagsReg crx, iRegNsrc src1, immN_0 src2) %{
11328   match(Set crx (CmpN src1 src2));
11329   // Make this more expensive than zeroCheckN_iReg_imm0.
11330   ins_cost(2);
11331 
11332   format %{ "CMPLWI  $crx, $src1, $src2 \t// compressed ptr" %}
11333   size(4);
11334   ins_encode %{
11335     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
11336     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11337   %}
11338   ins_pipe(pipe_class_compare);
11339 %}
11340 
11341 // Implicit zero checks (more implicit null checks).
11342 // No constant pool entries required.
11343 instruct zeroCheckP_reg_imm0(cmpOp cmp, iRegP_N2P value, immP_0 zero, label labl) %{
11344   match(If cmp (CmpP value zero));
11345   effect(USE labl);
11346   predicate(TrapBasedNullChecks &amp;&amp;
11347             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
11348             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
11349             Matcher::branches_to_uncommon_trap(_leaf));
11350   ins_cost(1); // Should not be cheaper than zeroCheckN.
11351 
11352   ins_is_TrapBasedCheckNode(true);
11353 
11354   format %{ "TDI     $value $cmp $zero \t// ZeroCheckP =&gt; trap $labl" %}
11355   size(4);
11356   ins_encode %{
11357     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
11358     if ($cmp$$cmpcode == 0xA) {
11359       __ trap_null_check($value$$Register);
11360     } else {
11361       // Both successors are uncommon traps, probability is 0.
11362       // Node got flipped during fixup flow.
11363       assert($cmp$$cmpcode == 0x2 , "must be equal(0xA) or notEqual(0x2)");
11364       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
11365     }
11366   %}
11367   ins_pipe(pipe_class_trap);
11368 %}
11369 
11370 // Compare Pointers
11371 instruct cmpP_reg_reg(flagsReg crx, iRegP_N2P src1, iRegP_N2P src2) %{
11372   match(Set crx (CmpP src1 src2));
11373   format %{ "CMPLD   $crx, $src1, $src2 \t// ptr" %}
11374   size(4);
11375   ins_encode %{
11376     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11377     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
11378   %}
11379   ins_pipe(pipe_class_compare);
11380 %}
11381 
11382 instruct cmpP_reg_null(flagsReg crx, iRegP_N2P src1, immP_0or1 src2) %{
11383   match(Set crx (CmpP src1 src2));
11384   format %{ "CMPLDI   $crx, $src1, $src2 \t// ptr" %}
11385   size(4);
11386   ins_encode %{
11387     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11388     __ cmpldi($crx$$CondRegister, $src1$$Register, (int)((short)($src2$$constant &amp; 0xFFFF)));
11389   %}
11390   ins_pipe(pipe_class_compare);
11391 %}
11392 
11393 // Used in postalloc expand.
11394 instruct cmpP_reg_imm16(flagsReg crx, iRegPsrc src1, immL16 src2) %{
11395   // This match rule prevents reordering of node before a safepoint.
11396   // This only makes sense if this instructions is used exclusively
11397   // for the expansion of EncodeP!
11398   match(Set crx (CmpP src1 src2));
11399   predicate(false);
11400 
11401   format %{ "CMPDI   $crx, $src1, $src2" %}
11402   size(4);
11403   ins_encode %{
11404     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11405     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11406   %}
11407   ins_pipe(pipe_class_compare);
11408 %}
11409 
11410 //----------Float Compares----------------------------------------------------
11411 
11412 instruct cmpFUnordered_reg_reg(flagsReg crx, regF src1, regF src2) %{
11413   // Needs matchrule, see cmpDUnordered.
11414   match(Set crx (CmpF src1 src2));
11415   // no match-rule, false predicate
11416   predicate(false);
11417 
11418   format %{ "cmpFUrd $crx, $src1, $src2" %}
11419   size(4);
11420   ins_encode %{
11421     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
11422     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
11423   %}
11424   ins_pipe(pipe_class_default);
11425 %}
11426 
11427 instruct cmov_bns_less(flagsReg crx) %{
11428   // no match-rule, false predicate
11429   effect(DEF crx);
11430   predicate(false);
11431 
11432   ins_variable_size_depending_on_alignment(true);
11433 
11434   format %{ "cmov    $crx" %}
11435   // Worst case is branch + move + stop, no stop without scheduler.
11436   size(false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 16 : 12);
11437   ins_encode %{
11438     // TODO: PPC port $archOpcode(ppc64Opcode_cmovecr);
11439     Label done;
11440     __ bns($crx$$CondRegister, done);        // not unordered -&gt; keep crx
11441     __ li(R0, 0);
11442     __ cmpwi($crx$$CondRegister, R0, 1);     // unordered -&gt; set crx to 'less'
11443     // TODO PPC port __ endgroup_if_needed(_size == 16);
11444     __ bind(done);
11445   %}
11446   ins_pipe(pipe_class_default);
11447 %}
11448 
11449 // Compare floating, generate condition code.
11450 instruct cmpF_reg_reg_Ex(flagsReg crx, regF src1, regF src2) %{
11451   // FIXME: should we match 'If cmp (CmpF src1 src2))' ??
11452   //
11453   // The following code sequence occurs a lot in mpegaudio:
11454   //
11455   // block BXX:
11456   // 0: instruct cmpFUnordered_reg_reg (cmpF_reg_reg-0):
11457   //    cmpFUrd CCR6, F11, F9
11458   // 4: instruct cmov_bns_less (cmpF_reg_reg-1):
11459   //    cmov CCR6
11460   // 8: instruct branchConSched:
11461   //    B_FARle CCR6, B56  P=0.500000 C=-1.000000
11462   match(Set crx (CmpF src1 src2));
11463   ins_cost(DEFAULT_COST+BRANCH_COST);
11464 
11465   format %{ "CmpF    $crx, $src1, $src2 \t// postalloc expanded" %}
11466   postalloc_expand %{
11467     //
11468     // replaces
11469     //
11470     //   region  src1  src2
11471     //    \       |     |
11472     //     crx=cmpF_reg_reg
11473     //
11474     // with
11475     //
11476     //   region  src1  src2
11477     //    \       |     |
11478     //     crx=cmpFUnordered_reg_reg
11479     //      |
11480     //      ^  region
11481     //      |   \
11482     //      crx=cmov_bns_less
11483     //
11484 
11485     // Create new nodes.
11486     MachNode *m1 = new cmpFUnordered_reg_regNode();
11487     MachNode *m2 = new cmov_bns_lessNode();
11488 
11489     // inputs for new nodes
11490     m1-&gt;add_req(n_region, n_src1, n_src2);
11491     m2-&gt;add_req(n_region);
11492     m2-&gt;add_prec(m1);
11493 
11494     // operands for new nodes
11495     m1-&gt;_opnds[0] = op_crx;
11496     m1-&gt;_opnds[1] = op_src1;
11497     m1-&gt;_opnds[2] = op_src2;
11498     m2-&gt;_opnds[0] = op_crx;
11499 
11500     // registers for new nodes
11501     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
11502     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
11503 
11504     // Insert new nodes.
11505     nodes-&gt;push(m1);
11506     nodes-&gt;push(m2);
11507   %}
11508 %}
11509 
11510 // Compare float, generate -1,0,1
11511 instruct cmpF3_reg_reg_ExEx(iRegIdst dst, regF src1, regF src2) %{
11512   match(Set dst (CmpF3 src1 src2));
11513   ins_cost(DEFAULT_COST*5+BRANCH_COST);
11514 
11515   expand %{
11516     flagsReg tmp1;
11517     cmpFUnordered_reg_reg(tmp1, src1, src2);
11518     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
11519   %}
11520 %}
11521 
11522 instruct cmpDUnordered_reg_reg(flagsReg crx, regD src1, regD src2) %{
11523   // Needs matchrule so that ideal opcode is Cmp. This causes that gcm places the
11524   // node right before the conditional move using it.
11525   // In jck test api/java_awt/geom/QuadCurve2DFloat/index.html#SetCurveTesttestCase7,
11526   // compilation of java.awt.geom.RectangularShape::getBounds()Ljava/awt/Rectangle
11527   // crashed in register allocation where the flags Reg between cmpDUnoredered and a
11528   // conditional move was supposed to be spilled.
11529   match(Set crx (CmpD src1 src2));
11530   // False predicate, shall not be matched.
11531   predicate(false);
11532 
11533   format %{ "cmpFUrd $crx, $src1, $src2" %}
11534   size(4);
11535   ins_encode %{
11536     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
11537     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
11538   %}
11539   ins_pipe(pipe_class_default);
11540 %}
11541 
11542 instruct cmpD_reg_reg_Ex(flagsReg crx, regD src1, regD src2) %{
11543   match(Set crx (CmpD src1 src2));
11544   ins_cost(DEFAULT_COST+BRANCH_COST);
11545 
11546   format %{ "CmpD    $crx, $src1, $src2 \t// postalloc expanded" %}
11547   postalloc_expand %{
11548     //
11549     // replaces
11550     //
11551     //   region  src1  src2
11552     //    \       |     |
11553     //     crx=cmpD_reg_reg
11554     //
11555     // with
11556     //
11557     //   region  src1  src2
11558     //    \       |     |
11559     //     crx=cmpDUnordered_reg_reg
11560     //      |
11561     //      ^  region
11562     //      |   \
11563     //      crx=cmov_bns_less
11564     //
11565 
11566     // create new nodes
11567     MachNode *m1 = new cmpDUnordered_reg_regNode();
11568     MachNode *m2 = new cmov_bns_lessNode();
11569 
11570     // inputs for new nodes
11571     m1-&gt;add_req(n_region, n_src1, n_src2);
11572     m2-&gt;add_req(n_region);
11573     m2-&gt;add_prec(m1);
11574 
11575     // operands for new nodes
11576     m1-&gt;_opnds[0] = op_crx;
11577     m1-&gt;_opnds[1] = op_src1;
11578     m1-&gt;_opnds[2] = op_src2;
11579     m2-&gt;_opnds[0] = op_crx;
11580 
11581     // registers for new nodes
11582     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
11583     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
11584 
11585     // Insert new nodes.
11586     nodes-&gt;push(m1);
11587     nodes-&gt;push(m2);
11588   %}
11589 %}
11590 
11591 // Compare double, generate -1,0,1
11592 instruct cmpD3_reg_reg_ExEx(iRegIdst dst, regD src1, regD src2) %{
11593   match(Set dst (CmpD3 src1 src2));
11594   ins_cost(DEFAULT_COST*5+BRANCH_COST);
11595 
11596   expand %{
11597     flagsReg tmp1;
11598     cmpDUnordered_reg_reg(tmp1, src1, src2);
11599     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
11600   %}
11601 %}
11602 
11603 //----------Branches---------------------------------------------------------
11604 // Jump
11605 
11606 // Direct Branch.
11607 instruct branch(label labl) %{
11608   match(Goto);
11609   effect(USE labl);
11610   ins_cost(BRANCH_COST);
11611 
11612   format %{ "B       $labl" %}
11613   size(4);
11614   ins_encode %{
11615     // TODO: PPC port $archOpcode(ppc64Opcode_b);
11616      Label d;    // dummy
11617      __ bind(d);
11618      Label* p = $labl$$label;
11619      // `p' is `NULL' when this encoding class is used only to
11620      // determine the size of the encoded instruction.
11621      Label&amp; l = (NULL == p)? d : *(p);
11622      __ b(l);
11623   %}
11624   ins_pipe(pipe_class_default);
11625 %}
11626 
11627 // Conditional Near Branch
11628 instruct branchCon(cmpOp cmp, flagsRegSrc crx, label lbl) %{
11629   // Same match rule as `branchConFar'.
11630   match(If cmp crx);
11631   effect(USE lbl);
11632   ins_cost(BRANCH_COST);
11633 
11634   // If set to 1 this indicates that the current instruction is a
11635   // short variant of a long branch. This avoids using this
11636   // instruction in first-pass matching. It will then only be used in
11637   // the `Shorten_branches' pass.
11638   ins_short_branch(1);
11639 
11640   format %{ "B$cmp     $crx, $lbl" %}
11641   size(4);
11642   ins_encode( enc_bc(crx, cmp, lbl) );
11643   ins_pipe(pipe_class_default);
11644 %}
11645 
11646 // This is for cases when the ppc64 `bc' instruction does not
11647 // reach far enough. So we emit a far branch here, which is more
11648 // expensive.
11649 //
11650 // Conditional Far Branch
11651 instruct branchConFar(cmpOp cmp, flagsRegSrc crx, label lbl) %{
11652   // Same match rule as `branchCon'.
11653   match(If cmp crx);
11654   effect(USE crx, USE lbl);
11655   predicate(!false /* TODO: PPC port HB_Schedule*/);
11656   // Higher cost than `branchCon'.
11657   ins_cost(5*BRANCH_COST);
11658 
11659   // This is not a short variant of a branch, but the long variant.
11660   ins_short_branch(0);
11661 
11662   format %{ "B_FAR$cmp $crx, $lbl" %}
11663   size(8);
11664   ins_encode( enc_bc_far(crx, cmp, lbl) );
11665   ins_pipe(pipe_class_default);
11666 %}
11667 
11668 // Conditional Branch used with Power6 scheduler (can be far or short).
11669 instruct branchConSched(cmpOp cmp, flagsRegSrc crx, label lbl) %{
11670   // Same match rule as `branchCon'.
11671   match(If cmp crx);
11672   effect(USE crx, USE lbl);
11673   predicate(false /* TODO: PPC port HB_Schedule*/);
11674   // Higher cost than `branchCon'.
11675   ins_cost(5*BRANCH_COST);
11676 
11677   // Actually size doesn't depend on alignment but on shortening.
11678   ins_variable_size_depending_on_alignment(true);
11679   // long variant.
11680   ins_short_branch(0);
11681 
11682   format %{ "B_FAR$cmp $crx, $lbl" %}
11683   size(8); // worst case
11684   ins_encode( enc_bc_short_far(crx, cmp, lbl) );
11685   ins_pipe(pipe_class_default);
11686 %}
11687 
11688 instruct branchLoopEnd(cmpOp cmp, flagsRegSrc crx, label labl) %{
11689   match(CountedLoopEnd cmp crx);
11690   effect(USE labl);
11691   ins_cost(BRANCH_COST);
11692 
11693   // short variant.
11694   ins_short_branch(1);
11695 
11696   format %{ "B$cmp     $crx, $labl \t// counted loop end" %}
11697   size(4);
11698   ins_encode( enc_bc(crx, cmp, labl) );
11699   ins_pipe(pipe_class_default);
11700 %}
11701 
11702 instruct branchLoopEndFar(cmpOp cmp, flagsRegSrc crx, label labl) %{
11703   match(CountedLoopEnd cmp crx);
11704   effect(USE labl);
11705   predicate(!false /* TODO: PPC port HB_Schedule */);
11706   ins_cost(BRANCH_COST);
11707 
11708   // Long variant.
11709   ins_short_branch(0);
11710 
11711   format %{ "B_FAR$cmp $crx, $labl \t// counted loop end" %}
11712   size(8);
11713   ins_encode( enc_bc_far(crx, cmp, labl) );
11714   ins_pipe(pipe_class_default);
11715 %}
11716 
11717 // Conditional Branch used with Power6 scheduler (can be far or short).
11718 instruct branchLoopEndSched(cmpOp cmp, flagsRegSrc crx, label labl) %{
11719   match(CountedLoopEnd cmp crx);
11720   effect(USE labl);
11721   predicate(false /* TODO: PPC port HB_Schedule */);
11722   // Higher cost than `branchCon'.
11723   ins_cost(5*BRANCH_COST);
11724 
11725   // Actually size doesn't depend on alignment but on shortening.
11726   ins_variable_size_depending_on_alignment(true);
11727   // Long variant.
11728   ins_short_branch(0);
11729 
11730   format %{ "B_FAR$cmp $crx, $labl \t// counted loop end" %}
11731   size(8); // worst case
11732   ins_encode( enc_bc_short_far(crx, cmp, labl) );
11733   ins_pipe(pipe_class_default);
11734 %}
11735 
11736 // ============================================================================
11737 // Java runtime operations, intrinsics and other complex operations.
11738 
11739 // The 2nd slow-half of a subtype check. Scan the subklass's 2ndary superklass
11740 // array for an instance of the superklass. Set a hidden internal cache on a
11741 // hit (cache is checked with exposed code in gen_subtype_check()). Return
11742 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
11743 //
11744 // GL TODO: Improve this.
11745 // - result should not be a TEMP
11746 // - Add match rule as on sparc avoiding additional Cmp.
11747 instruct partialSubtypeCheck(iRegPdst result, iRegP_N2P subklass, iRegP_N2P superklass,
11748                              iRegPdst tmp_klass, iRegPdst tmp_arrayptr) %{
11749   match(Set result (PartialSubtypeCheck subklass superklass));
11750   effect(TEMP_DEF result, TEMP tmp_klass, TEMP tmp_arrayptr);
11751   ins_cost(DEFAULT_COST*10);
11752 
11753   format %{ "PartialSubtypeCheck $result = ($subklass instanceOf $superklass) tmp: $tmp_klass, $tmp_arrayptr" %}
11754   ins_encode %{
11755     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11756     __ check_klass_subtype_slow_path($subklass$$Register, $superklass$$Register, $tmp_arrayptr$$Register,
11757                                      $tmp_klass$$Register, NULL, $result$$Register);
11758   %}
11759   ins_pipe(pipe_class_default);
11760 %}
11761 
11762 // inlined locking and unlocking
11763 
11764 instruct cmpFastLock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{
11765   match(Set crx (FastLock oop box));
11766   effect(TEMP tmp1, TEMP tmp2);
11767   predicate(!Compile::current()-&gt;use_rtm());
11768 
11769   format %{ "FASTLOCK  $oop, $box, $tmp1, $tmp2" %}
11770   ins_encode %{
11771     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11772     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
11773                                  $tmp1$$Register, $tmp2$$Register, /*tmp3*/ R0,
11774                                  UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
11775     // If locking was successfull, crx should indicate 'EQ'.
11776     // The compiler generates a branch to the runtime call to
11777     // _complete_monitor_locking_Java for the case where crx is 'NE'.
11778   %}
11779   ins_pipe(pipe_class_compare);
11780 %}
11781 
11782 // Separate version for TM. Use bound register for box to enable USE_KILL.
11783 instruct cmpFastLock_tm(flagsReg crx, iRegPdst oop, rarg2RegP box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
11784   match(Set crx (FastLock oop box));
11785   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL box);
11786   predicate(Compile::current()-&gt;use_rtm());
11787 
11788   format %{ "FASTLOCK  $oop, $box, $tmp1, $tmp2, $tmp3 (TM)" %}
11789   ins_encode %{
11790     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11791     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
11792                                  $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
11793                                  /*Biased Locking*/ false,
11794                                  _rtm_counters, _stack_rtm_counters,
11795                                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
11796                                  /*TM*/ true, ra_-&gt;C-&gt;profile_rtm());
11797     // If locking was successfull, crx should indicate 'EQ'.
11798     // The compiler generates a branch to the runtime call to
11799     // _complete_monitor_locking_Java for the case where crx is 'NE'.
11800   %}
11801   ins_pipe(pipe_class_compare);
11802 %}
11803 
11804 instruct cmpFastUnlock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
11805   match(Set crx (FastUnlock oop box));
11806   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
11807   predicate(!Compile::current()-&gt;use_rtm());
11808 
11809   format %{ "FASTUNLOCK  $oop, $box, $tmp1, $tmp2" %}
11810   ins_encode %{
11811     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11812     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
11813                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
11814                                    UseBiasedLocking &amp;&amp; !UseOptoBiasInlining,
11815                                    false);
11816     // If unlocking was successfull, crx should indicate 'EQ'.
11817     // The compiler generates a branch to the runtime call to
11818     // _complete_monitor_unlocking_Java for the case where crx is 'NE'.
11819   %}
11820   ins_pipe(pipe_class_compare);
11821 %}
11822 
11823 instruct cmpFastUnlock_tm(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
11824   match(Set crx (FastUnlock oop box));
11825   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
11826   predicate(Compile::current()-&gt;use_rtm());
11827 
11828   format %{ "FASTUNLOCK  $oop, $box, $tmp1, $tmp2 (TM)" %}
11829   ins_encode %{
11830     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11831     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
11832                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
11833                                    /*Biased Locking*/ false, /*TM*/ true);
11834     // If unlocking was successfull, crx should indicate 'EQ'.
11835     // The compiler generates a branch to the runtime call to
11836     // _complete_monitor_unlocking_Java for the case where crx is 'NE'.
11837   %}
11838   ins_pipe(pipe_class_compare);
11839 %}
11840 
11841 // Align address.
11842 instruct align_addr(iRegPdst dst, iRegPsrc src, immLnegpow2 mask) %{
11843   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
11844 
11845   format %{ "ANDDI   $dst, $src, $mask \t// next aligned address" %}
11846   size(4);
11847   ins_encode %{
11848     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
11849     __ clrrdi($dst$$Register, $src$$Register, log2_long((jlong)-$mask$$constant));
11850   %}
11851   ins_pipe(pipe_class_default);
11852 %}
11853 
11854 // Array size computation.
11855 instruct array_size(iRegLdst dst, iRegPsrc end, iRegPsrc start) %{
11856   match(Set dst (SubL (CastP2X end) (CastP2X start)));
11857 
11858   format %{ "SUB     $dst, $end, $start \t// array size in bytes" %}
11859   size(4);
11860   ins_encode %{
11861     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
11862     __ subf($dst$$Register, $start$$Register, $end$$Register);
11863   %}
11864   ins_pipe(pipe_class_default);
11865 %}
11866 
11867 // Clear-array with constant short array length. The versions below can use dcbz with cnt &gt; 30.
11868 instruct inlineCallClearArrayShort(immLmax30 cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
11869   match(Set dummy (ClearArray cnt base));
11870   effect(USE_KILL base, KILL ctr);
11871   ins_cost(2 * MEMORY_REF_COST);
11872 
11873   format %{ "ClearArray $cnt, $base" %}
11874   ins_encode %{
11875     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11876     __ clear_memory_constlen($base$$Register, $cnt$$constant, R0); // kills base, R0
11877   %}
11878   ins_pipe(pipe_class_default);
11879 %}
11880 
11881 // Clear-array with constant large array length.
11882 instruct inlineCallClearArrayLarge(immL cnt, rarg2RegP base, Universe dummy, iRegLdst tmp, regCTR ctr) %{
11883   match(Set dummy (ClearArray cnt base));
11884   effect(USE_KILL base, TEMP tmp, KILL ctr);
11885   ins_cost(3 * MEMORY_REF_COST);
11886 
11887   format %{ "ClearArray $cnt, $base \t// KILL $tmp" %}
11888   ins_encode %{
11889     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11890     __ clear_memory_doubleword($base$$Register, $tmp$$Register, R0, $cnt$$constant); // kills base, R0
11891   %}
11892   ins_pipe(pipe_class_default);
11893 %}
11894 
11895 // Clear-array with dynamic array length.
11896 instruct inlineCallClearArray(rarg1RegL cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
11897   match(Set dummy (ClearArray cnt base));
11898   effect(USE_KILL cnt, USE_KILL base, KILL ctr);
11899   ins_cost(4 * MEMORY_REF_COST);
11900 
11901   format %{ "ClearArray $cnt, $base" %}
11902   ins_encode %{
11903     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11904     __ clear_memory_doubleword($base$$Register, $cnt$$Register, R0); // kills cnt, base, R0
11905   %}
11906   ins_pipe(pipe_class_default);
11907 %}
11908 
11909 instruct string_compareL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
11910                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11911   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11912   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11913   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
11914   ins_cost(300);
11915   format %{ "String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp" %}
11916   ins_encode %{
11917     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11918     __ string_compare($str1$$Register, $str2$$Register,
11919                       $cnt1$$Register, $cnt2$$Register,
11920                       $tmp$$Register,
11921                       $result$$Register, StrIntrinsicNode::LL);
11922   %}
11923   ins_pipe(pipe_class_default);
11924 %}
11925 
11926 instruct string_compareU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
11927                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11928   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11929   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11930   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
11931   ins_cost(300);
11932   format %{ "String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp" %}
11933   ins_encode %{
11934     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11935     __ string_compare($str1$$Register, $str2$$Register,
11936                       $cnt1$$Register, $cnt2$$Register,
11937                       $tmp$$Register,
11938                       $result$$Register, StrIntrinsicNode::UU);
11939   %}
11940   ins_pipe(pipe_class_default);
11941 %}
11942 
11943 instruct string_compareLU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
11944                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11945   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11946   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11947   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
11948   ins_cost(300);
11949   format %{ "String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp" %}
11950   ins_encode %{
11951     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11952     __ string_compare($str1$$Register, $str2$$Register,
11953                       $cnt1$$Register, $cnt2$$Register,
11954                       $tmp$$Register,
11955                       $result$$Register, StrIntrinsicNode::LU);
11956   %}
11957   ins_pipe(pipe_class_default);
11958 %}
11959 
11960 instruct string_compareUL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
11961                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11962   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11963   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11964   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
11965   ins_cost(300);
11966   format %{ "String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp" %}
11967   ins_encode %{
11968     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11969     __ string_compare($str2$$Register, $str1$$Register,
11970                       $cnt2$$Register, $cnt1$$Register,
11971                       $tmp$$Register,
11972                       $result$$Register, StrIntrinsicNode::UL);
11973   %}
11974   ins_pipe(pipe_class_default);
11975 %}
11976 
11977 instruct string_equalsL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
11978                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11979   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11980   match(Set result (StrEquals (Binary str1 str2) cnt));
11981   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
11982   ins_cost(300);
11983   format %{ "String Equals byte[] $str1,$str2,$cnt -&gt; $result \t// KILL $tmp" %}
11984   ins_encode %{
11985     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11986     __ array_equals(false, $str1$$Register, $str2$$Register,
11987                     $cnt$$Register, $tmp$$Register,
11988                     $result$$Register, true /* byte */);
11989   %}
11990   ins_pipe(pipe_class_default);
11991 %}
11992 
11993 instruct string_equalsU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
11994                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11995   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11996   match(Set result (StrEquals (Binary str1 str2) cnt));
11997   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
11998   ins_cost(300);
11999   format %{ "String Equals char[]  $str1,$str2,$cnt -&gt; $result \t// KILL $tmp" %}
12000   ins_encode %{
12001     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12002     __ array_equals(false, $str1$$Register, $str2$$Register,
12003                     $cnt$$Register, $tmp$$Register,
12004                     $result$$Register, false /* byte */);
12005   %}
12006   ins_pipe(pipe_class_default);
12007 %}
12008 
12009 instruct array_equalsB(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
12010                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
12011   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12012   match(Set result (AryEq ary1 ary2));
12013   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
12014   ins_cost(300);
12015   format %{ "Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2" %}
12016   ins_encode %{
12017     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12018     __ array_equals(true, $ary1$$Register, $ary2$$Register,
12019                     $tmp1$$Register, $tmp2$$Register,
12020                     $result$$Register, true /* byte */);
12021   %}
12022   ins_pipe(pipe_class_default);
12023 %}
12024 
12025 instruct array_equalsC(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
12026                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
12027   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12028   match(Set result (AryEq ary1 ary2));
12029   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
12030   ins_cost(300);
12031   format %{ "Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2" %}
12032   ins_encode %{
12033     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12034     __ array_equals(true, $ary1$$Register, $ary2$$Register,
12035                     $tmp1$$Register, $tmp2$$Register,
12036                     $result$$Register, false /* byte */);
12037   %}
12038   ins_pipe(pipe_class_default);
12039 %}
12040 
12041 instruct indexOf_imm1_char_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12042                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
12043                              iRegIdst tmp1, iRegIdst tmp2,
12044                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12045   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
12046   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12047   // Required for EA: check if it is still a type_array.
12048   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12049   ins_cost(150);
12050 
12051   format %{ "String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]"
12052             "-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1" %}
12053 
12054   ins_encode %{
12055     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12056     immPOper *needleOper = (immPOper *)$needleImm;
12057     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
12058     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
12059     jchar chr;
12060 #ifdef VM_LITTLE_ENDIAN
12061     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
12062            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
12063 #else
12064     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
12065            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
12066 #endif
12067     __ string_indexof_char($result$$Register,
12068                            $haystack$$Register, $haycnt$$Register,
12069                            R0, chr,
12070                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
12071   %}
12072   ins_pipe(pipe_class_compare);
12073 %}
12074 
12075 instruct indexOf_imm1_char_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12076                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
12077                              iRegIdst tmp1, iRegIdst tmp2,
12078                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12079   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
12080   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12081   // Required for EA: check if it is still a type_array.
12082   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12083   ins_cost(150);
12084 
12085   format %{ "String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]"
12086             "-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1" %}
12087 
12088   ins_encode %{
12089     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12090     immPOper *needleOper = (immPOper *)$needleImm;
12091     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
12092     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
12093     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
12094     __ string_indexof_char($result$$Register,
12095                            $haystack$$Register, $haycnt$$Register,
12096                            R0, chr,
12097                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
12098   %}
12099   ins_pipe(pipe_class_compare);
12100 %}
12101 
12102 instruct indexOf_imm1_char_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12103                               immP needleImm, immL offsetImm, immI_1 needlecntImm,
12104                               iRegIdst tmp1, iRegIdst tmp2,
12105                               flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12106   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
12107   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12108   // Required for EA: check if it is still a type_array.
12109   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
12110   ins_cost(150);
12111 
12112   format %{ "String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]"
12113             "-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1" %}
12114 
12115   ins_encode %{
12116     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12117     immPOper *needleOper = (immPOper *)$needleImm;
12118     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
12119     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
12120     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
12121     __ string_indexof_char($result$$Register,
12122                            $haystack$$Register, $haycnt$$Register,
12123                            R0, chr,
12124                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
12125   %}
12126   ins_pipe(pipe_class_compare);
12127 %}
12128 
12129 instruct indexOf_imm1_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12130                         rscratch2RegP needle, immI_1 needlecntImm,
12131                         iRegIdst tmp1, iRegIdst tmp2,
12132                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12133   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12134   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12135   // Required for EA: check if it is still a type_array.
12136   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
12137             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12138             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12139   ins_cost(180);
12140 
12141   format %{ "String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12142             " -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1" %}
12143   ins_encode %{
12144     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12145     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12146     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12147     guarantee(needle_values, "sanity");
12148     jchar chr;
12149 #ifdef VM_LITTLE_ENDIAN
12150     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
12151            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
12152 #else
12153     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
12154            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
12155 #endif
12156     __ string_indexof_char($result$$Register,
12157                            $haystack$$Register, $haycnt$$Register,
12158                            R0, chr,
12159                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
12160   %}
12161   ins_pipe(pipe_class_compare);
12162 %}
12163 
12164 instruct indexOf_imm1_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12165                         rscratch2RegP needle, immI_1 needlecntImm,
12166                         iRegIdst tmp1, iRegIdst tmp2,
12167                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12168   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12169   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12170   // Required for EA: check if it is still a type_array.
12171   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
12172             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12173             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12174   ins_cost(180);
12175 
12176   format %{ "String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12177             " -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1" %}
12178   ins_encode %{
12179     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12180     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12181     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12182     guarantee(needle_values, "sanity");
12183     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
12184     __ string_indexof_char($result$$Register,
12185                            $haystack$$Register, $haycnt$$Register,
12186                            R0, chr,
12187                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
12188   %}
12189   ins_pipe(pipe_class_compare);
12190 %}
12191 
12192 instruct indexOf_imm1_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12193                          rscratch2RegP needle, immI_1 needlecntImm,
12194                          iRegIdst tmp1, iRegIdst tmp2,
12195                          flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12196   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12197   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12198   // Required for EA: check if it is still a type_array.
12199   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
12200             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12201             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12202   ins_cost(180);
12203 
12204   format %{ "String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12205             " -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1" %}
12206   ins_encode %{
12207     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12208     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12209     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12210     guarantee(needle_values, "sanity");
12211     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
12212     __ string_indexof_char($result$$Register,
12213                            $haystack$$Register, $haycnt$$Register,
12214                            R0, chr,
12215                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
12216   %}
12217   ins_pipe(pipe_class_compare);
12218 %}
12219 
12220 instruct indexOfChar_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12221                        iRegIsrc ch, iRegIdst tmp1, iRegIdst tmp2,
12222                        flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12223   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
12224   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12225   ins_cost(180);
12226 
12227   format %{ "String IndexOfChar $haystack[0..$haycnt], $ch"
12228             " -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1" %}
12229   ins_encode %{
12230     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12231     __ string_indexof_char($result$$Register,
12232                            $haystack$$Register, $haycnt$$Register,
12233                            $ch$$Register, 0 /* this is not used if the character is already in a register */,
12234                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
12235   %}
12236   ins_pipe(pipe_class_compare);
12237 %}
12238 
12239 instruct indexOf_imm_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
12240                        iRegPsrc needle, uimmI15 needlecntImm,
12241                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
12242                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12243   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12244   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
12245          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12246   // Required for EA: check if it is still a type_array.
12247   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
12248             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12249             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12250   ins_cost(250);
12251 
12252   format %{ "String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12253             " -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1" %}
12254   ins_encode %{
12255     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12256     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12257     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12258 
12259     __ string_indexof($result$$Register,
12260                       $haystack$$Register, $haycnt$$Register,
12261                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
12262                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
12263   %}
12264   ins_pipe(pipe_class_compare);
12265 %}
12266 
12267 instruct indexOf_imm_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
12268                        iRegPsrc needle, uimmI15 needlecntImm,
12269                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
12270                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12271   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12272   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
12273          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12274   // Required for EA: check if it is still a type_array.
12275   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
12276             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12277             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12278   ins_cost(250);
12279 
12280   format %{ "String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12281             " -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1" %}
12282   ins_encode %{
12283     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12284     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12285     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12286 
12287     __ string_indexof($result$$Register,
12288                       $haystack$$Register, $haycnt$$Register,
12289                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
12290                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
12291   %}
12292   ins_pipe(pipe_class_compare);
12293 %}
12294 
12295 instruct indexOf_imm_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
12296                         iRegPsrc needle, uimmI15 needlecntImm,
12297                         iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
12298                         flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12299   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12300   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
12301          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12302   // Required for EA: check if it is still a type_array.
12303   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
12304             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12305             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12306   ins_cost(250);
12307 
12308   format %{ "String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12309             " -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1" %}
12310   ins_encode %{
12311     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12312     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12313     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12314 
12315     __ string_indexof($result$$Register,
12316                       $haystack$$Register, $haycnt$$Register,
12317                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
12318                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
12319   %}
12320   ins_pipe(pipe_class_compare);
12321 %}
12322 
12323 instruct indexOf_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
12324                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
12325                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12326   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
12327   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
12328          TEMP_DEF result,
12329          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12330   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12331   ins_cost(300);
12332 
12333   format %{ "String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]"
12334              " -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1" %}
12335   ins_encode %{
12336     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12337     __ string_indexof($result$$Register,
12338                       $haystack$$Register, $haycnt$$Register,
12339                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
12340                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
12341   %}
12342   ins_pipe(pipe_class_compare);
12343 %}
12344 
12345 instruct indexOf_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
12346                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
12347                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12348   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
12349   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
12350          TEMP_DEF result,
12351          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12352   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12353   ins_cost(300);
12354 
12355   format %{ "String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]"
12356              " -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1" %}
12357   ins_encode %{
12358     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12359     __ string_indexof($result$$Register,
12360                       $haystack$$Register, $haycnt$$Register,
12361                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
12362                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
12363   %}
12364   ins_pipe(pipe_class_compare);
12365 %}
12366 
12367 instruct indexOf_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
12368                     iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
12369                     flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12370   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
12371   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
12372          TEMP_DEF result,
12373          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12374   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
12375   ins_cost(300);
12376 
12377   format %{ "String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]"
12378              " -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1" %}
12379   ins_encode %{
12380     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12381     __ string_indexof($result$$Register,
12382                       $haystack$$Register, $haycnt$$Register,
12383                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
12384                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
12385   %}
12386   ins_pipe(pipe_class_compare);
12387 %}
12388 
12389 // char[] to byte[] compression
12390 instruct string_compress(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
12391                          iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
12392   match(Set result (StrCompressedCopy src (Binary dst len)));
12393   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
12394          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
12395   ins_cost(300);
12396   format %{ "String Compress $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5" %}
12397   ins_encode %{
12398     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12399     Label Lskip, Ldone;
12400     __ li($result$$Register, 0);
12401     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
12402                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Ldone);
12403     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
12404     __ beq(CCR0, Lskip);
12405     __ string_compress($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register, Ldone);
12406     __ bind(Lskip);
12407     __ mr($result$$Register, $len$$Register);
12408     __ bind(Ldone);
12409   %}
12410   ins_pipe(pipe_class_default);
12411 %}
12412 
12413 // byte[] to char[] inflation
12414 instruct string_inflate(Universe dummy, rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegLdst tmp1,
12415                         iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
12416   match(Set dummy (StrInflatedCopy src (Binary dst len)));
12417   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
12418   ins_cost(300);
12419   format %{ "String Inflate $src,$dst,$len \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5" %}
12420   ins_encode %{
12421     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12422     Label Ldone;
12423     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
12424                          $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register);
12425     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
12426     __ beq(CCR0, Ldone);
12427     __ string_inflate($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register);
12428     __ bind(Ldone);
12429   %}
12430   ins_pipe(pipe_class_default);
12431 %}
12432 
12433 // StringCoding.java intrinsics
12434 instruct has_negatives(rarg1RegP ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,
12435                        regCTR ctr, flagsRegCR0 cr0)
12436 %{
12437   match(Set result (HasNegatives ary1 len));
12438   effect(TEMP_DEF result, USE_KILL ary1, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);
12439   ins_cost(300);
12440   format %{ "has negatives byte[] $ary1,$len -&gt; $result \t// KILL $tmp1, $tmp2" %}
12441   ins_encode %{
12442     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12443     __ has_negatives($ary1$$Register, $len$$Register, $result$$Register,
12444                      $tmp1$$Register, $tmp2$$Register);
12445   %}
12446   ins_pipe(pipe_class_default);
12447 %}
12448 
12449 // encode char[] to byte[] in ISO_8859_1
12450 instruct encode_iso_array(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
12451                           iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
12452   match(Set result (EncodeISOArray src (Binary dst len)));
12453   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
12454          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
12455   ins_cost(300);
12456   format %{ "Encode array $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5" %}
12457   ins_encode %{
12458     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12459     Label Lslow, Lfailure1, Lfailure2, Ldone;
12460     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
12461                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Lfailure1);
12462     __ rldicl_($result$$Register, $len$$Register, 0, 64-3); // Remaining characters.
12463     __ beq(CCR0, Ldone);
12464     __ bind(Lslow);
12465     __ string_compress($src$$Register, $dst$$Register, $result$$Register, $tmp2$$Register, Lfailure2);
12466     __ li($result$$Register, 0);
12467     __ b(Ldone);
12468 
12469     __ bind(Lfailure1);
12470     __ mr($result$$Register, $len$$Register);
12471     __ mfctr($tmp1$$Register);
12472     __ rldimi_($result$$Register, $tmp1$$Register, 3, 0); // Remaining characters.
12473     __ beq(CCR0, Ldone);
12474     __ b(Lslow);
12475 
12476     __ bind(Lfailure2);
12477     __ mfctr($result$$Register); // Remaining characters.
12478 
12479     __ bind(Ldone);
12480     __ subf($result$$Register, $result$$Register, $len$$Register);
12481   %}
12482   ins_pipe(pipe_class_default);
12483 %}
12484 
12485 
12486 //---------- Min/Max Instructions ---------------------------------------------
12487 
12488 instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
12489   match(Set dst (MinI src1 src2));
12490   ins_cost(DEFAULT_COST*6);
12491 
12492   expand %{
12493     iRegLdst src1s;
12494     iRegLdst src2s;
12495     iRegLdst diff;
12496     iRegLdst sm;
12497     iRegLdst doz; // difference or zero
12498     convI2L_reg(src1s, src1); // Ensure proper sign extension.
12499     convI2L_reg(src2s, src2); // Ensure proper sign extension.
12500     subL_reg_reg(diff, src2s, src1s);
12501     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
12502     signmask64L_regL(sm, diff);
12503     andL_reg_reg(doz, diff, sm); // &lt;=0
12504     addI_regL_regL(dst, doz, src1s);
12505   %}
12506 %}
12507 
12508 instruct minI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
12509   match(Set dst (MinI src1 src2));
12510   effect(KILL cr0);
12511   predicate(VM_Version::has_isel());
12512   ins_cost(DEFAULT_COST*2);
12513 
12514   ins_encode %{
12515     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12516     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
12517     __ isel($dst$$Register, CCR0, Assembler::less, /*invert*/false, $src1$$Register, $src2$$Register);
12518   %}
12519   ins_pipe(pipe_class_default);
12520 %}
12521 
12522 instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
12523   match(Set dst (MaxI src1 src2));
12524   ins_cost(DEFAULT_COST*6);
12525 
12526   expand %{
12527     iRegLdst src1s;
12528     iRegLdst src2s;
12529     iRegLdst diff;
12530     iRegLdst sm;
12531     iRegLdst doz; // difference or zero
12532     convI2L_reg(src1s, src1); // Ensure proper sign extension.
12533     convI2L_reg(src2s, src2); // Ensure proper sign extension.
12534     subL_reg_reg(diff, src2s, src1s);
12535     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
12536     signmask64L_regL(sm, diff);
12537     andcL_reg_reg(doz, diff, sm); // &gt;=0
12538     addI_regL_regL(dst, doz, src1s);
12539   %}
12540 %}
12541 
12542 instruct maxI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
12543   match(Set dst (MaxI src1 src2));
12544   effect(KILL cr0);
12545   predicate(VM_Version::has_isel());
12546   ins_cost(DEFAULT_COST*2);
12547 
12548   ins_encode %{
12549     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12550     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
12551     __ isel($dst$$Register, CCR0, Assembler::greater, /*invert*/false, $src1$$Register, $src2$$Register);
12552   %}
12553   ins_pipe(pipe_class_default);
12554 %}
12555 
12556 //---------- Population Count Instructions ------------------------------------
12557 
12558 // Popcnt for Power7.
12559 instruct popCountI(iRegIdst dst, iRegIsrc src) %{
12560   match(Set dst (PopCountI src));
12561   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
12562   ins_cost(DEFAULT_COST);
12563 
12564   format %{ "POPCNTW $dst, $src" %}
12565   size(4);
12566   ins_encode %{
12567     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
12568     __ popcntw($dst$$Register, $src$$Register);
12569   %}
12570   ins_pipe(pipe_class_default);
12571 %}
12572 
12573 // Popcnt for Power7.
12574 instruct popCountL(iRegIdst dst, iRegLsrc src) %{
12575   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
12576   match(Set dst (PopCountL src));
12577   ins_cost(DEFAULT_COST);
12578 
12579   format %{ "POPCNTD $dst, $src" %}
12580   size(4);
12581   ins_encode %{
12582     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
12583     __ popcntd($dst$$Register, $src$$Register);
12584   %}
12585   ins_pipe(pipe_class_default);
12586 %}
12587 
12588 instruct countLeadingZerosI(iRegIdst dst, iRegIsrc src) %{
12589   match(Set dst (CountLeadingZerosI src));
12590   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
12591   ins_cost(DEFAULT_COST);
12592 
12593   format %{ "CNTLZW  $dst, $src" %}
12594   size(4);
12595   ins_encode %{
12596     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzw);
12597     __ cntlzw($dst$$Register, $src$$Register);
12598   %}
12599   ins_pipe(pipe_class_default);
12600 %}
12601 
12602 instruct countLeadingZerosL(iRegIdst dst, iRegLsrc src) %{
12603   match(Set dst (CountLeadingZerosL src));
12604   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
12605   ins_cost(DEFAULT_COST);
12606 
12607   format %{ "CNTLZD  $dst, $src" %}
12608   size(4);
12609   ins_encode %{
12610     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
12611     __ cntlzd($dst$$Register, $src$$Register);
12612   %}
12613   ins_pipe(pipe_class_default);
12614 %}
12615 
12616 instruct countLeadingZerosP(iRegIdst dst, iRegPsrc src) %{
12617   // no match-rule, false predicate
12618   effect(DEF dst, USE src);
12619   predicate(false);
12620 
12621   format %{ "CNTLZD  $dst, $src" %}
12622   size(4);
12623   ins_encode %{
12624     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
12625     __ cntlzd($dst$$Register, $src$$Register);
12626   %}
12627   ins_pipe(pipe_class_default);
12628 %}
12629 
12630 instruct countTrailingZerosI_Ex(iRegIdst dst, iRegIsrc src) %{
12631   match(Set dst (CountTrailingZerosI src));
12632   predicate(UseCountLeadingZerosInstructionsPPC64);
12633   ins_cost(DEFAULT_COST);
12634 
12635   expand %{
12636     immI16 imm1 %{ (int)-1 %}
12637     immI16 imm2 %{ (int)32 %}
12638     immI_minus1 m1 %{ -1 %}
12639     iRegIdst tmpI1;
12640     iRegIdst tmpI2;
12641     iRegIdst tmpI3;
12642     addI_reg_imm16(tmpI1, src, imm1);
12643     andcI_reg_reg(tmpI2, src, m1, tmpI1);
12644     countLeadingZerosI(tmpI3, tmpI2);
12645     subI_imm16_reg(dst, imm2, tmpI3);
12646   %}
12647 %}
12648 
12649 instruct countTrailingZerosL_Ex(iRegIdst dst, iRegLsrc src) %{
12650   match(Set dst (CountTrailingZerosL src));
12651   predicate(UseCountLeadingZerosInstructionsPPC64);
12652   ins_cost(DEFAULT_COST);
12653 
12654   expand %{
12655     immL16 imm1 %{ (long)-1 %}
12656     immI16 imm2 %{ (int)64 %}
12657     iRegLdst tmpL1;
12658     iRegLdst tmpL2;
12659     iRegIdst tmpL3;
12660     addL_reg_imm16(tmpL1, src, imm1);
12661     andcL_reg_reg(tmpL2, tmpL1, src);
12662     countLeadingZerosL(tmpL3, tmpL2);
12663     subI_imm16_reg(dst, imm2, tmpL3);
12664  %}
12665 %}
12666 
12667 // Expand nodes for byte_reverse_int.
12668 instruct insrwi_a(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
12669   effect(DEF dst, USE src, USE pos, USE shift);
12670   predicate(false);
12671 
12672   format %{ "INSRWI  $dst, $src, $pos, $shift" %}
12673   size(4);
12674   ins_encode %{
12675     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
12676     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
12677   %}
12678   ins_pipe(pipe_class_default);
12679 %}
12680 
12681 // As insrwi_a, but with USE_DEF.
12682 instruct insrwi(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
12683   effect(USE_DEF dst, USE src, USE pos, USE shift);
12684   predicate(false);
12685 
12686   format %{ "INSRWI  $dst, $src, $pos, $shift" %}
12687   size(4);
12688   ins_encode %{
12689     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
12690     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
12691   %}
12692   ins_pipe(pipe_class_default);
12693 %}
12694 
12695 // Just slightly faster than java implementation.
12696 instruct bytes_reverse_int_Ex(iRegIdst dst, iRegIsrc src) %{
12697   match(Set dst (ReverseBytesI src));
12698   predicate(UseCountLeadingZerosInstructionsPPC64);
12699   ins_cost(DEFAULT_COST);
12700 
12701   expand %{
12702     immI16 imm24 %{ (int) 24 %}
12703     immI16 imm16 %{ (int) 16 %}
12704     immI16  imm8 %{ (int)  8 %}
12705     immI16  imm4 %{ (int)  4 %}
12706     immI16  imm0 %{ (int)  0 %}
12707     iRegLdst tmpI1;
12708     iRegLdst tmpI2;
12709     iRegLdst tmpI3;
12710 
12711     urShiftI_reg_imm(tmpI1, src, imm24);
12712     insrwi_a(dst, tmpI1, imm24, imm8);
12713     urShiftI_reg_imm(tmpI2, src, imm16);
12714     insrwi(dst, tmpI2, imm8, imm16);
12715     urShiftI_reg_imm(tmpI3, src, imm8);
12716     insrwi(dst, tmpI3, imm8, imm8);
12717     insrwi(dst, src, imm0, imm8);
12718   %}
12719 %}
12720 
12721 //---------- Replicate Vector Instructions ------------------------------------
12722 
12723 // Insrdi does replicate if src == dst.
12724 instruct repl32(iRegLdst dst) %{
12725   predicate(false);
12726   effect(USE_DEF dst);
12727 
12728   format %{ "INSRDI  $dst, #0, $dst, #32 \t// replicate" %}
12729   size(4);
12730   ins_encode %{
12731     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
12732     __ insrdi($dst$$Register, $dst$$Register, 32, 0);
12733   %}
12734   ins_pipe(pipe_class_default);
12735 %}
12736 
12737 // Insrdi does replicate if src == dst.
12738 instruct repl48(iRegLdst dst) %{
12739   predicate(false);
12740   effect(USE_DEF dst);
12741 
12742   format %{ "INSRDI  $dst, #0, $dst, #48 \t// replicate" %}
12743   size(4);
12744   ins_encode %{
12745     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
12746     __ insrdi($dst$$Register, $dst$$Register, 48, 0);
12747   %}
12748   ins_pipe(pipe_class_default);
12749 %}
12750 
12751 // Insrdi does replicate if src == dst.
12752 instruct repl56(iRegLdst dst) %{
12753   predicate(false);
12754   effect(USE_DEF dst);
12755 
12756   format %{ "INSRDI  $dst, #0, $dst, #56 \t// replicate" %}
12757   size(4);
12758   ins_encode %{
12759     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
12760     __ insrdi($dst$$Register, $dst$$Register, 56, 0);
12761   %}
12762   ins_pipe(pipe_class_default);
12763 %}
12764 
12765 instruct repl8B_reg_Ex(iRegLdst dst, iRegIsrc src) %{
12766   match(Set dst (ReplicateB src));
12767   predicate(n-&gt;as_Vector()-&gt;length() == 8);
12768   expand %{
12769     moveReg(dst, src);
12770     repl56(dst);
12771     repl48(dst);
12772     repl32(dst);
12773   %}
12774 %}
12775 
12776 instruct repl8B_immI0(iRegLdst dst, immI_0 zero) %{
12777   match(Set dst (ReplicateB zero));
12778   predicate(n-&gt;as_Vector()-&gt;length() == 8);
12779   format %{ "LI      $dst, #0 \t// replicate8B" %}
12780   size(4);
12781   ins_encode %{
12782     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12783     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
12784   %}
12785   ins_pipe(pipe_class_default);
12786 %}
12787 
12788 instruct repl8B_immIminus1(iRegLdst dst, immI_minus1 src) %{
12789   match(Set dst (ReplicateB src));
12790   predicate(n-&gt;as_Vector()-&gt;length() == 8);
12791   format %{ "LI      $dst, #-1 \t// replicate8B" %}
12792   size(4);
12793   ins_encode %{
12794     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12795     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
12796   %}
12797   ins_pipe(pipe_class_default);
12798 %}
12799 
12800 instruct repl4S_reg_Ex(iRegLdst dst, iRegIsrc src) %{
12801   match(Set dst (ReplicateS src));
12802   predicate(n-&gt;as_Vector()-&gt;length() == 4);
12803   expand %{
12804     moveReg(dst, src);
12805     repl48(dst);
12806     repl32(dst);
12807   %}
12808 %}
12809 
12810 instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
12811   match(Set dst (ReplicateS zero));
12812   predicate(n-&gt;as_Vector()-&gt;length() == 4);
12813   format %{ "LI      $dst, #0 \t// replicate4C" %}
12814   size(4);
12815   ins_encode %{
12816     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12817     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
12818   %}
12819   ins_pipe(pipe_class_default);
12820 %}
12821 
12822 instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
12823   match(Set dst (ReplicateS src));
12824   predicate(n-&gt;as_Vector()-&gt;length() == 4);
12825   format %{ "LI      $dst, -1 \t// replicate4C" %}
12826   size(4);
12827   ins_encode %{
12828     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12829     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
12830   %}
12831   ins_pipe(pipe_class_default);
12832 %}
12833 
12834 instruct repl2I_reg_Ex(iRegLdst dst, iRegIsrc src) %{
12835   match(Set dst (ReplicateI src));
12836   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12837   ins_cost(2 * DEFAULT_COST);
12838   expand %{
12839     moveReg(dst, src);
12840     repl32(dst);
12841   %}
12842 %}
12843 
12844 instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
12845   match(Set dst (ReplicateI zero));
12846   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12847   format %{ "LI      $dst, #0 \t// replicate4C" %}
12848   size(4);
12849   ins_encode %{
12850     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12851     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
12852   %}
12853   ins_pipe(pipe_class_default);
12854 %}
12855 
12856 instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
12857   match(Set dst (ReplicateI src));
12858   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12859   format %{ "LI      $dst, -1 \t// replicate4C" %}
12860   size(4);
12861   ins_encode %{
12862     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12863     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
12864   %}
12865   ins_pipe(pipe_class_default);
12866 %}
12867 
12868 // Move float to int register via stack, replicate.
12869 instruct repl2F_reg_Ex(iRegLdst dst, regF src) %{
12870   match(Set dst (ReplicateF src));
12871   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12872   ins_cost(2 * MEMORY_REF_COST + DEFAULT_COST);
12873   expand %{
12874     stackSlotL tmpS;
12875     iRegIdst tmpI;
12876     moveF2I_reg_stack(tmpS, src);   // Move float to stack.
12877     moveF2I_stack_reg(tmpI, tmpS);  // Move stack to int reg.
12878     moveReg(dst, tmpI);             // Move int to long reg.
12879     repl32(dst);                    // Replicate bitpattern.
12880   %}
12881 %}
12882 
12883 // Replicate scalar constant to packed float values in Double register
12884 instruct repl2F_immF_Ex(iRegLdst dst, immF src) %{
12885   match(Set dst (ReplicateF src));
12886   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12887   ins_cost(5 * DEFAULT_COST);
12888 
12889   format %{ "LD      $dst, offset, $constanttablebase\t// load replicated float $src $src from table, postalloc expanded" %}
12890   postalloc_expand( postalloc_expand_load_replF_constant(dst, src, constanttablebase) );
12891 %}
12892 
12893 // Replicate scalar zero constant to packed float values in Double register
12894 instruct repl2F_immF0(iRegLdst dst, immF_0 zero) %{
12895   match(Set dst (ReplicateF zero));
12896   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12897 
12898   format %{ "LI      $dst, #0 \t// replicate2F" %}
12899   ins_encode %{
12900     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12901     __ li($dst$$Register, 0x0);
12902   %}
12903   ins_pipe(pipe_class_default);
12904 %}
12905 
12906 
12907 //----------Overflow Math Instructions-----------------------------------------
12908 
12909 // Note that we have to make sure that XER.SO is reset before using overflow instructions.
12910 // Simple Overflow operations can be matched by very few instructions (e.g. addExact: xor, and_, bc).
12911 // Seems like only Long intrinsincs have an advantage. (The only expensive one is OverflowMulL.)
12912 
12913 instruct overflowAddL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
12914   match(Set cr0 (OverflowAddL op1 op2));
12915 
12916   format %{ "add_    $op1, $op2\t# overflow check long" %}
12917   ins_encode %{
12918     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12919     __ li(R0, 0);
12920     __ mtxer(R0); // clear XER.SO
12921     __ addo_(R0, $op1$$Register, $op2$$Register);
12922   %}
12923   ins_pipe(pipe_class_default);
12924 %}
12925 
12926 instruct overflowSubL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
12927   match(Set cr0 (OverflowSubL op1 op2));
12928 
12929   format %{ "subfo_  R0, $op2, $op1\t# overflow check long" %}
12930   ins_encode %{
12931     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12932     __ li(R0, 0);
12933     __ mtxer(R0); // clear XER.SO
12934     __ subfo_(R0, $op2$$Register, $op1$$Register);
12935   %}
12936   ins_pipe(pipe_class_default);
12937 %}
12938 
12939 instruct overflowNegL_reg(flagsRegCR0 cr0, immL_0 zero, iRegLsrc op2) %{
12940   match(Set cr0 (OverflowSubL zero op2));
12941 
12942   format %{ "nego_   R0, $op2\t# overflow check long" %}
12943   ins_encode %{
12944     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12945     __ li(R0, 0);
12946     __ mtxer(R0); // clear XER.SO
12947     __ nego_(R0, $op2$$Register);
12948   %}
12949   ins_pipe(pipe_class_default);
12950 %}
12951 
12952 instruct overflowMulL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
12953   match(Set cr0 (OverflowMulL op1 op2));
12954 
12955   format %{ "mulldo_ R0, $op1, $op2\t# overflow check long" %}
12956   ins_encode %{
12957     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12958     __ li(R0, 0);
12959     __ mtxer(R0); // clear XER.SO
12960     __ mulldo_(R0, $op1$$Register, $op2$$Register);
12961   %}
12962   ins_pipe(pipe_class_default);
12963 %}
12964 
12965 
12966 // ============================================================================
12967 // Safepoint Instruction
12968 
12969 instruct safePoint_poll(iRegPdst poll) %{
12970   match(SafePoint poll);
12971   predicate(LoadPollAddressFromThread);
12972 
12973   // It caused problems to add the effect that r0 is killed, but this
12974   // effect no longer needs to be mentioned, since r0 is not contained
12975   // in a reg_class.
12976 
12977   format %{ "LD      R0, #0, $poll \t// Safepoint poll for GC" %}
12978   size(4);
12979   ins_encode( enc_poll(0x0, poll) );
12980   ins_pipe(pipe_class_default);
12981 %}
12982 
12983 // Safepoint without per-thread support. Load address of page to poll
12984 // as constant.
12985 // Rscratch2RegP is R12.
12986 // LoadConPollAddr node is added in pd_post_matching_hook(). It must be
12987 // a seperate node so that the oop map is at the right location.
12988 instruct safePoint_poll_conPollAddr(rscratch2RegP poll) %{
12989   match(SafePoint poll);
12990   predicate(!LoadPollAddressFromThread);
12991 
12992   // It caused problems to add the effect that r0 is killed, but this
12993   // effect no longer needs to be mentioned, since r0 is not contained
12994   // in a reg_class.
12995 
12996   format %{ "LD      R0, #0, R12 \t// Safepoint poll for GC" %}
12997   ins_encode( enc_poll(0x0, poll) );
12998   ins_pipe(pipe_class_default);
12999 %}
13000 
13001 // ============================================================================
13002 // Call Instructions
13003 
13004 // Call Java Static Instruction
13005 
13006 // Schedulable version of call static node.
13007 instruct CallStaticJavaDirect(method meth) %{
13008   match(CallStaticJava);
13009   effect(USE meth);
13010   ins_cost(CALL_COST);
13011 
13012   ins_num_consts(3 /* up to 3 patchable constants: inline cache, 2 call targets. */);
13013 
13014   format %{ "CALL,static $meth \t// ==&gt; " %}
13015   size(4);
13016   ins_encode( enc_java_static_call(meth) );
13017   ins_pipe(pipe_class_call);
13018 %}
13019 
13020 // Call Java Dynamic Instruction
13021 
13022 // Used by postalloc expand of CallDynamicJavaDirectSchedEx (actual call).
13023 // Loading of IC was postalloc expanded. The nodes loading the IC are reachable
13024 // via fields ins_field_load_ic_hi_node and ins_field_load_ic_node.
13025 // The call destination must still be placed in the constant pool.
13026 instruct CallDynamicJavaDirectSched(method meth) %{
13027   match(CallDynamicJava); // To get all the data fields we need ...
13028   effect(USE meth);
13029   predicate(false);       // ... but never match.
13030 
13031   ins_field_load_ic_hi_node(loadConL_hiNode*);
13032   ins_field_load_ic_node(loadConLNode*);
13033   ins_num_consts(1 /* 1 patchable constant: call destination */);
13034 
13035   format %{ "BL        \t// dynamic $meth ==&gt; " %}
13036   size(4);
13037   ins_encode( enc_java_dynamic_call_sched(meth) );
13038   ins_pipe(pipe_class_call);
13039 %}
13040 
13041 // Schedulable (i.e. postalloc expanded) version of call dynamic java.
13042 // We use postalloc expanded calls if we use inline caches
13043 // and do not update method data.
13044 //
13045 // This instruction has two constants: inline cache (IC) and call destination.
13046 // Loading the inline cache will be postalloc expanded, thus leaving a call with
13047 // one constant.
13048 instruct CallDynamicJavaDirectSched_Ex(method meth) %{
13049   match(CallDynamicJava);
13050   effect(USE meth);
13051   predicate(UseInlineCaches);
13052   ins_cost(CALL_COST);
13053 
13054   ins_num_consts(2 /* 2 patchable constants: inline cache, call destination. */);
13055 
13056   format %{ "CALL,dynamic $meth \t// postalloc expanded" %}
13057   postalloc_expand( postalloc_expand_java_dynamic_call_sched(meth, constanttablebase) );
13058 %}
13059 
13060 // Compound version of call dynamic java
13061 // We use postalloc expanded calls if we use inline caches
13062 // and do not update method data.
13063 instruct CallDynamicJavaDirect(method meth) %{
13064   match(CallDynamicJava);
13065   effect(USE meth);
13066   predicate(!UseInlineCaches);
13067   ins_cost(CALL_COST);
13068 
13069   // Enc_java_to_runtime_call needs up to 4 constants (method data oop).
13070   ins_num_consts(4);
13071 
13072   format %{ "CALL,dynamic $meth \t// ==&gt; " %}
13073   ins_encode( enc_java_dynamic_call(meth, constanttablebase) );
13074   ins_pipe(pipe_class_call);
13075 %}
13076 
13077 // Call Runtime Instruction
13078 
13079 instruct CallRuntimeDirect(method meth) %{
13080   match(CallRuntime);
13081   effect(USE meth);
13082   ins_cost(CALL_COST);
13083 
13084   // Enc_java_to_runtime_call needs up to 3 constants: call target,
13085   // env for callee, C-toc.
13086   ins_num_consts(3);
13087 
13088   format %{ "CALL,runtime" %}
13089   ins_encode( enc_java_to_runtime_call(meth) );
13090   ins_pipe(pipe_class_call);
13091 %}
13092 
13093 // Call Leaf
13094 
13095 // Used by postalloc expand of CallLeafDirect_Ex (mtctr).
13096 instruct CallLeafDirect_mtctr(iRegLdst dst, iRegLsrc src) %{
13097   effect(DEF dst, USE src);
13098 
13099   ins_num_consts(1);
13100 
13101   format %{ "MTCTR   $src" %}
13102   size(4);
13103   ins_encode( enc_leaf_call_mtctr(src) );
13104   ins_pipe(pipe_class_default);
13105 %}
13106 
13107 // Used by postalloc expand of CallLeafDirect_Ex (actual call).
13108 instruct CallLeafDirect(method meth) %{
13109   match(CallLeaf);   // To get the data all the data fields we need ...
13110   effect(USE meth);
13111   predicate(false);  // but never match.
13112 
13113   format %{ "BCTRL     \t// leaf call $meth ==&gt; " %}
13114   size(4);
13115   ins_encode %{
13116     // TODO: PPC port $archOpcode(ppc64Opcode_bctrl);
13117     __ bctrl();
13118   %}
13119   ins_pipe(pipe_class_call);
13120 %}
13121 
13122 // postalloc expand of CallLeafDirect.
13123 // Load adress to call from TOC, then bl to it.
13124 instruct CallLeafDirect_Ex(method meth) %{
13125   match(CallLeaf);
13126   effect(USE meth);
13127   ins_cost(CALL_COST);
13128 
13129   // Postalloc_expand_java_to_runtime_call needs up to 3 constants: call target,
13130   // env for callee, C-toc.
13131   ins_num_consts(3);
13132 
13133   format %{ "CALL,runtime leaf $meth \t// postalloc expanded" %}
13134   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
13135 %}
13136 
13137 // Call runtime without safepoint - same as CallLeaf.
13138 // postalloc expand of CallLeafNoFPDirect.
13139 // Load adress to call from TOC, then bl to it.
13140 instruct CallLeafNoFPDirect_Ex(method meth) %{
13141   match(CallLeafNoFP);
13142   effect(USE meth);
13143   ins_cost(CALL_COST);
13144 
13145   // Enc_java_to_runtime_call needs up to 3 constants: call target,
13146   // env for callee, C-toc.
13147   ins_num_consts(3);
13148 
13149   format %{ "CALL,runtime leaf nofp $meth \t// postalloc expanded" %}
13150   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
13151 %}
13152 
13153 // Tail Call; Jump from runtime stub to Java code.
13154 // Also known as an 'interprocedural jump'.
13155 // Target of jump will eventually return to caller.
13156 // TailJump below removes the return address.
13157 instruct TailCalljmpInd(iRegPdstNoScratch jump_target, inline_cache_regP method_oop) %{
13158   match(TailCall jump_target method_oop);
13159   ins_cost(CALL_COST);
13160 
13161   format %{ "MTCTR   $jump_target \t// $method_oop holds method oop\n\t"
13162             "BCTR         \t// tail call" %}
13163   size(8);
13164   ins_encode %{
13165     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13166     __ mtctr($jump_target$$Register);
13167     __ bctr();
13168   %}
13169   ins_pipe(pipe_class_call);
13170 %}
13171 
13172 // Return Instruction
13173 instruct Ret() %{
13174   match(Return);
13175   format %{ "BLR      \t// branch to link register" %}
13176   size(4);
13177   ins_encode %{
13178     // TODO: PPC port $archOpcode(ppc64Opcode_blr);
13179     // LR is restored in MachEpilogNode. Just do the RET here.
13180     __ blr();
13181   %}
13182   ins_pipe(pipe_class_default);
13183 %}
13184 
13185 // Tail Jump; remove the return address; jump to target.
13186 // TailCall above leaves the return address around.
13187 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
13188 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
13189 // "restore" before this instruction (in Epilogue), we need to materialize it
13190 // in %i0.
13191 instruct tailjmpInd(iRegPdstNoScratch jump_target, rarg1RegP ex_oop) %{
13192   match(TailJump jump_target ex_oop);
13193   ins_cost(CALL_COST);
13194 
13195   format %{ "LD      R4_ARG2 = LR\n\t"
13196             "MTCTR   $jump_target\n\t"
13197             "BCTR     \t// TailJump, exception oop: $ex_oop" %}
13198   size(12);
13199   ins_encode %{
13200     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13201     __ ld(R4_ARG2/* issuing pc */, _abi(lr), R1_SP);
13202     __ mtctr($jump_target$$Register);
13203     __ bctr();
13204   %}
13205   ins_pipe(pipe_class_call);
13206 %}
13207 
13208 // Create exception oop: created by stack-crawling runtime code.
13209 // Created exception is now available to this handler, and is setup
13210 // just prior to jumping to this handler. No code emitted.
13211 instruct CreateException(rarg1RegP ex_oop) %{
13212   match(Set ex_oop (CreateEx));
13213   ins_cost(0);
13214 
13215   format %{ " -- \t// exception oop; no code emitted" %}
13216   size(0);
13217   ins_encode( /*empty*/ );
13218   ins_pipe(pipe_class_default);
13219 %}
13220 
13221 // Rethrow exception: The exception oop will come in the first
13222 // argument position. Then JUMP (not call) to the rethrow stub code.
13223 instruct RethrowException() %{
13224   match(Rethrow);
13225   ins_cost(CALL_COST);
13226 
13227   format %{ "Jmp     rethrow_stub" %}
13228   ins_encode %{
13229     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13230     cbuf.set_insts_mark();
13231     __ b64_patchable((address)OptoRuntime::rethrow_stub(), relocInfo::runtime_call_type);
13232   %}
13233   ins_pipe(pipe_class_call);
13234 %}
13235 
13236 // Die now.
13237 instruct ShouldNotReachHere() %{
13238   match(Halt);
13239   ins_cost(CALL_COST);
13240 
13241   format %{ "ShouldNotReachHere" %}
13242   size(4);
13243   ins_encode %{
13244     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
13245     __ trap_should_not_reach_here();
13246   %}
13247   ins_pipe(pipe_class_default);
13248 %}
13249 
13250 // This name is KNOWN by the ADLC and cannot be changed.  The ADLC
13251 // forces a 'TypeRawPtr::BOTTOM' output type for this guy.
13252 // Get a DEF on threadRegP, no costs, no encoding, use
13253 // 'ins_should_rematerialize(true)' to avoid spilling.
13254 instruct tlsLoadP(threadRegP dst) %{
13255   match(Set dst (ThreadLocal));
13256   ins_cost(0);
13257 
13258   ins_should_rematerialize(true);
13259 
13260   format %{ " -- \t// $dst=Thread::current(), empty" %}
13261   size(0);
13262   ins_encode( /*empty*/ );
13263   ins_pipe(pipe_class_empty);
13264 %}
13265 
13266 //---Some PPC specific nodes---------------------------------------------------
13267 
13268 // Stop a group.
13269 instruct endGroup() %{
13270   ins_cost(0);
13271 
13272   ins_is_nop(true);
13273 
13274   format %{ "End Bundle (ori r1, r1, 0)" %}
13275   size(4);
13276   ins_encode %{
13277     // TODO: PPC port $archOpcode(ppc64Opcode_endgroup);
13278     __ endgroup();
13279   %}
13280   ins_pipe(pipe_class_default);
13281 %}
13282 
13283 // Nop instructions
13284 
13285 instruct fxNop() %{
13286   ins_cost(0);
13287 
13288   ins_is_nop(true);
13289 
13290   format %{ "fxNop" %}
13291   size(4);
13292   ins_encode %{
13293     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
13294     __ nop();
13295   %}
13296   ins_pipe(pipe_class_default);
13297 %}
13298 
13299 instruct fpNop0() %{
13300   ins_cost(0);
13301 
13302   ins_is_nop(true);
13303 
13304   format %{ "fpNop0" %}
13305   size(4);
13306   ins_encode %{
13307     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
13308     __ fpnop0();
13309   %}
13310   ins_pipe(pipe_class_default);
13311 %}
13312 
13313 instruct fpNop1() %{
13314   ins_cost(0);
13315 
13316   ins_is_nop(true);
13317 
13318   format %{ "fpNop1" %}
13319   size(4);
13320   ins_encode %{
13321     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
13322     __ fpnop1();
13323   %}
13324   ins_pipe(pipe_class_default);
13325 %}
13326 
13327 instruct brNop0() %{
13328   ins_cost(0);
13329   size(4);
13330   format %{ "brNop0" %}
13331   ins_encode %{
13332     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
13333     __ brnop0();
13334   %}
13335   ins_is_nop(true);
13336   ins_pipe(pipe_class_default);
13337 %}
13338 
13339 instruct brNop1() %{
13340   ins_cost(0);
13341 
13342   ins_is_nop(true);
13343 
13344   format %{ "brNop1" %}
13345   size(4);
13346   ins_encode %{
13347     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
13348     __ brnop1();
13349   %}
13350   ins_pipe(pipe_class_default);
13351 %}
13352 
13353 instruct brNop2() %{
13354   ins_cost(0);
13355 
13356   ins_is_nop(true);
13357 
13358   format %{ "brNop2" %}
13359   size(4);
13360   ins_encode %{
13361     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
13362     __ brnop2();
13363   %}
13364   ins_pipe(pipe_class_default);
13365 %}
13366 
13367 //----------PEEPHOLE RULES-----------------------------------------------------
13368 // These must follow all instruction definitions as they use the names
13369 // defined in the instructions definitions.
13370 //
13371 // peepmatch ( root_instr_name [preceeding_instruction]* );
13372 //
13373 // peepconstraint %{
13374 // (instruction_number.operand_name relational_op instruction_number.operand_name
13375 //  [, ...] );
13376 // // instruction numbers are zero-based using left to right order in peepmatch
13377 //
13378 // peepreplace ( instr_name ( [instruction_number.operand_name]* ) );
13379 // // provide an instruction_number.operand_name for each operand that appears
13380 // // in the replacement instruction's match rule
13381 //
13382 // ---------VM FLAGS---------------------------------------------------------
13383 //
13384 // All peephole optimizations can be turned off using -XX:-OptoPeephole
13385 //
13386 // Each peephole rule is given an identifying number starting with zero and
13387 // increasing by one in the order seen by the parser. An individual peephole
13388 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
13389 // on the command-line.
13390 //
13391 // ---------CURRENT LIMITATIONS----------------------------------------------
13392 //
13393 // Only match adjacent instructions in same basic block
13394 // Only equality constraints
13395 // Only constraints between operands, not (0.dest_reg == EAX_enc)
13396 // Only one replacement instruction
13397 //
13398 // ---------EXAMPLE----------------------------------------------------------
13399 //
13400 // // pertinent parts of existing instructions in architecture description
13401 // instruct movI(eRegI dst, eRegI src) %{
13402 //   match(Set dst (CopyI src));
13403 // %}
13404 //
13405 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
13406 //   match(Set dst (AddI dst src));
13407 //   effect(KILL cr);
13408 // %}
13409 //
13410 // // Change (inc mov) to lea
13411 // peephole %{
13412 //   // increment preceeded by register-register move
13413 //   peepmatch ( incI_eReg movI );
13414 //   // require that the destination register of the increment
13415 //   // match the destination register of the move
13416 //   peepconstraint ( 0.dst == 1.dst );
13417 //   // construct a replacement instruction that sets
13418 //   // the destination to ( move's source register + one )
13419 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13420 // %}
13421 //
13422 // Implementation no longer uses movX instructions since
13423 // machine-independent system no longer uses CopyX nodes.
13424 //
13425 // peephole %{
13426 //   peepmatch ( incI_eReg movI );
13427 //   peepconstraint ( 0.dst == 1.dst );
13428 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13429 // %}
13430 //
13431 // peephole %{
13432 //   peepmatch ( decI_eReg movI );
13433 //   peepconstraint ( 0.dst == 1.dst );
13434 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13435 // %}
13436 //
13437 // peephole %{
13438 //   peepmatch ( addI_eReg_imm movI );
13439 //   peepconstraint ( 0.dst == 1.dst );
13440 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13441 // %}
13442 //
13443 // peephole %{
13444 //   peepmatch ( addP_eReg_imm movP );
13445 //   peepconstraint ( 0.dst == 1.dst );
13446 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
13447 // %}
13448 
13449 // // Change load of spilled value to only a spill
13450 // instruct storeI(memory mem, eRegI src) %{
13451 //   match(Set mem (StoreI mem src));
13452 // %}
13453 //
13454 // instruct loadI(eRegI dst, memory mem) %{
13455 //   match(Set dst (LoadI mem));
13456 // %}
13457 //
13458 peephole %{
13459   peepmatch ( loadI storeI );
13460   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
13461   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
13462 %}
13463 
13464 peephole %{
13465   peepmatch ( loadL storeL );
13466   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
13467   peepreplace ( storeL( 1.mem 1.mem 1.src ) );
13468 %}
13469 
13470 peephole %{
13471   peepmatch ( loadP storeP );
13472   peepconstraint ( 1.src == 0.dst, 1.dst == 0.mem );
13473   peepreplace ( storeP( 1.dst 1.dst 1.src ) );
13474 %}
13475 
13476 //----------SMARTSPILL RULES---------------------------------------------------
13477 // These must follow all instruction definitions as they use the names
13478 // defined in the instructions definitions.
</pre></body></html>
