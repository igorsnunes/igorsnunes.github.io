<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/os/windows/vm/os_windows.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // Must be at least Windows Vista or Server 2008 to use InitOnceExecuteOnce
  26 #define _WIN32_WINNT 0x0600
  27 
  28 // no precompiled headers
  29 #include "classfile/classLoader.hpp"
  30 #include "classfile/systemDictionary.hpp"
  31 #include "classfile/vmSymbols.hpp"
  32 #include "code/icBuffer.hpp"
  33 #include "code/vtableStubs.hpp"
  34 #include "compiler/compileBroker.hpp"
  35 #include "compiler/disassembler.hpp"
  36 #include "interpreter/interpreter.hpp"
  37 #include "jvm_windows.h"
  38 #include "logging/log.hpp"
  39 #include "memory/allocation.inline.hpp"
  40 #include "memory/filemap.hpp"
  41 #include "oops/oop.inline.hpp"
  42 #include "os_share_windows.hpp"
  43 #include "os_windows.inline.hpp"
  44 #include "prims/jniFastGetField.hpp"
  45 #include "prims/jvm.h"
  46 #include "prims/jvm_misc.hpp"
  47 #include "runtime/arguments.hpp"
  48 #include "runtime/atomic.hpp"
  49 #include "runtime/extendedPC.hpp"
  50 #include "runtime/globals.hpp"
  51 #include "runtime/interfaceSupport.hpp"
  52 #include "runtime/java.hpp"
  53 #include "runtime/javaCalls.hpp"
  54 #include "runtime/mutexLocker.hpp"
  55 #include "runtime/objectMonitor.hpp"
  56 #include "runtime/orderAccess.inline.hpp"
  57 #include "runtime/osThread.hpp"
  58 #include "runtime/perfMemory.hpp"
  59 #include "runtime/sharedRuntime.hpp"
  60 #include "runtime/statSampler.hpp"
  61 #include "runtime/stubRoutines.hpp"
  62 #include "runtime/thread.inline.hpp"
  63 #include "runtime/threadCritical.hpp"
  64 #include "runtime/timer.hpp"
  65 #include "runtime/vm_version.hpp"
  66 #include "semaphore_windows.hpp"
  67 #include "services/attachListener.hpp"
  68 #include "services/memTracker.hpp"
  69 #include "services/runtimeService.hpp"
  70 #include "utilities/decoder.hpp"
  71 #include "utilities/defaultStream.hpp"
  72 #include "utilities/events.hpp"
  73 #include "utilities/growableArray.hpp"
  74 #include "utilities/macros.hpp"
  75 #include "utilities/vmError.hpp"
  76 
  77 #ifdef _DEBUG
  78 #include &lt;crtdbg.h&gt;
  79 #endif
  80 
  81 
  82 #include &lt;windows.h&gt;
  83 #include &lt;sys/types.h&gt;
  84 #include &lt;sys/stat.h&gt;
  85 #include &lt;sys/timeb.h&gt;
  86 #include &lt;objidl.h&gt;
  87 #include &lt;shlobj.h&gt;
  88 
  89 #include &lt;malloc.h&gt;
  90 #include &lt;signal.h&gt;
  91 #include &lt;direct.h&gt;
  92 #include &lt;errno.h&gt;
  93 #include &lt;fcntl.h&gt;
  94 #include &lt;io.h&gt;
  95 #include &lt;process.h&gt;              // For _beginthreadex(), _endthreadex()
  96 #include &lt;imagehlp.h&gt;             // For os::dll_address_to_function_name
  97 // for enumerating dll libraries
  98 #include &lt;vdmdbg.h&gt;
  99 
 100 // for timer info max values which include all bits
 101 #define ALL_64_BITS CONST64(-1)
 102 
 103 // For DLL loading/load error detection
 104 // Values of PE COFF
 105 #define IMAGE_FILE_PTR_TO_SIGNATURE 0x3c
 106 #define IMAGE_FILE_SIGNATURE_LENGTH 4
 107 
 108 static HANDLE main_process;
 109 static HANDLE main_thread;
 110 static int    main_thread_id;
 111 
 112 static FILETIME process_creation_time;
 113 static FILETIME process_exit_time;
 114 static FILETIME process_user_time;
 115 static FILETIME process_kernel_time;
 116 
 117 #ifdef _M_IA64
 118   #define __CPU__ ia64
 119 #else
 120   #ifdef _M_AMD64
 121     #define __CPU__ amd64
 122   #else
 123     #define __CPU__ i486
 124   #endif
 125 #endif
 126 
 127 // save DLL module handle, used by GetModuleFileName
 128 
 129 HINSTANCE vm_lib_handle;
 130 
 131 BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved) {
 132   switch (reason) {
 133   case DLL_PROCESS_ATTACH:
 134     vm_lib_handle = hinst;
 135     if (ForceTimeHighResolution) {
 136       timeBeginPeriod(1L);
 137     }
 138     break;
 139   case DLL_PROCESS_DETACH:
 140     if (ForceTimeHighResolution) {
 141       timeEndPeriod(1L);
 142     }
 143     break;
 144   default:
 145     break;
 146   }
 147   return true;
 148 }
 149 
 150 static inline double fileTimeAsDouble(FILETIME* time) {
 151   const double high  = (double) ((unsigned int) ~0);
 152   const double split = 10000000.0;
 153   double result = (time-&gt;dwLowDateTime / split) +
 154                    time-&gt;dwHighDateTime * (high/split);
 155   return result;
 156 }
 157 
 158 // Implementation of os
 159 
 160 bool os::unsetenv(const char* name) {
 161   assert(name != NULL, "Null pointer");
 162   return (SetEnvironmentVariable(name, NULL) == TRUE);
 163 }
 164 
 165 // No setuid programs under Windows.
 166 bool os::have_special_privileges() {
 167   return false;
 168 }
 169 
 170 
 171 // This method is  a periodic task to check for misbehaving JNI applications
 172 // under CheckJNI, we can add any periodic checks here.
 173 // For Windows at the moment does nothing
 174 void os::run_periodic_checks() {
 175   return;
 176 }
 177 
 178 // previous UnhandledExceptionFilter, if there is one
 179 static LPTOP_LEVEL_EXCEPTION_FILTER prev_uef_handler = NULL;
 180 
 181 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo);
 182 
 183 void os::init_system_properties_values() {
 184   // sysclasspath, java_home, dll_dir
 185   {
 186     char *home_path;
 187     char *dll_path;
 188     char *pslash;
 189     char *bin = "\\bin";
 190     char home_dir[MAX_PATH + 1];
 191     char *alt_home_dir = ::getenv("_ALT_JAVA_HOME_DIR");
 192 
 193     if (alt_home_dir != NULL)  {
 194       strncpy(home_dir, alt_home_dir, MAX_PATH + 1);
 195       home_dir[MAX_PATH] = '\0';
 196     } else {
 197       os::jvm_path(home_dir, sizeof(home_dir));
 198       // Found the full path to jvm.dll.
 199       // Now cut the path to &lt;java_home&gt;/jre if we can.
 200       *(strrchr(home_dir, '\\')) = '\0';  // get rid of \jvm.dll
 201       pslash = strrchr(home_dir, '\\');
 202       if (pslash != NULL) {
 203         *pslash = '\0';                   // get rid of \{client|server}
 204         pslash = strrchr(home_dir, '\\');
 205         if (pslash != NULL) {
 206           *pslash = '\0';                 // get rid of \bin
 207         }
 208       }
 209     }
 210 
 211     home_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + 1, mtInternal);
 212     if (home_path == NULL) {
 213       return;
 214     }
 215     strcpy(home_path, home_dir);
 216     Arguments::set_java_home(home_path);
 217     FREE_C_HEAP_ARRAY(char, home_path);
 218 
 219     dll_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + strlen(bin) + 1,
 220                                 mtInternal);
 221     if (dll_path == NULL) {
 222       return;
 223     }
 224     strcpy(dll_path, home_dir);
 225     strcat(dll_path, bin);
 226     Arguments::set_dll_dir(dll_path);
 227     FREE_C_HEAP_ARRAY(char, dll_path);
 228 
 229     if (!set_boot_path('\\', ';')) {
 230       return;
 231     }
 232   }
 233 
 234 // library_path
 235 #define EXT_DIR "\\lib\\ext"
 236 #define BIN_DIR "\\bin"
 237 #define PACKAGE_DIR "\\Sun\\Java"
 238   {
 239     // Win32 library search order (See the documentation for LoadLibrary):
 240     //
 241     // 1. The directory from which application is loaded.
 242     // 2. The system wide Java Extensions directory (Java only)
 243     // 3. System directory (GetSystemDirectory)
 244     // 4. Windows directory (GetWindowsDirectory)
 245     // 5. The PATH environment variable
 246     // 6. The current directory
 247 
 248     char *library_path;
 249     char tmp[MAX_PATH];
 250     char *path_str = ::getenv("PATH");
 251 
 252     library_path = NEW_C_HEAP_ARRAY(char, MAX_PATH * 5 + sizeof(PACKAGE_DIR) +
 253                                     sizeof(BIN_DIR) + (path_str ? strlen(path_str) : 0) + 10, mtInternal);
 254 
 255     library_path[0] = '\0';
 256 
 257     GetModuleFileName(NULL, tmp, sizeof(tmp));
 258     *(strrchr(tmp, '\\')) = '\0';
 259     strcat(library_path, tmp);
 260 
 261     GetWindowsDirectory(tmp, sizeof(tmp));
 262     strcat(library_path, ";");
 263     strcat(library_path, tmp);
 264     strcat(library_path, PACKAGE_DIR BIN_DIR);
 265 
 266     GetSystemDirectory(tmp, sizeof(tmp));
 267     strcat(library_path, ";");
 268     strcat(library_path, tmp);
 269 
 270     GetWindowsDirectory(tmp, sizeof(tmp));
 271     strcat(library_path, ";");
 272     strcat(library_path, tmp);
 273 
 274     if (path_str) {
 275       strcat(library_path, ";");
 276       strcat(library_path, path_str);
 277     }
 278 
 279     strcat(library_path, ";.");
 280 
 281     Arguments::set_library_path(library_path);
 282     FREE_C_HEAP_ARRAY(char, library_path);
 283   }
 284 
 285   // Default extensions directory
 286   {
 287     char path[MAX_PATH];
 288     char buf[2 * MAX_PATH + 2 * sizeof(EXT_DIR) + sizeof(PACKAGE_DIR) + 1];
 289     GetWindowsDirectory(path, MAX_PATH);
 290     sprintf(buf, "%s%s;%s%s%s", Arguments::get_java_home(), EXT_DIR,
 291             path, PACKAGE_DIR, EXT_DIR);
 292     Arguments::set_ext_dirs(buf);
 293   }
 294   #undef EXT_DIR
 295   #undef BIN_DIR
 296   #undef PACKAGE_DIR
 297 
 298 #ifndef _WIN64
 299   // set our UnhandledExceptionFilter and save any previous one
 300   prev_uef_handler = SetUnhandledExceptionFilter(Handle_FLT_Exception);
 301 #endif
 302 
 303   // Done
 304   return;
 305 }
 306 
 307 void os::breakpoint() {
 308   DebugBreak();
 309 }
 310 
 311 // Invoked from the BREAKPOINT Macro
 312 extern "C" void breakpoint() {
 313   os::breakpoint();
 314 }
 315 
 316 // RtlCaptureStackBackTrace Windows API may not exist prior to Windows XP.
 317 // So far, this method is only used by Native Memory Tracking, which is
 318 // only supported on Windows XP or later.
 319 //
 320 int os::get_native_stack(address* stack, int frames, int toSkip) {
 321   int captured = RtlCaptureStackBackTrace(toSkip + 1, frames, (PVOID*)stack, NULL);
 322   for (int index = captured; index &lt; frames; index ++) {
 323     stack[index] = NULL;
 324   }
 325   return captured;
 326 }
 327 
 328 
 329 // os::current_stack_base()
 330 //
 331 //   Returns the base of the stack, which is the stack's
 332 //   starting address.  This function must be called
 333 //   while running on the stack of the thread being queried.
 334 
 335 address os::current_stack_base() {
 336   MEMORY_BASIC_INFORMATION minfo;
 337   address stack_bottom;
 338   size_t stack_size;
 339 
 340   VirtualQuery(&amp;minfo, &amp;minfo, sizeof(minfo));
 341   stack_bottom =  (address)minfo.AllocationBase;
 342   stack_size = minfo.RegionSize;
 343 
 344   // Add up the sizes of all the regions with the same
 345   // AllocationBase.
 346   while (1) {
 347     VirtualQuery(stack_bottom+stack_size, &amp;minfo, sizeof(minfo));
 348     if (stack_bottom == (address)minfo.AllocationBase) {
 349       stack_size += minfo.RegionSize;
 350     } else {
 351       break;
 352     }
 353   }
 354 
 355 #ifdef _M_IA64
 356   // IA64 has memory and register stacks
 357   //
 358   // This is the stack layout you get on NT/IA64 if you specify 1MB stack limit
 359   // at thread creation (1MB backing store growing upwards, 1MB memory stack
 360   // growing downwards, 2MB summed up)
 361   //
 362   // ...
 363   // ------- top of stack (high address) -----
 364   // |
 365   // |      1MB
 366   // |      Backing Store (Register Stack)
 367   // |
 368   // |         / \
 369   // |          |
 370   // |          |
 371   // |          |
 372   // ------------------------ stack base -----
 373   // |      1MB
 374   // |      Memory Stack
 375   // |
 376   // |          |
 377   // |          |
 378   // |          |
 379   // |         \ /
 380   // |
 381   // ----- bottom of stack (low address) -----
 382   // ...
 383 
 384   stack_size = stack_size / 2;
 385 #endif
 386   return stack_bottom + stack_size;
 387 }
 388 
 389 size_t os::current_stack_size() {
 390   size_t sz;
 391   MEMORY_BASIC_INFORMATION minfo;
 392   VirtualQuery(&amp;minfo, &amp;minfo, sizeof(minfo));
 393   sz = (size_t)os::current_stack_base() - (size_t)minfo.AllocationBase;
 394   return sz;
 395 }
 396 
 397 struct tm* os::localtime_pd(const time_t* clock, struct tm* res) {
 398   const struct tm* time_struct_ptr = localtime(clock);
 399   if (time_struct_ptr != NULL) {
 400     *res = *time_struct_ptr;
 401     return res;
 402   }
 403   return NULL;
 404 }
 405 
 406 LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo);
 407 
 408 // Thread start routine for all newly created threads
 409 static unsigned __stdcall thread_native_entry(Thread* thread) {
 410   // Try to randomize the cache line index of hot stack frames.
 411   // This helps when threads of the same stack traces evict each other's
 412   // cache lines. The threads can be either from the same JVM instance, or
 413   // from different JVM instances. The benefit is especially true for
 414   // processors with hyperthreading technology.
 415   static int counter = 0;
 416   int pid = os::current_process_id();
 417   _alloca(((pid ^ counter++) &amp; 7) * 128);
 418 
 419   thread-&gt;initialize_thread_current();
 420 
 421   OSThread* osthr = thread-&gt;osthread();
 422   assert(osthr-&gt;get_state() == RUNNABLE, "invalid os thread state");
 423 
 424   if (UseNUMA) {
 425     int lgrp_id = os::numa_get_group_id();
 426     if (lgrp_id != -1) {
 427       thread-&gt;set_lgrp_id(lgrp_id);
 428     }
 429   }
 430 
 431   // Diagnostic code to investigate JDK-6573254
 432   int res = 30115;  // non-java thread
 433   if (thread-&gt;is_Java_thread()) {
 434     res = 20115;    // java thread
 435   }
 436 
 437   log_info(os, thread)("Thread is alive (tid: " UINTX_FORMAT ").", os::current_thread_id());
 438 
 439   // Install a win32 structured exception handler around every thread created
 440   // by VM, so VM can generate error dump when an exception occurred in non-
 441   // Java thread (e.g. VM thread).
 442   __try {
 443     thread-&gt;run();
 444   } __except(topLevelExceptionFilter(
 445                                      (_EXCEPTION_POINTERS*)_exception_info())) {
 446     // Nothing to do.
 447   }
 448 
 449   log_info(os, thread)("Thread finished (tid: " UINTX_FORMAT ").", os::current_thread_id());
 450 
 451   // One less thread is executing
 452   // When the VMThread gets here, the main thread may have already exited
 453   // which frees the CodeHeap containing the Atomic::add code
 454   if (thread != VMThread::vm_thread() &amp;&amp; VMThread::vm_thread() != NULL) {
 455     Atomic::dec_ptr((intptr_t*)&amp;os::win32::_os_thread_count);
 456   }
 457 
 458   // If a thread has not deleted itself ("delete this") as part of its
 459   // termination sequence, we have to ensure thread-local-storage is
 460   // cleared before we actually terminate. No threads should ever be
 461   // deleted asynchronously with respect to their termination.
 462   if (Thread::current_or_null_safe() != NULL) {
 463     assert(Thread::current_or_null_safe() == thread, "current thread is wrong");
 464     thread-&gt;clear_thread_current();
 465   }
 466 
 467   // Thread must not return from exit_process_or_thread(), but if it does,
 468   // let it proceed to exit normally
 469   return (unsigned)os::win32::exit_process_or_thread(os::win32::EPT_THREAD, res);
 470 }
 471 
 472 static OSThread* create_os_thread(Thread* thread, HANDLE thread_handle,
 473                                   int thread_id) {
 474   // Allocate the OSThread object
 475   OSThread* osthread = new OSThread(NULL, NULL);
 476   if (osthread == NULL) return NULL;
 477 
 478   // Initialize support for Java interrupts
 479   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 480   if (interrupt_event == NULL) {
 481     delete osthread;
 482     return NULL;
 483   }
 484   osthread-&gt;set_interrupt_event(interrupt_event);
 485 
 486   // Store info on the Win32 thread into the OSThread
 487   osthread-&gt;set_thread_handle(thread_handle);
 488   osthread-&gt;set_thread_id(thread_id);
 489 
 490   if (UseNUMA) {
 491     int lgrp_id = os::numa_get_group_id();
 492     if (lgrp_id != -1) {
 493       thread-&gt;set_lgrp_id(lgrp_id);
 494     }
 495   }
 496 
 497   // Initial thread state is INITIALIZED, not SUSPENDED
 498   osthread-&gt;set_state(INITIALIZED);
 499 
 500   return osthread;
 501 }
 502 
 503 
 504 bool os::create_attached_thread(JavaThread* thread) {
 505 #ifdef ASSERT
 506   thread-&gt;verify_not_published();
 507 #endif
 508   HANDLE thread_h;
 509   if (!DuplicateHandle(main_process, GetCurrentThread(), GetCurrentProcess(),
 510                        &amp;thread_h, THREAD_ALL_ACCESS, false, 0)) {
 511     fatal("DuplicateHandle failed\n");
 512   }
 513   OSThread* osthread = create_os_thread(thread, thread_h,
 514                                         (int)current_thread_id());
 515   if (osthread == NULL) {
 516     return false;
 517   }
 518 
 519   // Initial thread state is RUNNABLE
 520   osthread-&gt;set_state(RUNNABLE);
 521 
 522   thread-&gt;set_osthread(osthread);
 523 
 524   log_info(os, thread)("Thread attached (tid: " UINTX_FORMAT ").",
 525     os::current_thread_id());
 526 
 527   return true;
 528 }
 529 
 530 bool os::create_main_thread(JavaThread* thread) {
 531 #ifdef ASSERT
 532   thread-&gt;verify_not_published();
 533 #endif
 534   if (_starting_thread == NULL) {
 535     _starting_thread = create_os_thread(thread, main_thread, main_thread_id);
 536     if (_starting_thread == NULL) {
 537       return false;
 538     }
 539   }
 540 
 541   // The primordial thread is runnable from the start)
 542   _starting_thread-&gt;set_state(RUNNABLE);
 543 
 544   thread-&gt;set_osthread(_starting_thread);
 545   return true;
 546 }
 547 
 548 // Helper function to trace _beginthreadex attributes,
 549 //  similar to os::Posix::describe_pthread_attr()
 550 static char* describe_beginthreadex_attributes(char* buf, size_t buflen,
 551                                                size_t stacksize, unsigned initflag) {
 552   stringStream ss(buf, buflen);
 553   if (stacksize == 0) {
 554     ss.print("stacksize: default, ");
 555   } else {
 556     ss.print("stacksize: " SIZE_FORMAT "k, ", stacksize / 1024);
 557   }
 558   ss.print("flags: ");
 559   #define PRINT_FLAG(f) if (initflag &amp; f) ss.print( #f " ");
 560   #define ALL(X) \
 561     X(CREATE_SUSPENDED) \
 562     X(STACK_SIZE_PARAM_IS_A_RESERVATION)
 563   ALL(PRINT_FLAG)
 564   #undef ALL
 565   #undef PRINT_FLAG
 566   return buf;
 567 }
 568 
 569 // Allocate and initialize a new OSThread
 570 bool os::create_thread(Thread* thread, ThreadType thr_type,
 571                        size_t stack_size) {
 572   unsigned thread_id;
 573 
 574   // Allocate the OSThread object
 575   OSThread* osthread = new OSThread(NULL, NULL);
 576   if (osthread == NULL) {
 577     return false;
 578   }
 579 
 580   // Initialize support for Java interrupts
 581   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 582   if (interrupt_event == NULL) {
 583     delete osthread;
 584     return NULL;
 585   }
 586   osthread-&gt;set_interrupt_event(interrupt_event);
 587   osthread-&gt;set_interrupted(false);
 588 
 589   thread-&gt;set_osthread(osthread);
 590 
 591   if (stack_size == 0) {
 592     switch (thr_type) {
 593     case os::java_thread:
 594       // Java threads use ThreadStackSize which default value can be changed with the flag -Xss
 595       if (JavaThread::stack_size_at_create() &gt; 0) {
 596         stack_size = JavaThread::stack_size_at_create();
 597       }
 598       break;
 599     case os::compiler_thread:
 600       if (CompilerThreadStackSize &gt; 0) {
 601         stack_size = (size_t)(CompilerThreadStackSize * K);
 602         break;
 603       } // else fall through:
 604         // use VMThreadStackSize if CompilerThreadStackSize is not defined
 605     case os::vm_thread:
 606     case os::pgc_thread:
 607     case os::cgc_thread:
 608     case os::watcher_thread:
 609       if (VMThreadStackSize &gt; 0) stack_size = (size_t)(VMThreadStackSize * K);
 610       break;
 611     }
 612   }
 613 
 614   // Create the Win32 thread
 615   //
 616   // Contrary to what MSDN document says, "stack_size" in _beginthreadex()
 617   // does not specify stack size. Instead, it specifies the size of
 618   // initially committed space. The stack size is determined by
 619   // PE header in the executable. If the committed "stack_size" is larger
 620   // than default value in the PE header, the stack is rounded up to the
 621   // nearest multiple of 1MB. For example if the launcher has default
 622   // stack size of 320k, specifying any size less than 320k does not
 623   // affect the actual stack size at all, it only affects the initial
 624   // commitment. On the other hand, specifying 'stack_size' larger than
 625   // default value may cause significant increase in memory usage, because
 626   // not only the stack space will be rounded up to MB, but also the
 627   // entire space is committed upfront.
 628   //
 629   // Finally Windows XP added a new flag 'STACK_SIZE_PARAM_IS_A_RESERVATION'
 630   // for CreateThread() that can treat 'stack_size' as stack size. However we
 631   // are not supposed to call CreateThread() directly according to MSDN
 632   // document because JVM uses C runtime library. The good news is that the
 633   // flag appears to work with _beginthredex() as well.
 634 
 635   const unsigned initflag = CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION;
 636   HANDLE thread_handle =
 637     (HANDLE)_beginthreadex(NULL,
 638                            (unsigned)stack_size,
 639                            (unsigned (__stdcall *)(void*)) thread_native_entry,
 640                            thread,
 641                            initflag,
 642                            &amp;thread_id);
 643 
 644   char buf[64];
 645   if (thread_handle != NULL) {
 646     log_info(os, thread)("Thread started (tid: %u, attributes: %s)",
 647       thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 648   } else {
 649     log_warning(os, thread)("Failed to start thread - _beginthreadex failed (%s) for attributes: %s.",
 650       os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 651   }
 652 
 653   if (thread_handle == NULL) {
 654     // Need to clean up stuff we've allocated so far
 655     CloseHandle(osthread-&gt;interrupt_event());
 656     thread-&gt;set_osthread(NULL);
 657     delete osthread;
 658     return NULL;
 659   }
 660 
 661   Atomic::inc_ptr((intptr_t*)&amp;os::win32::_os_thread_count);
 662 
 663   // Store info on the Win32 thread into the OSThread
 664   osthread-&gt;set_thread_handle(thread_handle);
 665   osthread-&gt;set_thread_id(thread_id);
 666 
 667   // Initial thread state is INITIALIZED, not SUSPENDED
 668   osthread-&gt;set_state(INITIALIZED);
 669 
 670   // The thread is returned suspended (in state INITIALIZED), and is started higher up in the call chain
 671   return true;
 672 }
 673 
 674 
 675 // Free Win32 resources related to the OSThread
 676 void os::free_thread(OSThread* osthread) {
 677   assert(osthread != NULL, "osthread not set");
 678 
 679   // We are told to free resources of the argument thread,
 680   // but we can only really operate on the current thread.
 681   assert(Thread::current()-&gt;osthread() == osthread,
 682          "os::free_thread but not current thread");
 683 
 684   CloseHandle(osthread-&gt;thread_handle());
 685   CloseHandle(osthread-&gt;interrupt_event());
 686   delete osthread;
 687 }
 688 
 689 static jlong first_filetime;
 690 static jlong initial_performance_count;
 691 static jlong performance_frequency;
 692 
 693 
 694 jlong as_long(LARGE_INTEGER x) {
 695   jlong result = 0; // initialization to avoid warning
 696   set_high(&amp;result, x.HighPart);
 697   set_low(&amp;result, x.LowPart);
 698   return result;
 699 }
 700 
 701 
 702 jlong os::elapsed_counter() {
 703   LARGE_INTEGER count;
 704   QueryPerformanceCounter(&amp;count);
 705   return as_long(count) - initial_performance_count;
 706 }
 707 
 708 
 709 jlong os::elapsed_frequency() {
 710   return performance_frequency;
 711 }
 712 
 713 
 714 julong os::available_memory() {
 715   return win32::available_memory();
 716 }
 717 
 718 julong os::win32::available_memory() {
 719   // Use GlobalMemoryStatusEx() because GlobalMemoryStatus() may return incorrect
 720   // value if total memory is larger than 4GB
 721   MEMORYSTATUSEX ms;
 722   ms.dwLength = sizeof(ms);
 723   GlobalMemoryStatusEx(&amp;ms);
 724 
 725   return (julong)ms.ullAvailPhys;
 726 }
 727 
 728 julong os::physical_memory() {
 729   return win32::physical_memory();
 730 }
 731 
 732 bool os::has_allocatable_memory_limit(julong* limit) {
 733   MEMORYSTATUSEX ms;
 734   ms.dwLength = sizeof(ms);
 735   GlobalMemoryStatusEx(&amp;ms);
 736 #ifdef _LP64
 737   *limit = (julong)ms.ullAvailVirtual;
 738   return true;
 739 #else
 740   // Limit to 1400m because of the 2gb address space wall
 741   *limit = MIN2((julong)1400*M, (julong)ms.ullAvailVirtual);
 742   return true;
 743 #endif
 744 }
 745 
 746 int os::active_processor_count() {
 747   DWORD_PTR lpProcessAffinityMask = 0;
 748   DWORD_PTR lpSystemAffinityMask = 0;
 749   int proc_count = processor_count();
 750   if (proc_count &lt;= sizeof(UINT_PTR) * BitsPerByte &amp;&amp;
 751       GetProcessAffinityMask(GetCurrentProcess(), &amp;lpProcessAffinityMask, &amp;lpSystemAffinityMask)) {
 752     // Nof active processors is number of bits in process affinity mask
 753     int bitcount = 0;
 754     while (lpProcessAffinityMask != 0) {
 755       lpProcessAffinityMask = lpProcessAffinityMask &amp; (lpProcessAffinityMask-1);
 756       bitcount++;
 757     }
 758     return bitcount;
 759   } else {
 760     return proc_count;
 761   }
 762 }
 763 
 764 void os::set_native_thread_name(const char *name) {
 765 
 766   // See: http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
 767   //
 768   // Note that unfortunately this only works if the process
 769   // is already attached to a debugger; debugger must observe
 770   // the exception below to show the correct name.
 771 
 772   const DWORD MS_VC_EXCEPTION = 0x406D1388;
 773   struct {
 774     DWORD dwType;     // must be 0x1000
 775     LPCSTR szName;    // pointer to name (in user addr space)
 776     DWORD dwThreadID; // thread ID (-1=caller thread)
 777     DWORD dwFlags;    // reserved for future use, must be zero
 778   } info;
 779 
 780   info.dwType = 0x1000;
 781   info.szName = name;
 782   info.dwThreadID = -1;
 783   info.dwFlags = 0;
 784 
 785   __try {
 786     RaiseException (MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(DWORD), (const ULONG_PTR*)&amp;info );
 787   } __except(EXCEPTION_CONTINUE_EXECUTION) {}
 788 }
 789 
 790 bool os::distribute_processes(uint length, uint* distribution) {
 791   // Not yet implemented.
 792   return false;
 793 }
 794 
 795 bool os::bind_to_processor(uint processor_id) {
 796   // Not yet implemented.
 797   return false;
 798 }
 799 
 800 void os::win32::initialize_performance_counter() {
 801   LARGE_INTEGER count;
 802   QueryPerformanceFrequency(&amp;count);
 803   performance_frequency = as_long(count);
 804   QueryPerformanceCounter(&amp;count);
 805   initial_performance_count = as_long(count);
 806 }
 807 
 808 
 809 double os::elapsedTime() {
 810   return (double) elapsed_counter() / (double) elapsed_frequency();
 811 }
 812 
 813 
 814 // Windows format:
 815 //   The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.
 816 // Java format:
 817 //   Java standards require the number of milliseconds since 1/1/1970
 818 
 819 // Constant offset - calculated using offset()
 820 static jlong  _offset   = 116444736000000000;
 821 // Fake time counter for reproducible results when debugging
 822 static jlong  fake_time = 0;
 823 
 824 #ifdef ASSERT
 825 // Just to be safe, recalculate the offset in debug mode
 826 static jlong _calculated_offset = 0;
 827 static int   _has_calculated_offset = 0;
 828 
 829 jlong offset() {
 830   if (_has_calculated_offset) return _calculated_offset;
 831   SYSTEMTIME java_origin;
 832   java_origin.wYear          = 1970;
 833   java_origin.wMonth         = 1;
 834   java_origin.wDayOfWeek     = 0; // ignored
 835   java_origin.wDay           = 1;
 836   java_origin.wHour          = 0;
 837   java_origin.wMinute        = 0;
 838   java_origin.wSecond        = 0;
 839   java_origin.wMilliseconds  = 0;
 840   FILETIME jot;
 841   if (!SystemTimeToFileTime(&amp;java_origin, &amp;jot)) {
 842     fatal("Error = %d\nWindows error", GetLastError());
 843   }
 844   _calculated_offset = jlong_from(jot.dwHighDateTime, jot.dwLowDateTime);
 845   _has_calculated_offset = 1;
 846   assert(_calculated_offset == _offset, "Calculated and constant time offsets must be equal");
 847   return _calculated_offset;
 848 }
 849 #else
 850 jlong offset() {
 851   return _offset;
 852 }
 853 #endif
 854 
 855 jlong windows_to_java_time(FILETIME wt) {
 856   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 857   return (a - offset()) / 10000;
 858 }
 859 
 860 // Returns time ticks in (10th of micro seconds)
 861 jlong windows_to_time_ticks(FILETIME wt) {
 862   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 863   return (a - offset());
 864 }
 865 
 866 FILETIME java_to_windows_time(jlong l) {
 867   jlong a = (l * 10000) + offset();
 868   FILETIME result;
 869   result.dwHighDateTime = high(a);
 870   result.dwLowDateTime  = low(a);
 871   return result;
 872 }
 873 
 874 bool os::supports_vtime() { return true; }
 875 bool os::enable_vtime() { return false; }
 876 bool os::vtime_enabled() { return false; }
 877 
 878 double os::elapsedVTime() {
 879   FILETIME created;
 880   FILETIME exited;
 881   FILETIME kernel;
 882   FILETIME user;
 883   if (GetThreadTimes(GetCurrentThread(), &amp;created, &amp;exited, &amp;kernel, &amp;user) != 0) {
 884     // the resolution of windows_to_java_time() should be sufficient (ms)
 885     return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) / MILLIUNITS;
 886   } else {
 887     return elapsedTime();
 888   }
 889 }
 890 
 891 jlong os::javaTimeMillis() {
 892   if (UseFakeTimers) {
 893     return fake_time++;
 894   } else {
 895     FILETIME wt;
 896     GetSystemTimeAsFileTime(&amp;wt);
 897     return windows_to_java_time(wt);
 898   }
 899 }
 900 
 901 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
 902   FILETIME wt;
 903   GetSystemTimeAsFileTime(&amp;wt);
 904   jlong ticks = windows_to_time_ticks(wt); // 10th of micros
 905   jlong secs = jlong(ticks / 10000000); // 10000 * 1000
 906   seconds = secs;
 907   nanos = jlong(ticks - (secs*10000000)) * 100;
 908 }
 909 
 910 jlong os::javaTimeNanos() {
 911     LARGE_INTEGER current_count;
 912     QueryPerformanceCounter(&amp;current_count);
 913     double current = as_long(current_count);
 914     double freq = performance_frequency;
 915     jlong time = (jlong)((current/freq) * NANOSECS_PER_SEC);
 916     return time;
 917 }
 918 
 919 void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {
 920   jlong freq = performance_frequency;
 921   if (freq &lt; NANOSECS_PER_SEC) {
 922     // the performance counter is 64 bits and we will
 923     // be multiplying it -- so no wrap in 64 bits
 924     info_ptr-&gt;max_value = ALL_64_BITS;
 925   } else if (freq &gt; NANOSECS_PER_SEC) {
 926     // use the max value the counter can reach to
 927     // determine the max value which could be returned
 928     julong max_counter = (julong)ALL_64_BITS;
 929     info_ptr-&gt;max_value = (jlong)(max_counter / (freq / NANOSECS_PER_SEC));
 930   } else {
 931     // the performance counter is 64 bits and we will
 932     // be using it directly -- so no wrap in 64 bits
 933     info_ptr-&gt;max_value = ALL_64_BITS;
 934   }
 935 
 936   // using a counter, so no skipping
 937   info_ptr-&gt;may_skip_backward = false;
 938   info_ptr-&gt;may_skip_forward = false;
 939 
 940   info_ptr-&gt;kind = JVMTI_TIMER_ELAPSED;                // elapsed not CPU time
 941 }
 942 
 943 char* os::local_time_string(char *buf, size_t buflen) {
 944   SYSTEMTIME st;
 945   GetLocalTime(&amp;st);
 946   jio_snprintf(buf, buflen, "%d-%02d-%02d %02d:%02d:%02d",
 947                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
 948   return buf;
 949 }
 950 
 951 bool os::getTimesSecs(double* process_real_time,
 952                       double* process_user_time,
 953                       double* process_system_time) {
 954   HANDLE h_process = GetCurrentProcess();
 955   FILETIME create_time, exit_time, kernel_time, user_time;
 956   BOOL result = GetProcessTimes(h_process,
 957                                 &amp;create_time,
 958                                 &amp;exit_time,
 959                                 &amp;kernel_time,
 960                                 &amp;user_time);
 961   if (result != 0) {
 962     FILETIME wt;
 963     GetSystemTimeAsFileTime(&amp;wt);
 964     jlong rtc_millis = windows_to_java_time(wt);
 965     *process_real_time = ((double) rtc_millis) / ((double) MILLIUNITS);
 966     *process_user_time =
 967       (double) jlong_from(user_time.dwHighDateTime, user_time.dwLowDateTime) / (10 * MICROUNITS);
 968     *process_system_time =
 969       (double) jlong_from(kernel_time.dwHighDateTime, kernel_time.dwLowDateTime) / (10 * MICROUNITS);
 970     return true;
 971   } else {
 972     return false;
 973   }
 974 }
 975 
 976 void os::shutdown() {
 977   // allow PerfMemory to attempt cleanup of any persistent resources
 978   perfMemory_exit();
 979 
 980   // flush buffered output, finish log files
 981   ostream_abort();
 982 
 983   // Check for abort hook
 984   abort_hook_t abort_hook = Arguments::abort_hook();
 985   if (abort_hook != NULL) {
 986     abort_hook();
 987   }
 988 }
 989 
 990 
 991 static BOOL (WINAPI *_MiniDumpWriteDump)(HANDLE, DWORD, HANDLE, MINIDUMP_TYPE,
 992                                          PMINIDUMP_EXCEPTION_INFORMATION,
 993                                          PMINIDUMP_USER_STREAM_INFORMATION,
 994                                          PMINIDUMP_CALLBACK_INFORMATION);
 995 
 996 static HANDLE dumpFile = NULL;
 997 
 998 // Check if dump file can be created.
 999 void os::check_dump_limit(char* buffer, size_t buffsz) {
1000   bool status = true;
1001   if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) &amp;&amp; !CreateCoredumpOnCrash) {
1002     jio_snprintf(buffer, buffsz, "CreateCoredumpOnCrash is disabled from command line");
1003     status = false;
1004   }
1005 
1006 #ifndef ASSERT
1007   if (!os::win32::is_windows_server() &amp;&amp; FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {
1008     jio_snprintf(buffer, buffsz, "Minidumps are not enabled by default on client versions of Windows");
1009     status = false;
1010   }
1011 #endif
1012 
1013   if (status) {
1014     const char* cwd = get_current_directory(NULL, 0);
1015     int pid = current_process_id();
1016     if (cwd != NULL) {
1017       jio_snprintf(buffer, buffsz, "%s\\hs_err_pid%u.mdmp", cwd, pid);
1018     } else {
1019       jio_snprintf(buffer, buffsz, ".\\hs_err_pid%u.mdmp", pid);
1020     }
1021 
1022     if (dumpFile == NULL &amp;&amp;
1023        (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))
1024                  == INVALID_HANDLE_VALUE) {
1025       jio_snprintf(buffer, buffsz, "Failed to create minidump file (0x%x).", GetLastError());
1026       status = false;
1027     }
1028   }
1029   VMError::record_coredump_status(buffer, status);
1030 }
1031 
1032 void os::abort(bool dump_core, void* siginfo, const void* context) {
1033   HINSTANCE dbghelp;
1034   EXCEPTION_POINTERS ep;
1035   MINIDUMP_EXCEPTION_INFORMATION mei;
1036   MINIDUMP_EXCEPTION_INFORMATION* pmei;
1037 
1038   HANDLE hProcess = GetCurrentProcess();
1039   DWORD processId = GetCurrentProcessId();
1040   MINIDUMP_TYPE dumpType;
1041 
1042   shutdown();
1043   if (!dump_core || dumpFile == NULL) {
1044     if (dumpFile != NULL) {
1045       CloseHandle(dumpFile);
1046     }
1047     win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1048   }
1049 
1050   dbghelp = os::win32::load_Windows_dll("DBGHELP.DLL", NULL, 0);
1051 
1052   if (dbghelp == NULL) {
1053     jio_fprintf(stderr, "Failed to load dbghelp.dll\n");
1054     CloseHandle(dumpFile);
1055     win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1056   }
1057 
1058   _MiniDumpWriteDump =
1059       CAST_TO_FN_PTR(BOOL(WINAPI *)(HANDLE, DWORD, HANDLE, MINIDUMP_TYPE,
1060                                     PMINIDUMP_EXCEPTION_INFORMATION,
1061                                     PMINIDUMP_USER_STREAM_INFORMATION,
1062                                     PMINIDUMP_CALLBACK_INFORMATION),
1063                                     GetProcAddress(dbghelp,
1064                                     "MiniDumpWriteDump"));
1065 
1066   if (_MiniDumpWriteDump == NULL) {
1067     jio_fprintf(stderr, "Failed to find MiniDumpWriteDump() in module dbghelp.dll.\n");
1068     CloseHandle(dumpFile);
1069     win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1070   }
1071 
1072   dumpType = (MINIDUMP_TYPE)(MiniDumpWithFullMemory | MiniDumpWithHandleData |
1073     MiniDumpWithFullMemoryInfo | MiniDumpWithThreadInfo | MiniDumpWithUnloadedModules);
1074 
1075   if (siginfo != NULL &amp;&amp; context != NULL) {
1076     ep.ContextRecord = (PCONTEXT) context;
1077     ep.ExceptionRecord = (PEXCEPTION_RECORD) siginfo;
1078 
1079     mei.ThreadId = GetCurrentThreadId();
1080     mei.ExceptionPointers = &amp;ep;
1081     pmei = &amp;mei;
1082   } else {
1083     pmei = NULL;
1084   }
1085 
1086   // Older versions of dbghelp.dll (the one shipped with Win2003 for example) may not support all
1087   // the dump types we really want. If first call fails, lets fall back to just use MiniDumpWithFullMemory then.
1088   if (_MiniDumpWriteDump(hProcess, processId, dumpFile, dumpType, pmei, NULL, NULL) == false &amp;&amp;
1089       _MiniDumpWriteDump(hProcess, processId, dumpFile, (MINIDUMP_TYPE)MiniDumpWithFullMemory, pmei, NULL, NULL) == false) {
1090     jio_fprintf(stderr, "Call to MiniDumpWriteDump() failed (Error 0x%x)\n", GetLastError());
1091   }
1092   CloseHandle(dumpFile);
1093   win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1094 }
1095 
1096 // Die immediately, no exit hook, no abort hook, no cleanup.
1097 void os::die() {
1098   win32::exit_process_or_thread(win32::EPT_PROCESS_DIE, -1);
1099 }
1100 
1101 // Directory routines copied from src/win32/native/java/io/dirent_md.c
1102 //  * dirent_md.c       1.15 00/02/02
1103 //
1104 // The declarations for DIR and struct dirent are in jvm_win32.h.
1105 
1106 // Caller must have already run dirname through JVM_NativePath, which removes
1107 // duplicate slashes and converts all instances of '/' into '\\'.
1108 
1109 DIR * os::opendir(const char *dirname) {
1110   assert(dirname != NULL, "just checking");   // hotspot change
1111   DIR *dirp = (DIR *)malloc(sizeof(DIR), mtInternal);
1112   DWORD fattr;                                // hotspot change
1113   char alt_dirname[4] = { 0, 0, 0, 0 };
1114 
1115   if (dirp == 0) {
1116     errno = ENOMEM;
1117     return 0;
1118   }
1119 
1120   // Win32 accepts "\" in its POSIX stat(), but refuses to treat it
1121   // as a directory in FindFirstFile().  We detect this case here and
1122   // prepend the current drive name.
1123   //
1124   if (dirname[1] == '\0' &amp;&amp; dirname[0] == '\\') {
1125     alt_dirname[0] = _getdrive() + 'A' - 1;
1126     alt_dirname[1] = ':';
1127     alt_dirname[2] = '\\';
1128     alt_dirname[3] = '\0';
1129     dirname = alt_dirname;
1130   }
1131 
1132   dirp-&gt;path = (char *)malloc(strlen(dirname) + 5, mtInternal);
1133   if (dirp-&gt;path == 0) {
1134     free(dirp);
1135     errno = ENOMEM;
1136     return 0;
1137   }
1138   strcpy(dirp-&gt;path, dirname);
1139 
1140   fattr = GetFileAttributes(dirp-&gt;path);
1141   if (fattr == 0xffffffff) {
1142     free(dirp-&gt;path);
1143     free(dirp);
1144     errno = ENOENT;
1145     return 0;
1146   } else if ((fattr &amp; FILE_ATTRIBUTE_DIRECTORY) == 0) {
1147     free(dirp-&gt;path);
1148     free(dirp);
1149     errno = ENOTDIR;
1150     return 0;
1151   }
1152 
1153   // Append "*.*", or possibly "\\*.*", to path
1154   if (dirp-&gt;path[1] == ':' &amp;&amp;
1155       (dirp-&gt;path[2] == '\0' ||
1156       (dirp-&gt;path[2] == '\\' &amp;&amp; dirp-&gt;path[3] == '\0'))) {
1157     // No '\\' needed for cases like "Z:" or "Z:\"
1158     strcat(dirp-&gt;path, "*.*");
1159   } else {
1160     strcat(dirp-&gt;path, "\\*.*");
1161   }
1162 
1163   dirp-&gt;handle = FindFirstFile(dirp-&gt;path, &amp;dirp-&gt;find_data);
1164   if (dirp-&gt;handle == INVALID_HANDLE_VALUE) {
1165     if (GetLastError() != ERROR_FILE_NOT_FOUND) {
1166       free(dirp-&gt;path);
1167       free(dirp);
1168       errno = EACCES;
1169       return 0;
1170     }
1171   }
1172   return dirp;
1173 }
1174 
1175 // parameter dbuf unused on Windows
1176 struct dirent * os::readdir(DIR *dirp, dirent *dbuf) {
1177   assert(dirp != NULL, "just checking");      // hotspot change
1178   if (dirp-&gt;handle == INVALID_HANDLE_VALUE) {
1179     return 0;
1180   }
1181 
1182   strcpy(dirp-&gt;dirent.d_name, dirp-&gt;find_data.cFileName);
1183 
1184   if (!FindNextFile(dirp-&gt;handle, &amp;dirp-&gt;find_data)) {
1185     if (GetLastError() == ERROR_INVALID_HANDLE) {
1186       errno = EBADF;
1187       return 0;
1188     }
1189     FindClose(dirp-&gt;handle);
1190     dirp-&gt;handle = INVALID_HANDLE_VALUE;
1191   }
1192 
1193   return &amp;dirp-&gt;dirent;
1194 }
1195 
1196 int os::closedir(DIR *dirp) {
1197   assert(dirp != NULL, "just checking");      // hotspot change
1198   if (dirp-&gt;handle != INVALID_HANDLE_VALUE) {
1199     if (!FindClose(dirp-&gt;handle)) {
1200       errno = EBADF;
1201       return -1;
1202     }
1203     dirp-&gt;handle = INVALID_HANDLE_VALUE;
1204   }
1205   free(dirp-&gt;path);
1206   free(dirp);
1207   return 0;
1208 }
1209 
1210 // This must be hard coded because it's the system's temporary
1211 // directory not the java application's temp directory, ala java.io.tmpdir.
1212 const char* os::get_temp_directory() {
1213   static char path_buf[MAX_PATH];
1214   if (GetTempPath(MAX_PATH, path_buf) &gt; 0) {
1215     return path_buf;
1216   } else {
1217     path_buf[0] = '\0';
1218     return path_buf;
1219   }
1220 }
1221 
1222 static bool file_exists(const char* filename) {
1223   if (filename == NULL || strlen(filename) == 0) {
1224     return false;
1225   }
1226   return GetFileAttributes(filename) != INVALID_FILE_ATTRIBUTES;
1227 }
1228 
1229 bool os::dll_build_name(char *buffer, size_t buflen,
1230                         const char* pname, const char* fname) {
1231   bool retval = false;
1232   const size_t pnamelen = pname ? strlen(pname) : 0;
1233   const char c = (pnamelen &gt; 0) ? pname[pnamelen-1] : 0;
1234 
1235   // Return error on buffer overflow.
1236   if (pnamelen + strlen(fname) + 10 &gt; buflen) {
1237     return retval;
1238   }
1239 
1240   if (pnamelen == 0) {
1241     jio_snprintf(buffer, buflen, "%s.dll", fname);
1242     retval = true;
1243   } else if (c == ':' || c == '\\') {
1244     jio_snprintf(buffer, buflen, "%s%s.dll", pname, fname);
1245     retval = true;
1246   } else if (strchr(pname, *os::path_separator()) != NULL) {
1247     int n;
1248     char** pelements = split_path(pname, &amp;n);
1249     if (pelements == NULL) {
1250       return false;
1251     }
1252     for (int i = 0; i &lt; n; i++) {
1253       char* path = pelements[i];
1254       // Really shouldn't be NULL, but check can't hurt
1255       size_t plen = (path == NULL) ? 0 : strlen(path);
1256       if (plen == 0) {
1257         continue; // skip the empty path values
1258       }
1259       const char lastchar = path[plen - 1];
1260       if (lastchar == ':' || lastchar == '\\') {
1261         jio_snprintf(buffer, buflen, "%s%s.dll", path, fname);
1262       } else {
1263         jio_snprintf(buffer, buflen, "%s\\%s.dll", path, fname);
1264       }
1265       if (file_exists(buffer)) {
1266         retval = true;
1267         break;
1268       }
1269     }
1270     // release the storage
1271     for (int i = 0; i &lt; n; i++) {
1272       if (pelements[i] != NULL) {
1273         FREE_C_HEAP_ARRAY(char, pelements[i]);
1274       }
1275     }
1276     if (pelements != NULL) {
1277       FREE_C_HEAP_ARRAY(char*, pelements);
1278     }
1279   } else {
1280     jio_snprintf(buffer, buflen, "%s\\%s.dll", pname, fname);
1281     retval = true;
1282   }
1283   return retval;
1284 }
1285 
1286 // Needs to be in os specific directory because windows requires another
1287 // header file &lt;direct.h&gt;
1288 const char* os::get_current_directory(char *buf, size_t buflen) {
1289   int n = static_cast&lt;int&gt;(buflen);
1290   if (buflen &gt; INT_MAX)  n = INT_MAX;
1291   return _getcwd(buf, n);
1292 }
1293 
1294 //-----------------------------------------------------------
1295 // Helper functions for fatal error handler
1296 #ifdef _WIN64
1297 // Helper routine which returns true if address in
1298 // within the NTDLL address space.
1299 //
1300 static bool _addr_in_ntdll(address addr) {
1301   HMODULE hmod;
1302   MODULEINFO minfo;
1303 
1304   hmod = GetModuleHandle("NTDLL.DLL");
1305   if (hmod == NULL) return false;
1306   if (!GetModuleInformation(GetCurrentProcess(), hmod,
1307                                           &amp;minfo, sizeof(MODULEINFO))) {
1308     return false;
1309   }
1310 
1311   if ((addr &gt;= minfo.lpBaseOfDll) &amp;&amp;
1312       (addr &lt; (address)((uintptr_t)minfo.lpBaseOfDll + (uintptr_t)minfo.SizeOfImage))) {
1313     return true;
1314   } else {
1315     return false;
1316   }
1317 }
1318 #endif
1319 
1320 struct _modinfo {
1321   address addr;
1322   char*   full_path;   // point to a char buffer
1323   int     buflen;      // size of the buffer
1324   address base_addr;
1325 };
1326 
1327 static int _locate_module_by_addr(const char * mod_fname, address base_addr,
1328                                   address top_address, void * param) {
1329   struct _modinfo *pmod = (struct _modinfo *)param;
1330   if (!pmod) return -1;
1331 
1332   if (base_addr   &lt;= pmod-&gt;addr &amp;&amp;
1333       top_address &gt; pmod-&gt;addr) {
1334     // if a buffer is provided, copy path name to the buffer
1335     if (pmod-&gt;full_path) {
1336       jio_snprintf(pmod-&gt;full_path, pmod-&gt;buflen, "%s", mod_fname);
1337     }
1338     pmod-&gt;base_addr = base_addr;
1339     return 1;
1340   }
1341   return 0;
1342 }
1343 
1344 bool os::dll_address_to_library_name(address addr, char* buf,
1345                                      int buflen, int* offset) {
1346   // buf is not optional, but offset is optional
1347   assert(buf != NULL, "sanity check");
1348 
1349 // NOTE: the reason we don't use SymGetModuleInfo() is it doesn't always
1350 //       return the full path to the DLL file, sometimes it returns path
1351 //       to the corresponding PDB file (debug info); sometimes it only
1352 //       returns partial path, which makes life painful.
1353 
1354   struct _modinfo mi;
1355   mi.addr      = addr;
1356   mi.full_path = buf;
1357   mi.buflen    = buflen;
1358   if (get_loaded_modules_info(_locate_module_by_addr, (void *)&amp;mi)) {
1359     // buf already contains path name
1360     if (offset) *offset = addr - mi.base_addr;
1361     return true;
1362   }
1363 
1364   buf[0] = '\0';
1365   if (offset) *offset = -1;
1366   return false;
1367 }
1368 
1369 bool os::dll_address_to_function_name(address addr, char *buf,
1370                                       int buflen, int *offset,
1371                                       bool demangle) {
1372   // buf is not optional, but offset is optional
1373   assert(buf != NULL, "sanity check");
1374 
1375   if (Decoder::decode(addr, buf, buflen, offset, demangle)) {
1376     return true;
1377   }
1378   if (offset != NULL)  *offset  = -1;
1379   buf[0] = '\0';
1380   return false;
1381 }
1382 
1383 // save the start and end address of jvm.dll into param[0] and param[1]
1384 static int _locate_jvm_dll(const char* mod_fname, address base_addr,
1385                            address top_address, void * param) {
1386   if (!param) return -1;
1387 
1388   if (base_addr   &lt;= (address)_locate_jvm_dll &amp;&amp;
1389       top_address &gt; (address)_locate_jvm_dll) {
1390     ((address*)param)[0] = base_addr;
1391     ((address*)param)[1] = top_address;
1392     return 1;
1393   }
1394   return 0;
1395 }
1396 
1397 address vm_lib_location[2];    // start and end address of jvm.dll
1398 
1399 // check if addr is inside jvm.dll
1400 bool os::address_is_in_vm(address addr) {
1401   if (!vm_lib_location[0] || !vm_lib_location[1]) {
1402     if (!get_loaded_modules_info(_locate_jvm_dll, (void *)vm_lib_location)) {
1403       assert(false, "Can't find jvm module.");
1404       return false;
1405     }
1406   }
1407 
1408   return (vm_lib_location[0] &lt;= addr) &amp;&amp; (addr &lt; vm_lib_location[1]);
1409 }
1410 
1411 // print module info; param is outputStream*
1412 static int _print_module(const char* fname, address base_address,
1413                          address top_address, void* param) {
1414   if (!param) return -1;
1415 
1416   outputStream* st = (outputStream*)param;
1417 
1418   st-&gt;print(PTR_FORMAT " - " PTR_FORMAT " \t%s\n", base_address, top_address, fname);
1419   return 0;
1420 }
1421 
1422 // Loads .dll/.so and
1423 // in case of error it checks if .dll/.so was built for the
1424 // same architecture as Hotspot is running on
1425 void * os::dll_load(const char *name, char *ebuf, int ebuflen) {
1426   void * result = LoadLibrary(name);
1427   if (result != NULL) {
1428     return result;
1429   }
1430 
1431   DWORD errcode = GetLastError();
1432   if (errcode == ERROR_MOD_NOT_FOUND) {
1433     strncpy(ebuf, "Can't find dependent libraries", ebuflen - 1);
1434     ebuf[ebuflen - 1] = '\0';
1435     return NULL;
1436   }
1437 
1438   // Parsing dll below
1439   // If we can read dll-info and find that dll was built
1440   // for an architecture other than Hotspot is running in
1441   // - then print to buffer "DLL was built for a different architecture"
1442   // else call os::lasterror to obtain system error message
1443 
1444   // Read system error message into ebuf
1445   // It may or may not be overwritten below (in the for loop and just above)
1446   lasterror(ebuf, (size_t) ebuflen);
1447   ebuf[ebuflen - 1] = '\0';
1448   int fd = ::open(name, O_RDONLY | O_BINARY, 0);
1449   if (fd &lt; 0) {
1450     return NULL;
1451   }
1452 
1453   uint32_t signature_offset;
1454   uint16_t lib_arch = 0;
1455   bool failed_to_get_lib_arch =
1456     ( // Go to position 3c in the dll
1457      (os::seek_to_file_offset(fd, IMAGE_FILE_PTR_TO_SIGNATURE) &lt; 0)
1458      ||
1459      // Read location of signature
1460      (sizeof(signature_offset) !=
1461      (os::read(fd, (void*)&amp;signature_offset, sizeof(signature_offset))))
1462      ||
1463      // Go to COFF File Header in dll
1464      // that is located after "signature" (4 bytes long)
1465      (os::seek_to_file_offset(fd,
1466      signature_offset + IMAGE_FILE_SIGNATURE_LENGTH) &lt; 0)
1467      ||
1468      // Read field that contains code of architecture
1469      // that dll was built for
1470      (sizeof(lib_arch) != (os::read(fd, (void*)&amp;lib_arch, sizeof(lib_arch))))
1471     );
1472 
1473   ::close(fd);
1474   if (failed_to_get_lib_arch) {
1475     // file i/o error - report os::lasterror(...) msg
1476     return NULL;
1477   }
1478 
1479   typedef struct {
1480     uint16_t arch_code;
1481     char* arch_name;
1482   } arch_t;
1483 
1484   static const arch_t arch_array[] = {
1485     {IMAGE_FILE_MACHINE_I386,      (char*)"IA 32"},
1486     {IMAGE_FILE_MACHINE_AMD64,     (char*)"AMD 64"},
1487     {IMAGE_FILE_MACHINE_IA64,      (char*)"IA 64"}
1488   };
1489 #if   (defined _M_IA64)
1490   static const uint16_t running_arch = IMAGE_FILE_MACHINE_IA64;
1491 #elif (defined _M_AMD64)
1492   static const uint16_t running_arch = IMAGE_FILE_MACHINE_AMD64;
1493 #elif (defined _M_IX86)
1494   static const uint16_t running_arch = IMAGE_FILE_MACHINE_I386;
1495 #else
1496   #error Method os::dll_load requires that one of following \
1497          is defined :_M_IA64,_M_AMD64 or _M_IX86
1498 #endif
1499 
1500 
1501   // Obtain a string for printf operation
1502   // lib_arch_str shall contain string what platform this .dll was built for
1503   // running_arch_str shall string contain what platform Hotspot was built for
1504   char *running_arch_str = NULL, *lib_arch_str = NULL;
1505   for (unsigned int i = 0; i &lt; ARRAY_SIZE(arch_array); i++) {
1506     if (lib_arch == arch_array[i].arch_code) {
1507       lib_arch_str = arch_array[i].arch_name;
1508     }
1509     if (running_arch == arch_array[i].arch_code) {
1510       running_arch_str = arch_array[i].arch_name;
1511     }
1512   }
1513 
1514   assert(running_arch_str,
1515          "Didn't find running architecture code in arch_array");
1516 
1517   // If the architecture is right
1518   // but some other error took place - report os::lasterror(...) msg
1519   if (lib_arch == running_arch) {
1520     return NULL;
1521   }
1522 
1523   if (lib_arch_str != NULL) {
1524     ::_snprintf(ebuf, ebuflen - 1,
1525                 "Can't load %s-bit .dll on a %s-bit platform",
1526                 lib_arch_str, running_arch_str);
1527   } else {
1528     // don't know what architecture this dll was build for
1529     ::_snprintf(ebuf, ebuflen - 1,
1530                 "Can't load this .dll (machine code=0x%x) on a %s-bit platform",
1531                 lib_arch, running_arch_str);
1532   }
1533 
1534   return NULL;
1535 }
1536 
1537 void os::print_dll_info(outputStream *st) {
1538   st-&gt;print_cr("Dynamic libraries:");
1539   get_loaded_modules_info(_print_module, (void *)st);
1540 }
1541 
1542 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
1543   HANDLE   hProcess;
1544 
1545 # define MAX_NUM_MODULES 128
1546   HMODULE     modules[MAX_NUM_MODULES];
1547   static char filename[MAX_PATH];
1548   int         result = 0;
1549 
1550   int pid = os::current_process_id();
1551   hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
1552                          FALSE, pid);
1553   if (hProcess == NULL) return 0;
1554 
1555   DWORD size_needed;
1556   if (!EnumProcessModules(hProcess, modules, sizeof(modules), &amp;size_needed)) {
1557     CloseHandle(hProcess);
1558     return 0;
1559   }
1560 
1561   // number of modules that are currently loaded
1562   int num_modules = size_needed / sizeof(HMODULE);
1563 
1564   for (int i = 0; i &lt; MIN2(num_modules, MAX_NUM_MODULES); i++) {
1565     // Get Full pathname:
1566     if (!GetModuleFileNameEx(hProcess, modules[i], filename, sizeof(filename))) {
1567       filename[0] = '\0';
1568     }
1569 
1570     MODULEINFO modinfo;
1571     if (!GetModuleInformation(hProcess, modules[i], &amp;modinfo, sizeof(modinfo))) {
1572       modinfo.lpBaseOfDll = NULL;
1573       modinfo.SizeOfImage = 0;
1574     }
1575 
1576     // Invoke callback function
1577     result = callback(filename, (address)modinfo.lpBaseOfDll,
1578                       (address)((u8)modinfo.lpBaseOfDll + (u8)modinfo.SizeOfImage), param);
1579     if (result) break;
1580   }
1581 
1582   CloseHandle(hProcess);
1583   return result;
1584 }
1585 
1586 bool os::get_host_name(char* buf, size_t buflen) {
1587   DWORD size = (DWORD)buflen;
1588   return (GetComputerNameEx(ComputerNameDnsHostname, buf, &amp;size) == TRUE);
1589 }
1590 
1591 void os::get_summary_os_info(char* buf, size_t buflen) {
1592   stringStream sst(buf, buflen);
1593   os::win32::print_windows_version(&amp;sst);
1594   // chop off newline character
1595   char* nl = strchr(buf, '\n');
1596   if (nl != NULL) *nl = '\0';
1597 }
1598 
1599 int os::log_vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {
1600   int ret = vsnprintf(buf, len, fmt, args);
1601   // Get the correct buffer size if buf is too small
1602   if (ret &lt; 0) {
1603     return _vscprintf(fmt, args);
1604   }
1605   return ret;
1606 }
1607 
1608 static inline time_t get_mtime(const char* filename) {
1609   struct stat st;
1610   int ret = os::stat(filename, &amp;st);
1611   assert(ret == 0, "failed to stat() file '%s': %s", filename, strerror(errno));
1612   return st.st_mtime;
1613 }
1614 
1615 int os::compare_file_modified_times(const char* file1, const char* file2) {
1616   time_t t1 = get_mtime(file1);
1617   time_t t2 = get_mtime(file2);
1618   return t1 - t2;
1619 }
1620 
1621 void os::print_os_info_brief(outputStream* st) {
1622   os::print_os_info(st);
1623 }
1624 
1625 void os::print_os_info(outputStream* st) {
1626 #ifdef ASSERT
1627   char buffer[1024];
1628   st-&gt;print("HostName: ");
1629   if (get_host_name(buffer, sizeof(buffer))) {
1630     st-&gt;print("%s ", buffer);
1631   } else {
1632     st-&gt;print("N/A ");
1633   }
1634 #endif
1635   st-&gt;print("OS:");
1636   os::win32::print_windows_version(st);
1637 }
1638 
1639 void os::win32::print_windows_version(outputStream* st) {
1640   OSVERSIONINFOEX osvi;
1641   VS_FIXEDFILEINFO *file_info;
1642   TCHAR kernel32_path[MAX_PATH];
1643   UINT len, ret;
1644 
1645   // Use the GetVersionEx information to see if we're on a server or
1646   // workstation edition of Windows. Starting with Windows 8.1 we can't
1647   // trust the OS version information returned by this API.
1648   ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));
1649   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
1650   if (!GetVersionEx((OSVERSIONINFO *)&amp;osvi)) {
1651     st-&gt;print_cr("Call to GetVersionEx failed");
1652     return;
1653   }
1654   bool is_workstation = (osvi.wProductType == VER_NT_WORKSTATION);
1655 
1656   // Get the full path to \Windows\System32\kernel32.dll and use that for
1657   // determining what version of Windows we're running on.
1658   len = MAX_PATH - (UINT)strlen("\\kernel32.dll") - 1;
1659   ret = GetSystemDirectory(kernel32_path, len);
1660   if (ret == 0 || ret &gt; len) {
1661     st-&gt;print_cr("Call to GetSystemDirectory failed");
1662     return;
1663   }
1664   strncat(kernel32_path, "\\kernel32.dll", MAX_PATH - ret);
1665 
1666   DWORD version_size = GetFileVersionInfoSize(kernel32_path, NULL);
1667   if (version_size == 0) {
1668     st-&gt;print_cr("Call to GetFileVersionInfoSize failed");
1669     return;
1670   }
1671 
1672   LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);
1673   if (version_info == NULL) {
1674     st-&gt;print_cr("Failed to allocate version_info");
1675     return;
1676   }
1677 
1678   if (!GetFileVersionInfo(kernel32_path, NULL, version_size, version_info)) {
1679     os::free(version_info);
1680     st-&gt;print_cr("Call to GetFileVersionInfo failed");
1681     return;
1682   }
1683 
1684   if (!VerQueryValue(version_info, TEXT("\\"), (LPVOID*)&amp;file_info, &amp;len)) {
1685     os::free(version_info);
1686     st-&gt;print_cr("Call to VerQueryValue failed");
1687     return;
1688   }
1689 
1690   int major_version = HIWORD(file_info-&gt;dwProductVersionMS);
1691   int minor_version = LOWORD(file_info-&gt;dwProductVersionMS);
1692   int build_number = HIWORD(file_info-&gt;dwProductVersionLS);
1693   int build_minor = LOWORD(file_info-&gt;dwProductVersionLS);
1694   int os_vers = major_version * 1000 + minor_version;
1695   os::free(version_info);
1696 
1697   st-&gt;print(" Windows ");
1698   switch (os_vers) {
1699 
1700   case 6000:
1701     if (is_workstation) {
1702       st-&gt;print("Vista");
1703     } else {
1704       st-&gt;print("Server 2008");
1705     }
1706     break;
1707 
1708   case 6001:
1709     if (is_workstation) {
1710       st-&gt;print("7");
1711     } else {
1712       st-&gt;print("Server 2008 R2");
1713     }
1714     break;
1715 
1716   case 6002:
1717     if (is_workstation) {
1718       st-&gt;print("8");
1719     } else {
1720       st-&gt;print("Server 2012");
1721     }
1722     break;
1723 
1724   case 6003:
1725     if (is_workstation) {
1726       st-&gt;print("8.1");
1727     } else {
1728       st-&gt;print("Server 2012 R2");
1729     }
1730     break;
1731 
1732   case 10000:
1733     if (is_workstation) {
1734       st-&gt;print("10");
1735     } else {
1736       st-&gt;print("Server 2016");
1737     }
1738     break;
1739 
1740   default:
1741     // Unrecognized windows, print out its major and minor versions
1742     st-&gt;print("%d.%d", major_version, minor_version);
1743     break;
1744   }
1745 
1746   // Retrieve SYSTEM_INFO from GetNativeSystemInfo call so that we could
1747   // find out whether we are running on 64 bit processor or not
1748   SYSTEM_INFO si;
1749   ZeroMemory(&amp;si, sizeof(SYSTEM_INFO));
1750   GetNativeSystemInfo(&amp;si);
1751   if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {
1752     st-&gt;print(" , 64 bit");
1753   }
1754 
1755   st-&gt;print(" Build %d", build_number);
1756   st-&gt;print(" (%d.%d.%d.%d)", major_version, minor_version, build_number, build_minor);
1757   st-&gt;cr();
1758 }
1759 
1760 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1761   // Nothing to do for now.
1762 }
1763 
1764 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1765   HKEY key;
1766   DWORD status = RegOpenKey(HKEY_LOCAL_MACHINE,
1767                "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", &amp;key);
1768   if (status == ERROR_SUCCESS) {
1769     DWORD size = (DWORD)buflen;
1770     status = RegQueryValueEx(key, "ProcessorNameString", NULL, NULL, (byte*)buf, &amp;size);
1771     if (status != ERROR_SUCCESS) {
1772         strncpy(buf, "## __CPU__", buflen);
1773     }
1774     RegCloseKey(key);
1775   } else {
1776     // Put generic cpu info to return
1777     strncpy(buf, "## __CPU__", buflen);
1778   }
1779 }
1780 
1781 void os::print_memory_info(outputStream* st) {
1782   st-&gt;print("Memory:");
1783   st-&gt;print(" %dk page", os::vm_page_size()&gt;&gt;10);
1784 
1785   // Use GlobalMemoryStatusEx() because GlobalMemoryStatus() may return incorrect
1786   // value if total memory is larger than 4GB
1787   MEMORYSTATUSEX ms;
1788   ms.dwLength = sizeof(ms);
1789   GlobalMemoryStatusEx(&amp;ms);
1790 
1791   st-&gt;print(", physical %uk", os::physical_memory() &gt;&gt; 10);
1792   st-&gt;print("(%uk free)", os::available_memory() &gt;&gt; 10);
1793 
1794   st-&gt;print(", swap %uk", ms.ullTotalPageFile &gt;&gt; 10);
1795   st-&gt;print("(%uk free)", ms.ullAvailPageFile &gt;&gt; 10);
1796   st-&gt;cr();
1797 }
1798 
1799 void os::print_siginfo(outputStream *st, const void* siginfo) {
1800   const EXCEPTION_RECORD* const er = (EXCEPTION_RECORD*)siginfo;
1801   st-&gt;print("siginfo:");
1802 
1803   char tmp[64];
1804   if (os::exception_name(er-&gt;ExceptionCode, tmp, sizeof(tmp)) == NULL) {
1805     strcpy(tmp, "EXCEPTION_??");
1806   }
1807   st-&gt;print(" %s (0x%x)", tmp, er-&gt;ExceptionCode);
1808 
1809   if ((er-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION ||
1810        er-&gt;ExceptionCode == EXCEPTION_IN_PAGE_ERROR) &amp;&amp;
1811        er-&gt;NumberParameters &gt;= 2) {
1812     switch (er-&gt;ExceptionInformation[0]) {
1813     case 0: st-&gt;print(", reading address"); break;
1814     case 1: st-&gt;print(", writing address"); break;
1815     case 8: st-&gt;print(", data execution prevention violation at address"); break;
1816     default: st-&gt;print(", ExceptionInformation=" INTPTR_FORMAT,
1817                        er-&gt;ExceptionInformation[0]);
1818     }
1819     st-&gt;print(" " INTPTR_FORMAT, er-&gt;ExceptionInformation[1]);
1820   } else {
1821     int num = er-&gt;NumberParameters;
1822     if (num &gt; 0) {
1823       st-&gt;print(", ExceptionInformation=");
1824       for (int i = 0; i &lt; num; i++) {
1825         st-&gt;print(INTPTR_FORMAT " ", er-&gt;ExceptionInformation[i]);
1826       }
1827     }
1828   }
1829   st-&gt;cr();
1830 }
1831 
1832 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1833   // do nothing
1834 }
1835 
1836 static char saved_jvm_path[MAX_PATH] = {0};
1837 
1838 // Find the full path to the current module, jvm.dll
1839 void os::jvm_path(char *buf, jint buflen) {
1840   // Error checking.
1841   if (buflen &lt; MAX_PATH) {
1842     assert(false, "must use a large-enough buffer");
1843     buf[0] = '\0';
1844     return;
1845   }
1846   // Lazy resolve the path to current module.
1847   if (saved_jvm_path[0] != 0) {
1848     strcpy(buf, saved_jvm_path);
1849     return;
1850   }
1851 
1852   buf[0] = '\0';
1853   if (Arguments::sun_java_launcher_is_altjvm()) {
1854     // Support for the java launcher's '-XXaltjvm=&lt;path&gt;' option. Check
1855     // for a JAVA_HOME environment variable and fix up the path so it
1856     // looks like jvm.dll is installed there (append a fake suffix
1857     // hotspot/jvm.dll).
1858     char* java_home_var = ::getenv("JAVA_HOME");
1859     if (java_home_var != NULL &amp;&amp; java_home_var[0] != 0 &amp;&amp;
1860         strlen(java_home_var) &lt; (size_t)buflen) {
1861       strncpy(buf, java_home_var, buflen);
1862 
1863       // determine if this is a legacy image or modules image
1864       // modules image doesn't have "jre" subdirectory
1865       size_t len = strlen(buf);
1866       char* jrebin_p = buf + len;
1867       jio_snprintf(jrebin_p, buflen-len, "\\jre\\bin\\");
1868       if (0 != _access(buf, 0)) {
1869         jio_snprintf(jrebin_p, buflen-len, "\\bin\\");
1870       }
1871       len = strlen(buf);
1872       jio_snprintf(buf + len, buflen-len, "hotspot\\jvm.dll");
1873     }
1874   }
1875 
1876   if (buf[0] == '\0') {
1877     GetModuleFileName(vm_lib_handle, buf, buflen);
1878   }
1879   strncpy(saved_jvm_path, buf, MAX_PATH);
1880   saved_jvm_path[MAX_PATH - 1] = '\0';
1881 }
1882 
1883 
1884 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1885 #ifndef _WIN64
1886   st-&gt;print("_");
1887 #endif
1888 }
1889 
1890 
1891 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1892 #ifndef _WIN64
1893   st-&gt;print("@%d", args_size  * sizeof(int));
1894 #endif
1895 }
1896 
1897 // This method is a copy of JDK's sysGetLastErrorString
1898 // from src/windows/hpi/src/system_md.c
1899 
1900 size_t os::lasterror(char* buf, size_t len) {
1901   DWORD errval;
1902 
1903   if ((errval = GetLastError()) != 0) {
1904     // DOS error
1905     size_t n = (size_t)FormatMessage(
1906                                      FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
1907                                      NULL,
1908                                      errval,
1909                                      0,
1910                                      buf,
1911                                      (DWORD)len,
1912                                      NULL);
1913     if (n &gt; 3) {
1914       // Drop final '.', CR, LF
1915       if (buf[n - 1] == '\n') n--;
1916       if (buf[n - 1] == '\r') n--;
1917       if (buf[n - 1] == '.') n--;
1918       buf[n] = '\0';
1919     }
1920     return n;
1921   }
1922 
1923   if (errno != 0) {
1924     // C runtime error that has no corresponding DOS error code
1925     const char* s = os::strerror(errno);
1926     size_t n = strlen(s);
1927     if (n &gt;= len) n = len - 1;
1928     strncpy(buf, s, n);
1929     buf[n] = '\0';
1930     return n;
1931   }
1932 
1933   return 0;
1934 }
1935 
1936 int os::get_last_error() {
1937   DWORD error = GetLastError();
1938   if (error == 0) {
1939     error = errno;
1940   }
1941   return (int)error;
1942 }
1943 
1944 WindowsSemaphore::WindowsSemaphore(uint value) {
1945   _semaphore = ::CreateSemaphore(NULL, value, LONG_MAX, NULL);
1946 
1947   guarantee(_semaphore != NULL, "CreateSemaphore failed with error code: %lu", GetLastError());
1948 }
1949 
1950 WindowsSemaphore::~WindowsSemaphore() {
1951   ::CloseHandle(_semaphore);
1952 }
1953 
1954 void WindowsSemaphore::signal(uint count) {
1955   if (count &gt; 0) {
1956     BOOL ret = ::ReleaseSemaphore(_semaphore, count, NULL);
1957 
1958     assert(ret != 0, "ReleaseSemaphore failed with error code: %lu", GetLastError());
1959   }
1960 }
1961 
1962 void WindowsSemaphore::wait() {
1963   DWORD ret = ::WaitForSingleObject(_semaphore, INFINITE);
1964   assert(ret != WAIT_FAILED,   "WaitForSingleObject failed with error code: %lu", GetLastError());
1965   assert(ret == WAIT_OBJECT_0, "WaitForSingleObject failed with return value: %lu", ret);
1966 }
1967 
1968 // sun.misc.Signal
1969 // NOTE that this is a workaround for an apparent kernel bug where if
1970 // a signal handler for SIGBREAK is installed then that signal handler
1971 // takes priority over the console control handler for CTRL_CLOSE_EVENT.
1972 // See bug 4416763.
1973 static void (*sigbreakHandler)(int) = NULL;
1974 
1975 static void UserHandler(int sig, void *siginfo, void *context) {
1976   os::signal_notify(sig);
1977   // We need to reinstate the signal handler each time...
1978   os::signal(sig, (void*)UserHandler);
1979 }
1980 
1981 void* os::user_handler() {
1982   return (void*) UserHandler;
1983 }
1984 
1985 void* os::signal(int signal_number, void* handler) {
1986   if ((signal_number == SIGBREAK) &amp;&amp; (!ReduceSignalUsage)) {
1987     void (*oldHandler)(int) = sigbreakHandler;
1988     sigbreakHandler = (void (*)(int)) handler;
1989     return (void*) oldHandler;
1990   } else {
1991     return (void*)::signal(signal_number, (void (*)(int))handler);
1992   }
1993 }
1994 
1995 void os::signal_raise(int signal_number) {
1996   raise(signal_number);
1997 }
1998 
1999 // The Win32 C runtime library maps all console control events other than ^C
2000 // into SIGBREAK, which makes it impossible to distinguish ^BREAK from close,
2001 // logoff, and shutdown events.  We therefore install our own console handler
2002 // that raises SIGTERM for the latter cases.
2003 //
2004 static BOOL WINAPI consoleHandler(DWORD event) {
2005   switch (event) {
2006   case CTRL_C_EVENT:
2007     if (is_error_reported()) {
2008       // Ctrl-C is pressed during error reporting, likely because the error
2009       // handler fails to abort. Let VM die immediately.
2010       os::die();
2011     }
2012 
2013     os::signal_raise(SIGINT);
2014     return TRUE;
2015     break;
2016   case CTRL_BREAK_EVENT:
2017     if (sigbreakHandler != NULL) {
2018       (*sigbreakHandler)(SIGBREAK);
2019     }
2020     return TRUE;
2021     break;
2022   case CTRL_LOGOFF_EVENT: {
2023     // Don't terminate JVM if it is running in a non-interactive session,
2024     // such as a service process.
2025     USEROBJECTFLAGS flags;
2026     HANDLE handle = GetProcessWindowStation();
2027     if (handle != NULL &amp;&amp;
2028         GetUserObjectInformation(handle, UOI_FLAGS, &amp;flags,
2029         sizeof(USEROBJECTFLAGS), NULL)) {
2030       // If it is a non-interactive session, let next handler to deal
2031       // with it.
2032       if ((flags.dwFlags &amp; WSF_VISIBLE) == 0) {
2033         return FALSE;
2034       }
2035     }
2036   }
2037   case CTRL_CLOSE_EVENT:
2038   case CTRL_SHUTDOWN_EVENT:
2039     os::signal_raise(SIGTERM);
2040     return TRUE;
2041     break;
2042   default:
2043     break;
2044   }
2045   return FALSE;
2046 }
2047 
2048 // The following code is moved from os.cpp for making this
2049 // code platform specific, which it is by its very nature.
2050 
2051 // Return maximum OS signal used + 1 for internal use only
2052 // Used as exit signal for signal_thread
2053 int os::sigexitnum_pd() {
2054   return NSIG;
2055 }
2056 
2057 // a counter for each possible signal value, including signal_thread exit signal
2058 static volatile jint pending_signals[NSIG+1] = { 0 };
2059 static HANDLE sig_sem = NULL;
2060 
2061 void os::signal_init_pd() {
2062   // Initialize signal structures
2063   memset((void*)pending_signals, 0, sizeof(pending_signals));
2064 
2065   sig_sem = ::CreateSemaphore(NULL, 0, NSIG+1, NULL);
2066 
2067   // Programs embedding the VM do not want it to attempt to receive
2068   // events like CTRL_LOGOFF_EVENT, which are used to implement the
2069   // shutdown hooks mechanism introduced in 1.3.  For example, when
2070   // the VM is run as part of a Windows NT service (i.e., a servlet
2071   // engine in a web server), the correct behavior is for any console
2072   // control handler to return FALSE, not TRUE, because the OS's
2073   // "final" handler for such events allows the process to continue if
2074   // it is a service (while terminating it if it is not a service).
2075   // To make this behavior uniform and the mechanism simpler, we
2076   // completely disable the VM's usage of these console events if -Xrs
2077   // (=ReduceSignalUsage) is specified.  This means, for example, that
2078   // the CTRL-BREAK thread dump mechanism is also disabled in this
2079   // case.  See bugs 4323062, 4345157, and related bugs.
2080 
2081   if (!ReduceSignalUsage) {
2082     // Add a CTRL-C handler
2083     SetConsoleCtrlHandler(consoleHandler, TRUE);
2084   }
2085 }
2086 
2087 void os::signal_notify(int signal_number) {
2088   BOOL ret;
2089   if (sig_sem != NULL) {
2090     Atomic::inc(&amp;pending_signals[signal_number]);
2091     ret = ::ReleaseSemaphore(sig_sem, 1, NULL);
2092     assert(ret != 0, "ReleaseSemaphore() failed");
2093   }
2094 }
2095 
2096 static int check_pending_signals(bool wait_for_signal) {
2097   DWORD ret;
2098   while (true) {
2099     for (int i = 0; i &lt; NSIG + 1; i++) {
2100       jint n = pending_signals[i];
2101       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {
2102         return i;
2103       }
2104     }
2105     if (!wait_for_signal) {
2106       return -1;
2107     }
2108 
2109     JavaThread *thread = JavaThread::current();
2110 
2111     ThreadBlockInVM tbivm(thread);
2112 
2113     bool threadIsSuspended;
2114     do {
2115       thread-&gt;set_suspend_equivalent();
2116       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2117       ret = ::WaitForSingleObject(sig_sem, INFINITE);
2118       assert(ret == WAIT_OBJECT_0, "WaitForSingleObject() failed");
2119 
2120       // were we externally suspended while we were waiting?
2121       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2122       if (threadIsSuspended) {
2123         // The semaphore has been incremented, but while we were waiting
2124         // another thread suspended us. We don't want to continue running
2125         // while suspended because that would surprise the thread that
2126         // suspended us.
2127         ret = ::ReleaseSemaphore(sig_sem, 1, NULL);
2128         assert(ret != 0, "ReleaseSemaphore() failed");
2129 
2130         thread-&gt;java_suspend_self();
2131       }
2132     } while (threadIsSuspended);
2133   }
2134 }
2135 
2136 int os::signal_lookup() {
2137   return check_pending_signals(false);
2138 }
2139 
2140 int os::signal_wait() {
2141   return check_pending_signals(true);
2142 }
2143 
2144 // Implicit OS exception handling
2145 
2146 LONG Handle_Exception(struct _EXCEPTION_POINTERS* exceptionInfo,
2147                       address handler) {
2148     JavaThread* thread = (JavaThread*) Thread::current_or_null();
2149   // Save pc in thread
2150 #ifdef _M_IA64
2151   // Do not blow up if no thread info available.
2152   if (thread) {
2153     // Saving PRECISE pc (with slot information) in thread.
2154     uint64_t precise_pc = (uint64_t) exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress;
2155     // Convert precise PC into "Unix" format
2156     precise_pc = (precise_pc &amp; 0xFFFFFFFFFFFFFFF0) | ((precise_pc &amp; 0xF) &gt;&gt; 2);
2157     thread-&gt;set_saved_exception_pc((address)precise_pc);
2158   }
2159   // Set pc to handler
2160   exceptionInfo-&gt;ContextRecord-&gt;StIIP = (DWORD64)handler;
2161   // Clear out psr.ri (= Restart Instruction) in order to continue
2162   // at the beginning of the target bundle.
2163   exceptionInfo-&gt;ContextRecord-&gt;StIPSR &amp;= 0xFFFFF9FFFFFFFFFF;
2164   assert(((DWORD64)handler &amp; 0xF) == 0, "Target address must point to the beginning of a bundle!");
2165 #else
2166   #ifdef _M_AMD64
2167   // Do not blow up if no thread info available.
2168   if (thread) {
2169     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Rip);
2170   }
2171   // Set pc to handler
2172   exceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)handler;
2173   #else
2174   // Do not blow up if no thread info available.
2175   if (thread) {
2176     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Eip);
2177   }
2178   // Set pc to handler
2179   exceptionInfo-&gt;ContextRecord-&gt;Eip = (DWORD)(DWORD_PTR)handler;
2180   #endif
2181 #endif
2182 
2183   // Continue the execution
2184   return EXCEPTION_CONTINUE_EXECUTION;
2185 }
2186 
2187 
2188 // Used for PostMortemDump
2189 extern "C" void safepoints();
2190 extern "C" void find(int x);
2191 extern "C" void events();
2192 
2193 // According to Windows API documentation, an illegal instruction sequence should generate
2194 // the 0xC000001C exception code. However, real world experience shows that occasionnaly
2195 // the execution of an illegal instruction can generate the exception code 0xC000001E. This
2196 // seems to be an undocumented feature of Win NT 4.0 (and probably other Windows systems).
2197 
2198 #define EXCEPTION_ILLEGAL_INSTRUCTION_2 0xC000001E
2199 
2200 // From "Execution Protection in the Windows Operating System" draft 0.35
2201 // Once a system header becomes available, the "real" define should be
2202 // included or copied here.
2203 #define EXCEPTION_INFO_EXEC_VIOLATION 0x08
2204 
2205 // Handle NAT Bit consumption on IA64.
2206 #ifdef _M_IA64
2207   #define EXCEPTION_REG_NAT_CONSUMPTION    STATUS_REG_NAT_CONSUMPTION
2208 #endif
2209 
2210 // Windows Vista/2008 heap corruption check
2211 #define EXCEPTION_HEAP_CORRUPTION        0xC0000374
2212 
2213 // All Visual C++ exceptions thrown from code generated by the Microsoft Visual
2214 // C++ compiler contain this error code. Because this is a compiler-generated
2215 // error, the code is not listed in the Win32 API header files.
2216 // The code is actually a cryptic mnemonic device, with the initial "E"
2217 // standing for "exception" and the final 3 bytes (0x6D7363) representing the
2218 // ASCII values of "msc".
2219 
2220 #define EXCEPTION_UNCAUGHT_CXX_EXCEPTION    0xE06D7363
2221 
2222 #define def_excpt(val) { #val, (val) }
2223 
2224 static const struct { char* name; uint number; } exceptlabels[] = {
2225     def_excpt(EXCEPTION_ACCESS_VIOLATION),
2226     def_excpt(EXCEPTION_DATATYPE_MISALIGNMENT),
2227     def_excpt(EXCEPTION_BREAKPOINT),
2228     def_excpt(EXCEPTION_SINGLE_STEP),
2229     def_excpt(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
2230     def_excpt(EXCEPTION_FLT_DENORMAL_OPERAND),
2231     def_excpt(EXCEPTION_FLT_DIVIDE_BY_ZERO),
2232     def_excpt(EXCEPTION_FLT_INEXACT_RESULT),
2233     def_excpt(EXCEPTION_FLT_INVALID_OPERATION),
2234     def_excpt(EXCEPTION_FLT_OVERFLOW),
2235     def_excpt(EXCEPTION_FLT_STACK_CHECK),
2236     def_excpt(EXCEPTION_FLT_UNDERFLOW),
2237     def_excpt(EXCEPTION_INT_DIVIDE_BY_ZERO),
2238     def_excpt(EXCEPTION_INT_OVERFLOW),
2239     def_excpt(EXCEPTION_PRIV_INSTRUCTION),
2240     def_excpt(EXCEPTION_IN_PAGE_ERROR),
2241     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION),
2242     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION_2),
2243     def_excpt(EXCEPTION_NONCONTINUABLE_EXCEPTION),
2244     def_excpt(EXCEPTION_STACK_OVERFLOW),
2245     def_excpt(EXCEPTION_INVALID_DISPOSITION),
2246     def_excpt(EXCEPTION_GUARD_PAGE),
2247     def_excpt(EXCEPTION_INVALID_HANDLE),
2248     def_excpt(EXCEPTION_UNCAUGHT_CXX_EXCEPTION),
2249     def_excpt(EXCEPTION_HEAP_CORRUPTION)
2250 #ifdef _M_IA64
2251     , def_excpt(EXCEPTION_REG_NAT_CONSUMPTION)
2252 #endif
2253 };
2254 
2255 #undef def_excpt
2256 
2257 const char* os::exception_name(int exception_code, char *buf, size_t size) {
2258   uint code = static_cast&lt;uint&gt;(exception_code);
2259   for (uint i = 0; i &lt; ARRAY_SIZE(exceptlabels); ++i) {
2260     if (exceptlabels[i].number == code) {
2261       jio_snprintf(buf, size, "%s", exceptlabels[i].name);
2262       return buf;
2263     }
2264   }
2265 
2266   return NULL;
2267 }
2268 
2269 //-----------------------------------------------------------------------------
2270 LONG Handle_IDiv_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
2271   // handle exception caused by idiv; should only happen for -MinInt/-1
2272   // (division by zero is handled explicitly)
2273 #ifdef _M_IA64
2274   assert(0, "Fix Handle_IDiv_Exception");
2275 #else
2276   #ifdef  _M_AMD64
2277   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2278   address pc = (address)ctx-&gt;Rip;
2279   assert(pc[0] &gt;= Assembler::REX &amp;&amp; pc[0] &lt;= Assembler::REX_WRXB &amp;&amp; pc[1] == 0xF7 || pc[0] == 0xF7, "not an idiv opcode");
2280   assert(pc[0] &gt;= Assembler::REX &amp;&amp; pc[0] &lt;= Assembler::REX_WRXB &amp;&amp; (pc[2] &amp; ~0x7) == 0xF8 || (pc[1] &amp; ~0x7) == 0xF8, "cannot handle non-register operands");
2281   if (pc[0] == 0xF7) {
2282     // set correct result values and continue after idiv instruction
2283     ctx-&gt;Rip = (DWORD64)pc + 2;        // idiv reg, reg  is 2 bytes
2284   } else {
2285     ctx-&gt;Rip = (DWORD64)pc + 3;        // REX idiv reg, reg  is 3 bytes
2286   }
2287   // Do not set ctx-&gt;Rax as it already contains the correct value (either 32 or 64 bit, depending on the operation)
2288   // this is the case because the exception only happens for -MinValue/-1 and -MinValue is always in rax because of the
2289   // idiv opcode (0xF7).
2290   ctx-&gt;Rdx = (DWORD)0;             // remainder
2291   // Continue the execution
2292   #else
2293   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2294   address pc = (address)ctx-&gt;Eip;
2295   assert(pc[0] == 0xF7, "not an idiv opcode");
2296   assert((pc[1] &amp; ~0x7) == 0xF8, "cannot handle non-register operands");
2297   assert(ctx-&gt;Eax == min_jint, "unexpected idiv exception");
2298   // set correct result values and continue after idiv instruction
2299   ctx-&gt;Eip = (DWORD)pc + 2;        // idiv reg, reg  is 2 bytes
2300   ctx-&gt;Eax = (DWORD)min_jint;      // result
2301   ctx-&gt;Edx = (DWORD)0;             // remainder
2302   // Continue the execution
2303   #endif
2304 #endif
2305   return EXCEPTION_CONTINUE_EXECUTION;
2306 }
2307 
2308 //-----------------------------------------------------------------------------
2309 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
2310   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2311 #ifndef  _WIN64
2312   // handle exception caused by native method modifying control word
2313   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2314 
2315   switch (exception_code) {
2316   case EXCEPTION_FLT_DENORMAL_OPERAND:
2317   case EXCEPTION_FLT_DIVIDE_BY_ZERO:
2318   case EXCEPTION_FLT_INEXACT_RESULT:
2319   case EXCEPTION_FLT_INVALID_OPERATION:
2320   case EXCEPTION_FLT_OVERFLOW:
2321   case EXCEPTION_FLT_STACK_CHECK:
2322   case EXCEPTION_FLT_UNDERFLOW:
2323     jint fp_control_word = (* (jint*) StubRoutines::addr_fpu_cntrl_wrd_std());
2324     if (fp_control_word != ctx-&gt;FloatSave.ControlWord) {
2325       // Restore FPCW and mask out FLT exceptions
2326       ctx-&gt;FloatSave.ControlWord = fp_control_word | 0xffffffc0;
2327       // Mask out pending FLT exceptions
2328       ctx-&gt;FloatSave.StatusWord &amp;=  0xffffff00;
2329       return EXCEPTION_CONTINUE_EXECUTION;
2330     }
2331   }
2332 
2333   if (prev_uef_handler != NULL) {
2334     // We didn't handle this exception so pass it to the previous
2335     // UnhandledExceptionFilter.
2336     return (prev_uef_handler)(exceptionInfo);
2337   }
2338 #else // !_WIN64
2339   // On Windows, the mxcsr control bits are non-volatile across calls
2340   // See also CR 6192333
2341   //
2342   jint MxCsr = INITIAL_MXCSR;
2343   // we can't use StubRoutines::addr_mxcsr_std()
2344   // because in Win64 mxcsr is not saved there
2345   if (MxCsr != ctx-&gt;MxCsr) {
2346     ctx-&gt;MxCsr = MxCsr;
2347     return EXCEPTION_CONTINUE_EXECUTION;
2348   }
2349 #endif // !_WIN64
2350 
2351   return EXCEPTION_CONTINUE_SEARCH;
2352 }
2353 
2354 static inline void report_error(Thread* t, DWORD exception_code,
2355                                 address addr, void* siginfo, void* context) {
2356   VMError::report_and_die(t, exception_code, addr, siginfo, context);
2357 
2358   // If UseOsErrorReporting, this will return here and save the error file
2359   // somewhere where we can find it in the minidump.
2360 }
2361 
2362 bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,
2363         struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {
2364   PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2365   address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2366   if (Interpreter::contains(pc)) {
2367     *fr = os::fetch_frame_from_context((void*)exceptionInfo-&gt;ContextRecord);
2368     if (!fr-&gt;is_first_java_frame()) {
2369       // get_frame_at_stack_banging_point() is only called when we
2370       // have well defined stacks so java_sender() calls do not need
2371       // to assert safe_for_sender() first.
2372       *fr = fr-&gt;java_sender();
2373     }
2374   } else {
2375     // more complex code with compiled code
2376     assert(!Interpreter::contains(pc), "Interpreted methods should have been handled above");
2377     CodeBlob* cb = CodeCache::find_blob(pc);
2378     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
2379       // Not sure where the pc points to, fallback to default
2380       // stack overflow handling
2381       return false;
2382     } else {
2383       *fr = os::fetch_frame_from_context((void*)exceptionInfo-&gt;ContextRecord);
2384       // in compiled code, the stack banging is performed just after the return pc
2385       // has been pushed on the stack
2386       *fr = frame(fr-&gt;sp() + 1, fr-&gt;fp(), (address)*(fr-&gt;sp()));
2387       if (!fr-&gt;is_java_frame()) {
2388         // See java_sender() comment above.
2389         *fr = fr-&gt;java_sender();
2390       }
2391     }
2392   }
2393   assert(fr-&gt;is_java_frame(), "Safety check");
2394   return true;
2395 }
2396 
2397 //-----------------------------------------------------------------------------
2398 LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2399   if (InterceptOSException) return EXCEPTION_CONTINUE_SEARCH;
2400   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2401 #ifdef _M_IA64
2402   // On Itanium, we need the "precise pc", which has the slot number coded
2403   // into the least 4 bits: 0000=slot0, 0100=slot1, 1000=slot2 (Windows format).
2404   address pc = (address) exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress;
2405   // Convert the pc to "Unix format", which has the slot number coded
2406   // into the least 2 bits: 0000=slot0, 0001=slot1, 0010=slot2
2407   // This is needed for IA64 because "relocation" / "implicit null check" / "poll instruction"
2408   // information is saved in the Unix format.
2409   address pc_unix_format = (address) ((((uint64_t)pc) &amp; 0xFFFFFFFFFFFFFFF0) | ((((uint64_t)pc) &amp; 0xF) &gt;&gt; 2));
2410 #else
2411   #ifdef _M_AMD64
2412   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Rip;
2413   #else
2414   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
2415   #endif
2416 #endif
2417   Thread* t = Thread::current_or_null_safe();
2418 
2419   // Handle SafeFetch32 and SafeFetchN exceptions.
2420   if (StubRoutines::is_safefetch_fault(pc)) {
2421     return Handle_Exception(exceptionInfo, StubRoutines::continuation_for_safefetch_fault(pc));
2422   }
2423 
2424 #ifndef _WIN64
2425   // Execution protection violation - win32 running on AMD64 only
2426   // Handled first to avoid misdiagnosis as a "normal" access violation;
2427   // This is safe to do because we have a new/unique ExceptionInformation
2428   // code for this condition.
2429   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2430     PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2431     int exception_subcode = (int) exceptionRecord-&gt;ExceptionInformation[0];
2432     address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2433 
2434     if (exception_subcode == EXCEPTION_INFO_EXEC_VIOLATION) {
2435       int page_size = os::vm_page_size();
2436 
2437       // Make sure the pc and the faulting address are sane.
2438       //
2439       // If an instruction spans a page boundary, and the page containing
2440       // the beginning of the instruction is executable but the following
2441       // page is not, the pc and the faulting address might be slightly
2442       // different - we still want to unguard the 2nd page in this case.
2443       //
2444       // 15 bytes seems to be a (very) safe value for max instruction size.
2445       bool pc_is_near_addr =
2446         (pointer_delta((void*) addr, (void*) pc, sizeof(char)) &lt; 15);
2447       bool instr_spans_page_boundary =
2448         (align_size_down((intptr_t) pc ^ (intptr_t) addr,
2449                          (intptr_t) page_size) &gt; 0);
2450 
2451       if (pc == addr || (pc_is_near_addr &amp;&amp; instr_spans_page_boundary)) {
2452         static volatile address last_addr =
2453           (address) os::non_memory_address_word();
2454 
2455         // In conservative mode, don't unguard unless the address is in the VM
2456         if (UnguardOnExecutionViolation &gt; 0 &amp;&amp; addr != last_addr &amp;&amp;
2457             (UnguardOnExecutionViolation &gt; 1 || os::address_is_in_vm(addr))) {
2458 
2459           // Set memory to RWX and retry
2460           address page_start =
2461             (address) align_size_down((intptr_t) addr, (intptr_t) page_size);
2462           bool res = os::protect_memory((char*) page_start, page_size,
2463                                         os::MEM_PROT_RWX);
2464 
2465           log_debug(os)("Execution protection violation "
2466                         "at " INTPTR_FORMAT
2467                         ", unguarding " INTPTR_FORMAT ": %s", p2i(addr),
2468                         p2i(page_start), (res ? "success" : os::strerror(errno)));
2469 
2470           // Set last_addr so if we fault again at the same address, we don't
2471           // end up in an endless loop.
2472           //
2473           // There are two potential complications here.  Two threads trapping
2474           // at the same address at the same time could cause one of the
2475           // threads to think it already unguarded, and abort the VM.  Likely
2476           // very rare.
2477           //
2478           // The other race involves two threads alternately trapping at
2479           // different addresses and failing to unguard the page, resulting in
2480           // an endless loop.  This condition is probably even more unlikely
2481           // than the first.
2482           //
2483           // Although both cases could be avoided by using locks or thread
2484           // local last_addr, these solutions are unnecessary complication:
2485           // this handler is a best-effort safety net, not a complete solution.
2486           // It is disabled by default and should only be used as a workaround
2487           // in case we missed any no-execute-unsafe VM code.
2488 
2489           last_addr = addr;
2490 
2491           return EXCEPTION_CONTINUE_EXECUTION;
2492         }
2493       }
2494 
2495       // Last unguard failed or not unguarding
2496       tty-&gt;print_raw_cr("Execution protection violation");
2497       report_error(t, exception_code, addr, exceptionInfo-&gt;ExceptionRecord,
2498                    exceptionInfo-&gt;ContextRecord);
2499       return EXCEPTION_CONTINUE_SEARCH;
2500     }
2501   }
2502 #endif // _WIN64
2503 
2504   // Check to see if we caught the safepoint code in the
2505   // process of write protecting the memory serialization page.
2506   // It write enables the page immediately after protecting it
2507   // so just return.
2508   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2509     if (t != NULL &amp;&amp; t-&gt;is_Java_thread()) {
2510       JavaThread* thread = (JavaThread*) t;
2511       PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2512       address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2513       if (os::is_memory_serialize_page(thread, addr)) {
2514         // Block current thread until the memory serialize page permission restored.
2515         os::block_on_serialize_page_trap();
2516         return EXCEPTION_CONTINUE_EXECUTION;
2517       }
2518     }
2519   }
2520 
2521   if ((exception_code == EXCEPTION_ACCESS_VIOLATION) &amp;&amp;
2522       VM_Version::is_cpuinfo_segv_addr(pc)) {
2523     // Verify that OS save/restore AVX registers.
2524     return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr());
2525   }
2526 
2527   if (t != NULL &amp;&amp; t-&gt;is_Java_thread()) {
2528     JavaThread* thread = (JavaThread*) t;
2529     bool in_java = thread-&gt;thread_state() == _thread_in_Java;
2530 
2531     // Handle potential stack overflows up front.
2532     if (exception_code == EXCEPTION_STACK_OVERFLOW) {
2533 #ifdef _M_IA64
2534       // Use guard page for register stack.
2535       PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2536       address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2537       // Check for a register stack overflow on Itanium
2538       if (thread-&gt;addr_inside_register_stack_red_zone(addr)) {
2539         // Fatal red zone violation happens if the Java program
2540         // catches a StackOverflow error and does so much processing
2541         // that it runs beyond the unprotected yellow guard zone. As
2542         // a result, we are out of here.
2543         fatal("ERROR: Unrecoverable stack overflow happened. JVM will exit.");
2544       } else if(thread-&gt;addr_inside_register_stack(addr)) {
2545         // Disable the yellow zone which sets the state that
2546         // we've got a stack overflow problem.
2547         if (thread-&gt;stack_yellow_reserved_zone_enabled()) {
2548           thread-&gt;disable_stack_yellow_reserved_zone();
2549         }
2550         // Give us some room to process the exception.
2551         thread-&gt;disable_register_stack_guard();
2552         // Tracing with +Verbose.
2553         if (Verbose) {
2554           tty-&gt;print_cr("SOF Compiled Register Stack overflow at " INTPTR_FORMAT " (SIGSEGV)", pc);
2555           tty-&gt;print_cr("Register Stack access at " INTPTR_FORMAT, addr);
2556           tty-&gt;print_cr("Register Stack base " INTPTR_FORMAT, thread-&gt;register_stack_base());
2557           tty-&gt;print_cr("Register Stack [" INTPTR_FORMAT "," INTPTR_FORMAT "]",
2558                         thread-&gt;register_stack_base(),
2559                         thread-&gt;register_stack_base() + thread-&gt;stack_size());
2560         }
2561 
2562         // Reguard the permanent register stack red zone just to be sure.
2563         // We saw Windows silently disabling this without telling us.
2564         thread-&gt;enable_register_stack_red_zone();
2565 
2566         return Handle_Exception(exceptionInfo,
2567                                 SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW));
2568       }
2569 #endif
2570       if (thread-&gt;stack_guards_enabled()) {
2571         if (in_java) {
2572           frame fr;
2573           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2574           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2575           if (os::win32::get_frame_at_stack_banging_point(thread, exceptionInfo, pc, &amp;fr)) {
2576             assert(fr.is_java_frame(), "Must be a Java frame");
2577             SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
2578           }
2579         }
2580         // Yellow zone violation.  The o/s has unprotected the first yellow
2581         // zone page for us.  Note:  must call disable_stack_yellow_zone to
2582         // update the enabled status, even if the zone contains only one page.
2583         assert(thread-&gt;thread_state() != _thread_in_vm, "Undersized StackShadowPages");
2584         thread-&gt;disable_stack_yellow_reserved_zone();
2585         // If not in java code, return and hope for the best.
2586         return in_java
2587             ? Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW))
2588             :  EXCEPTION_CONTINUE_EXECUTION;
2589       } else {
2590         // Fatal red zone violation.
2591         thread-&gt;disable_stack_red_zone();
2592         tty-&gt;print_raw_cr("An unrecoverable stack overflow has occurred.");
2593         report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2594                       exceptionInfo-&gt;ContextRecord);
2595         return EXCEPTION_CONTINUE_SEARCH;
2596       }
2597     } else if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2598       // Either stack overflow or null pointer exception.
2599       if (in_java) {
2600         PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2601         address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2602         address stack_end = thread-&gt;stack_end();
2603         if (addr &lt; stack_end &amp;&amp; addr &gt;= stack_end - os::vm_page_size()) {
2604           // Stack overflow.
2605           assert(!os::uses_stack_guard_pages(),
2606                  "should be caught by red zone code above.");
2607           return Handle_Exception(exceptionInfo,
2608                                   SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW));
2609         }
2610         // Check for safepoint polling and implicit null
2611         // We only expect null pointers in the stubs (vtable)
2612         // the rest are checked explicitly now.
2613         CodeBlob* cb = CodeCache::find_blob(pc);
2614         if (cb != NULL) {
2615           if (os::is_poll_address(addr)) {
2616             address stub = SharedRuntime::get_poll_stub(pc);
2617             return Handle_Exception(exceptionInfo, stub);
2618           }
2619         }
2620         {
2621 #ifdef _WIN64
2622           // If it's a legal stack address map the entire region in
2623           //
2624           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2625           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2626           if (addr &gt; thread-&gt;stack_reserved_zone_base() &amp;&amp; addr &lt; thread-&gt;stack_base()) {
2627             addr = (address)((uintptr_t)addr &amp;
2628                              (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));
2629             os::commit_memory((char *)addr, thread-&gt;stack_base() - addr,
2630                               !ExecMem);
2631             return EXCEPTION_CONTINUE_EXECUTION;
2632           } else
2633 #endif
2634           {
2635             // Null pointer exception.
2636 #ifdef _M_IA64
2637             // Process implicit null checks in compiled code. Note: Implicit null checks
2638             // can happen even if "ImplicitNullChecks" is disabled, e.g. in vtable stubs.
2639             if (CodeCache::contains((void*) pc_unix_format) &amp;&amp; !MacroAssembler::needs_explicit_null_check((intptr_t) addr)) {
2640               CodeBlob *cb = CodeCache::find_blob_unsafe(pc_unix_format);
2641               // Handle implicit null check in UEP method entry
2642               if (cb &amp;&amp; (cb-&gt;is_frame_complete_at(pc) ||
2643                          (cb-&gt;is_nmethod() &amp;&amp; ((nmethod *)cb)-&gt;inlinecache_check_contains(pc)))) {
2644                 if (Verbose) {
2645                   intptr_t *bundle_start = (intptr_t*) ((intptr_t) pc_unix_format &amp; 0xFFFFFFFFFFFFFFF0);
2646                   tty-&gt;print_cr("trap: null_check at " INTPTR_FORMAT " (SIGSEGV)", pc_unix_format);
2647                   tty-&gt;print_cr("      to addr " INTPTR_FORMAT, addr);
2648                   tty-&gt;print_cr("      bundle is " INTPTR_FORMAT " (high), " INTPTR_FORMAT " (low)",
2649                                 *(bundle_start + 1), *bundle_start);
2650                 }
2651                 return Handle_Exception(exceptionInfo,
2652                                         SharedRuntime::continuation_for_implicit_exception(thread, pc_unix_format, SharedRuntime::IMPLICIT_NULL));
2653               }
2654             }
2655 
2656             // Implicit null checks were processed above.  Hence, we should not reach
2657             // here in the usual case =&gt; die!
2658             if (Verbose) tty-&gt;print_raw_cr("Access violation, possible null pointer exception");
2659             report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2660                          exceptionInfo-&gt;ContextRecord);
2661             return EXCEPTION_CONTINUE_SEARCH;
2662 
2663 #else // !IA64
2664 
2665             if (!MacroAssembler::needs_explicit_null_check((intptr_t)addr)) {
2666               address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
2667               if (stub != NULL) return Handle_Exception(exceptionInfo, stub);
2668             }
2669             report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2670                          exceptionInfo-&gt;ContextRecord);
2671             return EXCEPTION_CONTINUE_SEARCH;
2672 #endif
2673           }
2674         }
2675       }
2676 
2677 #ifdef _WIN64
2678       // Special care for fast JNI field accessors.
2679       // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc's if a GC kicks
2680       // in and the heap gets shrunk before the field access.
2681       if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2682         address addr = JNI_FastGetField::find_slowcase_pc(pc);
2683         if (addr != (address)-1) {
2684           return Handle_Exception(exceptionInfo, addr);
2685         }
2686       }
2687 #endif
2688 
2689       // Stack overflow or null pointer exception in native code.
2690       report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2691                    exceptionInfo-&gt;ContextRecord);
2692       return EXCEPTION_CONTINUE_SEARCH;
2693     } // /EXCEPTION_ACCESS_VIOLATION
2694     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2695 #if defined _M_IA64
2696     else if ((exception_code == EXCEPTION_ILLEGAL_INSTRUCTION ||
2697               exception_code == EXCEPTION_ILLEGAL_INSTRUCTION_2)) {
2698       M37 handle_wrong_method_break(0, NativeJump::HANDLE_WRONG_METHOD, PR0);
2699 
2700       // Compiled method patched to be non entrant? Following conditions must apply:
2701       // 1. must be first instruction in bundle
2702       // 2. must be a break instruction with appropriate code
2703       if ((((uint64_t) pc &amp; 0x0F) == 0) &amp;&amp;
2704           (((IPF_Bundle*) pc)-&gt;get_slot0() == handle_wrong_method_break.bits())) {
2705         return Handle_Exception(exceptionInfo,
2706                                 (address)SharedRuntime::get_handle_wrong_method_stub());
2707       }
2708     } // /EXCEPTION_ILLEGAL_INSTRUCTION
2709 #endif
2710 
2711 
2712     if (in_java) {
2713       switch (exception_code) {
2714       case EXCEPTION_INT_DIVIDE_BY_ZERO:
2715         return Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO));
2716 
2717       case EXCEPTION_INT_OVERFLOW:
2718         return Handle_IDiv_Exception(exceptionInfo);
2719 
2720       } // switch
2721     }
2722     if (((thread-&gt;thread_state() == _thread_in_Java) ||
2723          (thread-&gt;thread_state() == _thread_in_native)) &amp;&amp;
2724          exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {
2725       LONG result=Handle_FLT_Exception(exceptionInfo);
2726       if (result==EXCEPTION_CONTINUE_EXECUTION) return result;
2727     }
2728   }
2729 
2730   if (exception_code != EXCEPTION_BREAKPOINT) {
2731     report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2732                  exceptionInfo-&gt;ContextRecord);
2733   }
2734   return EXCEPTION_CONTINUE_SEARCH;
2735 }
2736 
2737 #ifndef _WIN64
2738 // Special care for fast JNI accessors.
2739 // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc's if a GC kicks in and
2740 // the heap gets shrunk before the field access.
2741 // Need to install our own structured exception handler since native code may
2742 // install its own.
2743 LONG WINAPI fastJNIAccessorExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2744   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2745   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2746     address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
2747     address addr = JNI_FastGetField::find_slowcase_pc(pc);
2748     if (addr != (address)-1) {
2749       return Handle_Exception(exceptionInfo, addr);
2750     }
2751   }
2752   return EXCEPTION_CONTINUE_SEARCH;
2753 }
2754 
2755 #define DEFINE_FAST_GETFIELD(Return, Fieldname, Result)                     \
2756   Return JNICALL jni_fast_Get##Result##Field_wrapper(JNIEnv *env,           \
2757                                                      jobject obj,           \
2758                                                      jfieldID fieldID) {    \
2759     __try {                                                                 \
2760       return (*JNI_FastGetField::jni_fast_Get##Result##Field_fp)(env,       \
2761                                                                  obj,       \
2762                                                                  fieldID);  \
2763     } __except(fastJNIAccessorExceptionFilter((_EXCEPTION_POINTERS*)        \
2764                                               _exception_info())) {         \
2765     }                                                                       \
2766     return 0;                                                               \
2767   }
2768 
2769 DEFINE_FAST_GETFIELD(jboolean, bool,   Boolean)
2770 DEFINE_FAST_GETFIELD(jbyte,    byte,   Byte)
2771 DEFINE_FAST_GETFIELD(jchar,    char,   Char)
2772 DEFINE_FAST_GETFIELD(jshort,   short,  Short)
2773 DEFINE_FAST_GETFIELD(jint,     int,    Int)
2774 DEFINE_FAST_GETFIELD(jlong,    long,   Long)
2775 DEFINE_FAST_GETFIELD(jfloat,   float,  Float)
2776 DEFINE_FAST_GETFIELD(jdouble,  double, Double)
2777 
2778 address os::win32::fast_jni_accessor_wrapper(BasicType type) {
2779   switch (type) {
2780   case T_BOOLEAN: return (address)jni_fast_GetBooleanField_wrapper;
2781   case T_BYTE:    return (address)jni_fast_GetByteField_wrapper;
2782   case T_CHAR:    return (address)jni_fast_GetCharField_wrapper;
2783   case T_SHORT:   return (address)jni_fast_GetShortField_wrapper;
2784   case T_INT:     return (address)jni_fast_GetIntField_wrapper;
2785   case T_LONG:    return (address)jni_fast_GetLongField_wrapper;
2786   case T_FLOAT:   return (address)jni_fast_GetFloatField_wrapper;
2787   case T_DOUBLE:  return (address)jni_fast_GetDoubleField_wrapper;
2788   default:        ShouldNotReachHere();
2789   }
2790   return (address)-1;
2791 }
2792 #endif
2793 
2794 // Virtual Memory
2795 
2796 int os::vm_page_size() { return os::win32::vm_page_size(); }
2797 int os::vm_allocation_granularity() {
2798   return os::win32::vm_allocation_granularity();
2799 }
2800 
2801 // Windows large page support is available on Windows 2003. In order to use
2802 // large page memory, the administrator must first assign additional privilege
2803 // to the user:
2804 //   + select Control Panel -&gt; Administrative Tools -&gt; Local Security Policy
2805 //   + select Local Policies -&gt; User Rights Assignment
2806 //   + double click "Lock pages in memory", add users and/or groups
2807 //   + reboot
2808 // Note the above steps are needed for administrator as well, as administrators
2809 // by default do not have the privilege to lock pages in memory.
2810 //
2811 // Note about Windows 2003: although the API supports committing large page
2812 // memory on a page-by-page basis and VirtualAlloc() returns success under this
2813 // scenario, I found through experiment it only uses large page if the entire
2814 // memory region is reserved and committed in a single VirtualAlloc() call.
2815 // This makes Windows large page support more or less like Solaris ISM, in
2816 // that the entire heap must be committed upfront. This probably will change
2817 // in the future, if so the code below needs to be revisited.
2818 
2819 #ifndef MEM_LARGE_PAGES
2820   #define MEM_LARGE_PAGES 0x20000000
2821 #endif
2822 
2823 static HANDLE    _hProcess;
2824 static HANDLE    _hToken;
2825 
2826 // Container for NUMA node list info
2827 class NUMANodeListHolder {
2828  private:
2829   int *_numa_used_node_list;  // allocated below
2830   int _numa_used_node_count;
2831 
2832   void free_node_list() {
2833     if (_numa_used_node_list != NULL) {
2834       FREE_C_HEAP_ARRAY(int, _numa_used_node_list);
2835     }
2836   }
2837 
2838  public:
2839   NUMANodeListHolder() {
2840     _numa_used_node_count = 0;
2841     _numa_used_node_list = NULL;
2842     // do rest of initialization in build routine (after function pointers are set up)
2843   }
2844 
2845   ~NUMANodeListHolder() {
2846     free_node_list();
2847   }
2848 
2849   bool build() {
2850     DWORD_PTR proc_aff_mask;
2851     DWORD_PTR sys_aff_mask;
2852     if (!GetProcessAffinityMask(GetCurrentProcess(), &amp;proc_aff_mask, &amp;sys_aff_mask)) return false;
2853     ULONG highest_node_number;
2854     if (!GetNumaHighestNodeNumber(&amp;highest_node_number)) return false;
2855     free_node_list();
2856     _numa_used_node_list = NEW_C_HEAP_ARRAY(int, highest_node_number + 1, mtInternal);
2857     for (unsigned int i = 0; i &lt;= highest_node_number; i++) {
2858       ULONGLONG proc_mask_numa_node;
2859       if (!GetNumaNodeProcessorMask(i, &amp;proc_mask_numa_node)) return false;
2860       if ((proc_aff_mask &amp; proc_mask_numa_node)!=0) {
2861         _numa_used_node_list[_numa_used_node_count++] = i;
2862       }
2863     }
2864     return (_numa_used_node_count &gt; 1);
2865   }
2866 
2867   int get_count() { return _numa_used_node_count; }
2868   int get_node_list_entry(int n) {
2869     // for indexes out of range, returns -1
2870     return (n &lt; _numa_used_node_count ? _numa_used_node_list[n] : -1);
2871   }
2872 
2873 } numa_node_list_holder;
2874 
2875 
2876 
2877 static size_t _large_page_size = 0;
2878 
2879 static bool request_lock_memory_privilege() {
2880   _hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,
2881                           os::current_process_id());
2882 
2883   LUID luid;
2884   if (_hProcess != NULL &amp;&amp;
2885       OpenProcessToken(_hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;_hToken) &amp;&amp;
2886       LookupPrivilegeValue(NULL, "SeLockMemoryPrivilege", &amp;luid)) {
2887 
2888     TOKEN_PRIVILEGES tp;
2889     tp.PrivilegeCount = 1;
2890     tp.Privileges[0].Luid = luid;
2891     tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
2892 
2893     // AdjustTokenPrivileges() may return TRUE even when it couldn't change the
2894     // privilege. Check GetLastError() too. See MSDN document.
2895     if (AdjustTokenPrivileges(_hToken, false, &amp;tp, sizeof(tp), NULL, NULL) &amp;&amp;
2896         (GetLastError() == ERROR_SUCCESS)) {
2897       return true;
2898     }
2899   }
2900 
2901   return false;
2902 }
2903 
2904 static void cleanup_after_large_page_init() {
2905   if (_hProcess) CloseHandle(_hProcess);
2906   _hProcess = NULL;
2907   if (_hToken) CloseHandle(_hToken);
2908   _hToken = NULL;
2909 }
2910 
2911 static bool numa_interleaving_init() {
2912   bool success = false;
2913   bool use_numa_interleaving_specified = !FLAG_IS_DEFAULT(UseNUMAInterleaving);
2914 
2915   // print a warning if UseNUMAInterleaving flag is specified on command line
2916   bool warn_on_failure = use_numa_interleaving_specified;
2917 #define WARN(msg) if (warn_on_failure) { warning(msg); }
2918 
2919   // NUMAInterleaveGranularity cannot be less than vm_allocation_granularity (or _large_page_size if using large pages)
2920   size_t min_interleave_granularity = UseLargePages ? _large_page_size : os::vm_allocation_granularity();
2921   NUMAInterleaveGranularity = align_size_up(NUMAInterleaveGranularity, min_interleave_granularity);
2922 
2923   if (numa_node_list_holder.build()) {
2924     if (log_is_enabled(Debug, os, cpu)) {
2925       Log(os, cpu) log;
2926       log.debug("NUMA UsedNodeCount=%d, namely ", numa_node_list_holder.get_count());
2927       for (int i = 0; i &lt; numa_node_list_holder.get_count(); i++) {
2928         log.debug("  %d ", numa_node_list_holder.get_node_list_entry(i));
2929       }
2930     }
2931     success = true;
2932   } else {
2933     WARN("Process does not cover multiple NUMA nodes.");
2934   }
2935   if (!success) {
2936     if (use_numa_interleaving_specified) WARN("...Ignoring UseNUMAInterleaving flag.");
2937   }
2938   return success;
2939 #undef WARN
2940 }
2941 
2942 // this routine is used whenever we need to reserve a contiguous VA range
2943 // but we need to make separate VirtualAlloc calls for each piece of the range
2944 // Reasons for doing this:
2945 //  * UseLargePagesIndividualAllocation was set (normally only needed on WS2003 but possible to be set otherwise)
2946 //  * UseNUMAInterleaving requires a separate node for each piece
2947 static char* allocate_pages_individually(size_t bytes, char* addr, DWORD flags,
2948                                          DWORD prot,
2949                                          bool should_inject_error = false) {
2950   char * p_buf;
2951   // note: at setup time we guaranteed that NUMAInterleaveGranularity was aligned up to a page size
2952   size_t page_size = UseLargePages ? _large_page_size : os::vm_allocation_granularity();
2953   size_t chunk_size = UseNUMAInterleaving ? NUMAInterleaveGranularity : page_size;
2954 
2955   // first reserve enough address space in advance since we want to be
2956   // able to break a single contiguous virtual address range into multiple
2957   // large page commits but WS2003 does not allow reserving large page space
2958   // so we just use 4K pages for reserve, this gives us a legal contiguous
2959   // address space. then we will deallocate that reservation, and re alloc
2960   // using large pages
2961   const size_t size_of_reserve = bytes + chunk_size;
2962   if (bytes &gt; size_of_reserve) {
2963     // Overflowed.
2964     return NULL;
2965   }
2966   p_buf = (char *) VirtualAlloc(addr,
2967                                 size_of_reserve,  // size of Reserve
2968                                 MEM_RESERVE,
2969                                 PAGE_READWRITE);
2970   // If reservation failed, return NULL
2971   if (p_buf == NULL) return NULL;
2972   MemTracker::record_virtual_memory_reserve((address)p_buf, size_of_reserve, CALLER_PC);
2973   os::release_memory(p_buf, bytes + chunk_size);
2974 
2975   // we still need to round up to a page boundary (in case we are using large pages)
2976   // but not to a chunk boundary (in case InterleavingGranularity doesn't align with page size)
2977   // instead we handle this in the bytes_to_rq computation below
2978   p_buf = (char *) align_size_up((size_t)p_buf, page_size);
2979 
2980   // now go through and allocate one chunk at a time until all bytes are
2981   // allocated
2982   size_t  bytes_remaining = bytes;
2983   // An overflow of align_size_up() would have been caught above
2984   // in the calculation of size_of_reserve.
2985   char * next_alloc_addr = p_buf;
2986   HANDLE hProc = GetCurrentProcess();
2987 
2988 #ifdef ASSERT
2989   // Variable for the failure injection
2990   long ran_num = os::random();
2991   size_t fail_after = ran_num % bytes;
2992 #endif
2993 
2994   int count=0;
2995   while (bytes_remaining) {
2996     // select bytes_to_rq to get to the next chunk_size boundary
2997 
2998     size_t bytes_to_rq = MIN2(bytes_remaining, chunk_size - ((size_t)next_alloc_addr % chunk_size));
2999     // Note allocate and commit
3000     char * p_new;
3001 
3002 #ifdef ASSERT
3003     bool inject_error_now = should_inject_error &amp;&amp; (bytes_remaining &lt;= fail_after);
3004 #else
3005     const bool inject_error_now = false;
3006 #endif
3007 
3008     if (inject_error_now) {
3009       p_new = NULL;
3010     } else {
3011       if (!UseNUMAInterleaving) {
3012         p_new = (char *) VirtualAlloc(next_alloc_addr,
3013                                       bytes_to_rq,
3014                                       flags,
3015                                       prot);
3016       } else {
3017         // get the next node to use from the used_node_list
3018         assert(numa_node_list_holder.get_count() &gt; 0, "Multiple NUMA nodes expected");
3019         DWORD node = numa_node_list_holder.get_node_list_entry(count % numa_node_list_holder.get_count());
3020         p_new = (char *)VirtualAllocExNuma(hProc, next_alloc_addr, bytes_to_rq, flags, prot, node);
3021       }
3022     }
3023 
3024     if (p_new == NULL) {
3025       // Free any allocated pages
3026       if (next_alloc_addr &gt; p_buf) {
3027         // Some memory was committed so release it.
3028         size_t bytes_to_release = bytes - bytes_remaining;
3029         // NMT has yet to record any individual blocks, so it
3030         // need to create a dummy 'reserve' record to match
3031         // the release.
3032         MemTracker::record_virtual_memory_reserve((address)p_buf,
3033                                                   bytes_to_release, CALLER_PC);
3034         os::release_memory(p_buf, bytes_to_release);
3035       }
3036 #ifdef ASSERT
3037       if (should_inject_error) {
3038         log_develop_debug(pagesize)("Reserving pages individually failed.");
3039       }
3040 #endif
3041       return NULL;
3042     }
3043 
3044     bytes_remaining -= bytes_to_rq;
3045     next_alloc_addr += bytes_to_rq;
3046     count++;
3047   }
3048   // Although the memory is allocated individually, it is returned as one.
3049   // NMT records it as one block.
3050   if ((flags &amp; MEM_COMMIT) != 0) {
3051     MemTracker::record_virtual_memory_reserve_and_commit((address)p_buf, bytes, CALLER_PC);
3052   } else {
3053     MemTracker::record_virtual_memory_reserve((address)p_buf, bytes, CALLER_PC);
3054   }
3055 
3056   // made it this far, success
3057   return p_buf;
3058 }
3059 
3060 
3061 
3062 void os::large_page_init() {
3063   if (!UseLargePages) return;
3064 
3065   // print a warning if any large page related flag is specified on command line
3066   bool warn_on_failure = !FLAG_IS_DEFAULT(UseLargePages) ||
3067                          !FLAG_IS_DEFAULT(LargePageSizeInBytes);
3068   bool success = false;
3069 
3070 #define WARN(msg) if (warn_on_failure) { warning(msg); }
3071   if (request_lock_memory_privilege()) {
3072     size_t s = GetLargePageMinimum();
3073     if (s) {
3074 #if defined(IA32) || defined(AMD64)
3075       if (s &gt; 4*M || LargePageSizeInBytes &gt; 4*M) {
3076         WARN("JVM cannot use large pages bigger than 4mb.");
3077       } else {
3078 #endif
3079         if (LargePageSizeInBytes &amp;&amp; LargePageSizeInBytes % s == 0) {
3080           _large_page_size = LargePageSizeInBytes;
3081         } else {
3082           _large_page_size = s;
3083         }
3084         success = true;
3085 #if defined(IA32) || defined(AMD64)
3086       }
3087 #endif
3088     } else {
3089       WARN("Large page is not supported by the processor.");
3090     }
3091   } else {
3092     WARN("JVM cannot use large page memory because it does not have enough privilege to lock pages in memory.");
3093   }
3094 #undef WARN
3095 
3096   const size_t default_page_size = (size_t) vm_page_size();
3097   if (success &amp;&amp; _large_page_size &gt; default_page_size) {
3098     _page_sizes[0] = _large_page_size;
3099     _page_sizes[1] = default_page_size;
3100     _page_sizes[2] = 0;
3101   }
3102 
3103   cleanup_after_large_page_init();
3104   UseLargePages = success;
3105 }
3106 
3107 // On win32, one cannot release just a part of reserved memory, it's an
3108 // all or nothing deal.  When we split a reservation, we must break the
3109 // reservation into two reservations.
3110 void os::pd_split_reserved_memory(char *base, size_t size, size_t split,
3111                                   bool realloc) {
3112   if (size &gt; 0) {
3113     release_memory(base, size);
3114     if (realloc) {
3115       reserve_memory(split, base);
3116     }
3117     if (size != split) {
3118       reserve_memory(size - split, base + split);
3119     }
3120   }
3121 }
3122 
3123 // Multiple threads can race in this code but it's not possible to unmap small sections of
3124 // virtual space to get requested alignment, like posix-like os's.
3125 // Windows prevents multiple thread from remapping over each other so this loop is thread-safe.
3126 char* os::reserve_memory_aligned(size_t size, size_t alignment) {
3127   assert((alignment &amp; (os::vm_allocation_granularity() - 1)) == 0,
3128          "Alignment must be a multiple of allocation granularity (page size)");
3129   assert((size &amp; (alignment -1)) == 0, "size must be 'alignment' aligned");
3130 
3131   size_t extra_size = size + alignment;
3132   assert(extra_size &gt;= size, "overflow, size is too large to allow alignment");
3133 
3134   char* aligned_base = NULL;
3135 
3136   do {
3137     char* extra_base = os::reserve_memory(extra_size, NULL, alignment);
3138     if (extra_base == NULL) {
3139       return NULL;
3140     }
3141     // Do manual alignment
3142     aligned_base = (char*) align_size_up((uintptr_t) extra_base, alignment);
3143 
3144     os::release_memory(extra_base, extra_size);
3145 
3146     aligned_base = os::reserve_memory(size, aligned_base);
3147 
3148   } while (aligned_base == NULL);
3149 
3150   return aligned_base;
3151 }
3152 
3153 char* os::pd_reserve_memory(size_t bytes, char* addr, size_t alignment_hint) {
3154   assert((size_t)addr % os::vm_allocation_granularity() == 0,
3155          "reserve alignment");
3156   assert(bytes % os::vm_page_size() == 0, "reserve page size");
3157   char* res;
3158   // note that if UseLargePages is on, all the areas that require interleaving
3159   // will go thru reserve_memory_special rather than thru here.
3160   bool use_individual = (UseNUMAInterleaving &amp;&amp; !UseLargePages);
3161   if (!use_individual) {
3162     res = (char*)VirtualAlloc(addr, bytes, MEM_RESERVE, PAGE_READWRITE);
3163   } else {
3164     elapsedTimer reserveTimer;
3165     if (Verbose &amp;&amp; PrintMiscellaneous) reserveTimer.start();
3166     // in numa interleaving, we have to allocate pages individually
3167     // (well really chunks of NUMAInterleaveGranularity size)
3168     res = allocate_pages_individually(bytes, addr, MEM_RESERVE, PAGE_READWRITE);
3169     if (res == NULL) {
3170       warning("NUMA page allocation failed");
3171     }
3172     if (Verbose &amp;&amp; PrintMiscellaneous) {
3173       reserveTimer.stop();
3174       tty-&gt;print_cr("reserve_memory of %Ix bytes took " JLONG_FORMAT " ms (" JLONG_FORMAT " ticks)", bytes,
3175                     reserveTimer.milliseconds(), reserveTimer.ticks());
3176     }
3177   }
3178   assert(res == NULL || addr == NULL || addr == res,
3179          "Unexpected address from reserve.");
3180 
3181   return res;
3182 }
3183 
3184 // Reserve memory at an arbitrary address, only if that area is
3185 // available (and not reserved for something else).
3186 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
3187   // Windows os::reserve_memory() fails of the requested address range is
3188   // not avilable.
3189   return reserve_memory(bytes, requested_addr);
3190 }
3191 
3192 size_t os::large_page_size() {
3193   return _large_page_size;
3194 }
3195 
3196 bool os::can_commit_large_page_memory() {
3197   // Windows only uses large page memory when the entire region is reserved
3198   // and committed in a single VirtualAlloc() call. This may change in the
3199   // future, but with Windows 2003 it's not possible to commit on demand.
3200   return false;
3201 }
3202 
3203 bool os::can_execute_large_page_memory() {
3204   return true;
3205 }
3206 
3207 char* os::reserve_memory_special(size_t bytes, size_t alignment, char* addr,
3208                                  bool exec) {
3209   assert(UseLargePages, "only for large pages");
3210 
3211   if (!is_size_aligned(bytes, os::large_page_size()) || alignment &gt; os::large_page_size()) {
3212     return NULL; // Fallback to small pages.
3213   }
3214 
3215   const DWORD prot = exec ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
3216   const DWORD flags = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3217 
3218   // with large pages, there are two cases where we need to use Individual Allocation
3219   // 1) the UseLargePagesIndividualAllocation flag is set (set by default on WS2003)
3220   // 2) NUMA Interleaving is enabled, in which case we use a different node for each page
3221   if (UseLargePagesIndividualAllocation || UseNUMAInterleaving) {
3222     log_debug(pagesize)("Reserving large pages individually.");
3223 
3224     char * p_buf = allocate_pages_individually(bytes, addr, flags, prot, LargePagesIndividualAllocationInjectError);
3225     if (p_buf == NULL) {
3226       // give an appropriate warning message
3227       if (UseNUMAInterleaving) {
3228         warning("NUMA large page allocation failed, UseLargePages flag ignored");
3229       }
3230       if (UseLargePagesIndividualAllocation) {
3231         warning("Individually allocated large pages failed, "
3232                 "use -XX:-UseLargePagesIndividualAllocation to turn off");
3233       }
3234       return NULL;
3235     }
3236 
3237     return p_buf;
3238 
3239   } else {
3240     log_debug(pagesize)("Reserving large pages in a single large chunk.");
3241 
3242     // normal policy just allocate it all at once
3243     DWORD flag = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3244     char * res = (char *)VirtualAlloc(addr, bytes, flag, prot);
3245     if (res != NULL) {
3246       MemTracker::record_virtual_memory_reserve_and_commit((address)res, bytes, CALLER_PC);
3247     }
3248 
3249     return res;
3250   }
3251 }
3252 
3253 bool os::release_memory_special(char* base, size_t bytes) {
3254   assert(base != NULL, "Sanity check");
3255   return release_memory(base, bytes);
3256 }
3257 
3258 void os::print_statistics() {
3259 }
3260 
3261 static void warn_fail_commit_memory(char* addr, size_t bytes, bool exec) {
3262   int err = os::get_last_error();
3263   char buf[256];
3264   size_t buf_len = os::lasterror(buf, sizeof(buf));
3265   warning("INFO: os::commit_memory(" PTR_FORMAT ", " SIZE_FORMAT
3266           ", %d) failed; error='%s' (DOS error/errno=%d)", addr, bytes,
3267           exec, buf_len != 0 ? buf : "&lt;no_error_string&gt;", err);
3268 }
3269 
3270 bool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {
3271   if (bytes == 0) {
3272     // Don't bother the OS with noops.
3273     return true;
3274   }
3275   assert((size_t) addr % os::vm_page_size() == 0, "commit on page boundaries");
3276   assert(bytes % os::vm_page_size() == 0, "commit in page-sized chunks");
3277   // Don't attempt to print anything if the OS call fails. We're
3278   // probably low on resources, so the print itself may cause crashes.
3279 
3280   // unless we have NUMAInterleaving enabled, the range of a commit
3281   // is always within a reserve covered by a single VirtualAlloc
3282   // in that case we can just do a single commit for the requested size
3283   if (!UseNUMAInterleaving) {
3284     if (VirtualAlloc(addr, bytes, MEM_COMMIT, PAGE_READWRITE) == NULL) {
3285       NOT_PRODUCT(warn_fail_commit_memory(addr, bytes, exec);)
3286       return false;
3287     }
3288     if (exec) {
3289       DWORD oldprot;
3290       // Windows doc says to use VirtualProtect to get execute permissions
3291       if (!VirtualProtect(addr, bytes, PAGE_EXECUTE_READWRITE, &amp;oldprot)) {
3292         NOT_PRODUCT(warn_fail_commit_memory(addr, bytes, exec);)
3293         return false;
3294       }
3295     }
3296     return true;
3297   } else {
3298 
3299     // when NUMAInterleaving is enabled, the commit might cover a range that
3300     // came from multiple VirtualAlloc reserves (using allocate_pages_individually).
3301     // VirtualQuery can help us determine that.  The RegionSize that VirtualQuery
3302     // returns represents the number of bytes that can be committed in one step.
3303     size_t bytes_remaining = bytes;
3304     char * next_alloc_addr = addr;
3305     while (bytes_remaining &gt; 0) {
3306       MEMORY_BASIC_INFORMATION alloc_info;
3307       VirtualQuery(next_alloc_addr, &amp;alloc_info, sizeof(alloc_info));
3308       size_t bytes_to_rq = MIN2(bytes_remaining, (size_t)alloc_info.RegionSize);
3309       if (VirtualAlloc(next_alloc_addr, bytes_to_rq, MEM_COMMIT,
3310                        PAGE_READWRITE) == NULL) {
3311         NOT_PRODUCT(warn_fail_commit_memory(next_alloc_addr, bytes_to_rq,
3312                                             exec);)
3313         return false;
3314       }
3315       if (exec) {
3316         DWORD oldprot;
3317         if (!VirtualProtect(next_alloc_addr, bytes_to_rq,
3318                             PAGE_EXECUTE_READWRITE, &amp;oldprot)) {
3319           NOT_PRODUCT(warn_fail_commit_memory(next_alloc_addr, bytes_to_rq,
3320                                               exec);)
3321           return false;
3322         }
3323       }
3324       bytes_remaining -= bytes_to_rq;
3325       next_alloc_addr += bytes_to_rq;
3326     }
3327   }
3328   // if we made it this far, return true
3329   return true;
3330 }
3331 
3332 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
3333                           bool exec) {
3334   // alignment_hint is ignored on this OS
3335   return pd_commit_memory(addr, size, exec);
3336 }
3337 
3338 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
3339                                   const char* mesg) {
3340   assert(mesg != NULL, "mesg must be specified");
3341   if (!pd_commit_memory(addr, size, exec)) {
3342     warn_fail_commit_memory(addr, size, exec);
3343     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, "%s", mesg);
3344   }
3345 }
3346 
3347 void os::pd_commit_memory_or_exit(char* addr, size_t size,
3348                                   size_t alignment_hint, bool exec,
3349                                   const char* mesg) {
3350   // alignment_hint is ignored on this OS
3351   pd_commit_memory_or_exit(addr, size, exec, mesg);
3352 }
3353 
3354 bool os::pd_uncommit_memory(char* addr, size_t bytes) {
3355   if (bytes == 0) {
3356     // Don't bother the OS with noops.
3357     return true;
3358   }
3359   assert((size_t) addr % os::vm_page_size() == 0, "uncommit on page boundaries");
3360   assert(bytes % os::vm_page_size() == 0, "uncommit in page-sized chunks");
3361   return (VirtualFree(addr, bytes, MEM_DECOMMIT) != 0);
3362 }
3363 
3364 bool os::pd_release_memory(char* addr, size_t bytes) {
3365   return VirtualFree(addr, 0, MEM_RELEASE) != 0;
3366 }
3367 
3368 bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
3369   return os::commit_memory(addr, size, !ExecMem);
3370 }
3371 
3372 bool os::remove_stack_guard_pages(char* addr, size_t size) {
3373   return os::uncommit_memory(addr, size);
3374 }
3375 
3376 static bool protect_pages_individually(char* addr, size_t bytes, unsigned int p, DWORD *old_status) {
3377   uint count = 0;
3378   bool ret = false;
3379   size_t bytes_remaining = bytes;
3380   char * next_protect_addr = addr;
3381 
3382   // Use VirtualQuery() to get the chunk size.
3383   while (bytes_remaining) {
3384     MEMORY_BASIC_INFORMATION alloc_info;
3385     if (VirtualQuery(next_protect_addr, &amp;alloc_info, sizeof(alloc_info)) == 0) {
3386       return false;
3387     }
3388 
3389     size_t bytes_to_protect = MIN2(bytes_remaining, (size_t)alloc_info.RegionSize);
3390     // We used different API at allocate_pages_individually() based on UseNUMAInterleaving,
3391     // but we don't distinguish here as both cases are protected by same API.
3392     ret = VirtualProtect(next_protect_addr, bytes_to_protect, p, old_status) != 0;
3393     warning("Failed protecting pages individually for chunk #%u", count);
3394     if (!ret) {
3395       return false;
3396     }
3397 
3398     bytes_remaining -= bytes_to_protect;
3399     next_protect_addr += bytes_to_protect;
3400     count++;
3401   }
3402   return ret;
3403 }
3404 
3405 // Set protections specified
3406 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
3407                         bool is_committed) {
3408   unsigned int p = 0;
3409   switch (prot) {
3410   case MEM_PROT_NONE: p = PAGE_NOACCESS; break;
3411   case MEM_PROT_READ: p = PAGE_READONLY; break;
3412   case MEM_PROT_RW:   p = PAGE_READWRITE; break;
3413   case MEM_PROT_RWX:  p = PAGE_EXECUTE_READWRITE; break;
3414   default:
3415     ShouldNotReachHere();
3416   }
3417 
3418   DWORD old_status;
3419 
3420   // Strange enough, but on Win32 one can change protection only for committed
3421   // memory, not a big deal anyway, as bytes less or equal than 64K
3422   if (!is_committed) {
3423     commit_memory_or_exit(addr, bytes, prot == MEM_PROT_RWX,
3424                           "cannot commit protection page");
3425   }
3426   // One cannot use os::guard_memory() here, as on Win32 guard page
3427   // have different (one-shot) semantics, from MSDN on PAGE_GUARD:
3428   //
3429   // Pages in the region become guard pages. Any attempt to access a guard page
3430   // causes the system to raise a STATUS_GUARD_PAGE exception and turn off
3431   // the guard page status. Guard pages thus act as a one-time access alarm.
3432   bool ret;
3433   if (UseNUMAInterleaving) {
3434     // If UseNUMAInterleaving is enabled, the pages may have been allocated a chunk at a time,
3435     // so we must protect the chunks individually.
3436     ret = protect_pages_individually(addr, bytes, p, &amp;old_status);
3437   } else {
3438     ret = VirtualProtect(addr, bytes, p, &amp;old_status) != 0;
3439   }
3440 #ifdef ASSERT
3441   if (!ret) {
3442     int err = os::get_last_error();
3443     char buf[256];
3444     size_t buf_len = os::lasterror(buf, sizeof(buf));
3445     warning("INFO: os::protect_memory(" PTR_FORMAT ", " SIZE_FORMAT
3446           ") failed; error='%s' (DOS error/errno=%d)", addr, bytes,
3447           buf_len != 0 ? buf : "&lt;no_error_string&gt;", err);
3448   }
3449 #endif
3450   return ret;
3451 }
3452 
3453 bool os::guard_memory(char* addr, size_t bytes) {
3454   DWORD old_status;
3455   return VirtualProtect(addr, bytes, PAGE_READWRITE | PAGE_GUARD, &amp;old_status) != 0;
3456 }
3457 
3458 bool os::unguard_memory(char* addr, size_t bytes) {
3459   DWORD old_status;
3460   return VirtualProtect(addr, bytes, PAGE_READWRITE, &amp;old_status) != 0;
3461 }
3462 
3463 void os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) { }
3464 void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) { }
3465 void os::numa_make_global(char *addr, size_t bytes)    { }
3466 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint)    { }
3467 bool os::numa_topology_changed()                       { return false; }
3468 size_t os::numa_get_groups_num()                       { return MAX2(numa_node_list_holder.get_count(), 1); }
3469 int os::numa_get_group_id()                            { return 0; }
3470 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
3471   if (numa_node_list_holder.get_count() == 0 &amp;&amp; size &gt; 0) {
3472     // Provide an answer for UMA systems
3473     ids[0] = 0;
3474     return 1;
3475   } else {
3476     // check for size bigger than actual groups_num
3477     size = MIN2(size, numa_get_groups_num());
3478     for (int i = 0; i &lt; (int)size; i++) {
3479       ids[i] = numa_node_list_holder.get_node_list_entry(i);
3480     }
3481     return size;
3482   }
3483 }
3484 
3485 bool os::get_page_info(char *start, page_info* info) {
3486   return false;
3487 }
3488 
3489 char *os::scan_pages(char *start, char* end, page_info* page_expected,
3490                      page_info* page_found) {
3491   return end;
3492 }
3493 
3494 char* os::non_memory_address_word() {
3495   // Must never look like an address returned by reserve_memory,
3496   // even in its subfields (as defined by the CPU immediate fields,
3497   // if the CPU splits constants across multiple instructions).
3498   return (char*)-1;
3499 }
3500 
3501 #define MAX_ERROR_COUNT 100
3502 #define SYS_THREAD_ERROR 0xffffffffUL
3503 
3504 void os::pd_start_thread(Thread* thread) {
3505   DWORD ret = ResumeThread(thread-&gt;osthread()-&gt;thread_handle());
3506   // Returns previous suspend state:
3507   // 0:  Thread was not suspended
3508   // 1:  Thread is running now
3509   // &gt;1: Thread is still suspended.
3510   assert(ret != SYS_THREAD_ERROR, "StartThread failed"); // should propagate back
3511 }
3512 
3513 class HighResolutionInterval : public CHeapObj&lt;mtThread&gt; {
3514   // The default timer resolution seems to be 10 milliseconds.
3515   // (Where is this written down?)
3516   // If someone wants to sleep for only a fraction of the default,
3517   // then we set the timer resolution down to 1 millisecond for
3518   // the duration of their interval.
3519   // We carefully set the resolution back, since otherwise we
3520   // seem to incur an overhead (3%?) that we don't need.
3521   // CONSIDER: if ms is small, say 3, then we should run with a high resolution time.
3522   // Buf if ms is large, say 500, or 503, we should avoid the call to timeBeginPeriod().
3523   // Alternatively, we could compute the relative error (503/500 = .6%) and only use
3524   // timeBeginPeriod() if the relative error exceeded some threshold.
3525   // timeBeginPeriod() has been linked to problems with clock drift on win32 systems and
3526   // to decreased efficiency related to increased timer "tick" rates.  We want to minimize
3527   // (a) calls to timeBeginPeriod() and timeEndPeriod() and (b) time spent with high
3528   // resolution timers running.
3529  private:
3530   jlong resolution;
3531  public:
3532   HighResolutionInterval(jlong ms) {
3533     resolution = ms % 10L;
3534     if (resolution != 0) {
3535       MMRESULT result = timeBeginPeriod(1L);
3536     }
3537   }
3538   ~HighResolutionInterval() {
3539     if (resolution != 0) {
3540       MMRESULT result = timeEndPeriod(1L);
3541     }
3542     resolution = 0L;
3543   }
3544 };
3545 
3546 int os::sleep(Thread* thread, jlong ms, bool interruptable) {
3547   jlong limit = (jlong) MAXDWORD;
3548 
3549   while (ms &gt; limit) {
3550     int res;
3551     if ((res = sleep(thread, limit, interruptable)) != OS_TIMEOUT) {
3552       return res;
3553     }
3554     ms -= limit;
3555   }
3556 
3557   assert(thread == Thread::current(), "thread consistency check");
3558   OSThread* osthread = thread-&gt;osthread();
3559   OSThreadWaitState osts(osthread, false /* not Object.wait() */);
3560   int result;
3561   if (interruptable) {
3562     assert(thread-&gt;is_Java_thread(), "must be java thread");
3563     JavaThread *jt = (JavaThread *) thread;
3564     ThreadBlockInVM tbivm(jt);
3565 
3566     jt-&gt;set_suspend_equivalent();
3567     // cleared by handle_special_suspend_equivalent_condition() or
3568     // java_suspend_self() via check_and_wait_while_suspended()
3569 
3570     HANDLE events[1];
3571     events[0] = osthread-&gt;interrupt_event();
3572     HighResolutionInterval *phri=NULL;
3573     if (!ForceTimeHighResolution) {
3574       phri = new HighResolutionInterval(ms);
3575     }
3576     if (WaitForMultipleObjects(1, events, FALSE, (DWORD)ms) == WAIT_TIMEOUT) {
3577       result = OS_TIMEOUT;
3578     } else {
3579       ResetEvent(osthread-&gt;interrupt_event());
3580       osthread-&gt;set_interrupted(false);
3581       result = OS_INTRPT;
3582     }
3583     delete phri; //if it is NULL, harmless
3584 
3585     // were we externally suspended while we were waiting?
3586     jt-&gt;check_and_wait_while_suspended();
3587   } else {
3588     assert(!thread-&gt;is_Java_thread(), "must not be java thread");
3589     Sleep((long) ms);
3590     result = OS_TIMEOUT;
3591   }
3592   return result;
3593 }
3594 
3595 // Short sleep, direct OS call.
3596 //
3597 // ms = 0, means allow others (if any) to run.
3598 //
3599 void os::naked_short_sleep(jlong ms) {
3600   assert(ms &lt; 1000, "Un-interruptable sleep, short time use only");
3601   Sleep(ms);
3602 }
3603 
3604 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
3605 void os::infinite_sleep() {
3606   while (true) {    // sleep forever ...
3607     Sleep(100000);  // ... 100 seconds at a time
3608   }
3609 }
3610 
3611 typedef BOOL (WINAPI * STTSignature)(void);
3612 
3613 void os::naked_yield() {
3614   // Consider passing back the return value from SwitchToThread().
3615   SwitchToThread();
3616 }
3617 
3618 // Win32 only gives you access to seven real priorities at a time,
3619 // so we compress Java's ten down to seven.  It would be better
3620 // if we dynamically adjusted relative priorities.
3621 
3622 int os::java_to_os_priority[CriticalPriority + 1] = {
3623   THREAD_PRIORITY_IDLE,                         // 0  Entry should never be used
3624   THREAD_PRIORITY_LOWEST,                       // 1  MinPriority
3625   THREAD_PRIORITY_LOWEST,                       // 2
3626   THREAD_PRIORITY_BELOW_NORMAL,                 // 3
3627   THREAD_PRIORITY_BELOW_NORMAL,                 // 4
3628   THREAD_PRIORITY_NORMAL,                       // 5  NormPriority
3629   THREAD_PRIORITY_NORMAL,                       // 6
3630   THREAD_PRIORITY_ABOVE_NORMAL,                 // 7
3631   THREAD_PRIORITY_ABOVE_NORMAL,                 // 8
3632   THREAD_PRIORITY_HIGHEST,                      // 9  NearMaxPriority
3633   THREAD_PRIORITY_HIGHEST,                      // 10 MaxPriority
3634   THREAD_PRIORITY_HIGHEST                       // 11 CriticalPriority
3635 };
3636 
3637 int prio_policy1[CriticalPriority + 1] = {
3638   THREAD_PRIORITY_IDLE,                         // 0  Entry should never be used
3639   THREAD_PRIORITY_LOWEST,                       // 1  MinPriority
3640   THREAD_PRIORITY_LOWEST,                       // 2
3641   THREAD_PRIORITY_BELOW_NORMAL,                 // 3
3642   THREAD_PRIORITY_BELOW_NORMAL,                 // 4
3643   THREAD_PRIORITY_NORMAL,                       // 5  NormPriority
3644   THREAD_PRIORITY_ABOVE_NORMAL,                 // 6
3645   THREAD_PRIORITY_ABOVE_NORMAL,                 // 7
3646   THREAD_PRIORITY_HIGHEST,                      // 8
3647   THREAD_PRIORITY_HIGHEST,                      // 9  NearMaxPriority
3648   THREAD_PRIORITY_TIME_CRITICAL,                // 10 MaxPriority
3649   THREAD_PRIORITY_TIME_CRITICAL                 // 11 CriticalPriority
3650 };
3651 
3652 static int prio_init() {
3653   // If ThreadPriorityPolicy is 1, switch tables
3654   if (ThreadPriorityPolicy == 1) {
3655     int i;
3656     for (i = 0; i &lt; CriticalPriority + 1; i++) {
3657       os::java_to_os_priority[i] = prio_policy1[i];
3658     }
3659   }
3660   if (UseCriticalJavaThreadPriority) {
3661     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];
3662   }
3663   return 0;
3664 }
3665 
3666 OSReturn os::set_native_priority(Thread* thread, int priority) {
3667   if (!UseThreadPriorities) return OS_OK;
3668   bool ret = SetThreadPriority(thread-&gt;osthread()-&gt;thread_handle(), priority) != 0;
3669   return ret ? OS_OK : OS_ERR;
3670 }
3671 
3672 OSReturn os::get_native_priority(const Thread* const thread,
3673                                  int* priority_ptr) {
3674   if (!UseThreadPriorities) {
3675     *priority_ptr = java_to_os_priority[NormPriority];
3676     return OS_OK;
3677   }
3678   int os_prio = GetThreadPriority(thread-&gt;osthread()-&gt;thread_handle());
3679   if (os_prio == THREAD_PRIORITY_ERROR_RETURN) {
3680     assert(false, "GetThreadPriority failed");
3681     return OS_ERR;
3682   }
3683   *priority_ptr = os_prio;
3684   return OS_OK;
3685 }
3686 
3687 
3688 // Hint to the underlying OS that a task switch would not be good.
3689 // Void return because it's a hint and can fail.
3690 void os::hint_no_preempt() {}
3691 
3692 void os::interrupt(Thread* thread) {
3693   assert(!thread-&gt;is_Java_thread() || Thread::current() == thread ||
3694          Threads_lock-&gt;owned_by_self(),
3695          "possibility of dangling Thread pointer");
3696 
3697   OSThread* osthread = thread-&gt;osthread();
3698   osthread-&gt;set_interrupted(true);
3699   // More than one thread can get here with the same value of osthread,
3700   // resulting in multiple notifications.  We do, however, want the store
3701   // to interrupted() to be visible to other threads before we post
3702   // the interrupt event.
3703   OrderAccess::release();
3704   SetEvent(osthread-&gt;interrupt_event());
3705   // For JSR166:  unpark after setting status
3706   if (thread-&gt;is_Java_thread()) {
3707     ((JavaThread*)thread)-&gt;parker()-&gt;unpark();
3708   }
3709 
3710   ParkEvent * ev = thread-&gt;_ParkEvent;
3711   if (ev != NULL) ev-&gt;unpark();
3712 }
3713 
3714 
3715 bool os::is_interrupted(Thread* thread, bool clear_interrupted) {
3716   assert(!thread-&gt;is_Java_thread() || Thread::current() == thread || Threads_lock-&gt;owned_by_self(),
3717          "possibility of dangling Thread pointer");
3718 
3719   OSThread* osthread = thread-&gt;osthread();
3720   // There is no synchronization between the setting of the interrupt
3721   // and it being cleared here. It is critical - see 6535709 - that
3722   // we only clear the interrupt state, and reset the interrupt event,
3723   // if we are going to report that we were indeed interrupted - else
3724   // an interrupt can be "lost", leading to spurious wakeups or lost wakeups
3725   // depending on the timing. By checking thread interrupt event to see
3726   // if the thread gets real interrupt thus prevent spurious wakeup.
3727   bool interrupted = osthread-&gt;interrupted() &amp;&amp; (WaitForSingleObject(osthread-&gt;interrupt_event(), 0) == WAIT_OBJECT_0);
3728   if (interrupted &amp;&amp; clear_interrupted) {
3729     osthread-&gt;set_interrupted(false);
3730     ResetEvent(osthread-&gt;interrupt_event());
3731   } // Otherwise leave the interrupted state alone
3732 
3733   return interrupted;
3734 }
3735 
3736 // Get's a pc (hint) for a running thread. Currently used only for profiling.
3737 ExtendedPC os::get_thread_pc(Thread* thread) {
3738   CONTEXT context;
3739   context.ContextFlags = CONTEXT_CONTROL;
3740   HANDLE handle = thread-&gt;osthread()-&gt;thread_handle();
3741 #ifdef _M_IA64
3742   assert(0, "Fix get_thread_pc");
3743   return ExtendedPC(NULL);
3744 #else
3745   if (GetThreadContext(handle, &amp;context)) {
3746 #ifdef _M_AMD64
3747     return ExtendedPC((address) context.Rip);
3748 #else
3749     return ExtendedPC((address) context.Eip);
3750 #endif
3751   } else {
3752     return ExtendedPC(NULL);
3753   }
3754 #endif
3755 }
3756 
3757 // GetCurrentThreadId() returns DWORD
3758 intx os::current_thread_id()  { return GetCurrentThreadId(); }
3759 
3760 static int _initial_pid = 0;
3761 
3762 int os::current_process_id() {
3763   return (_initial_pid ? _initial_pid : _getpid());
3764 }
3765 
3766 int    os::win32::_vm_page_size              = 0;
3767 int    os::win32::_vm_allocation_granularity = 0;
3768 int    os::win32::_processor_type            = 0;
3769 // Processor level is not available on non-NT systems, use vm_version instead
3770 int    os::win32::_processor_level           = 0;
3771 julong os::win32::_physical_memory           = 0;
3772 size_t os::win32::_default_stack_size        = 0;
3773 
3774 intx          os::win32::_os_thread_limit    = 0;
3775 volatile intx os::win32::_os_thread_count    = 0;
3776 
3777 bool   os::win32::_is_windows_server         = false;
3778 
3779 // 6573254
3780 // Currently, the bug is observed across all the supported Windows releases,
3781 // including the latest one (as of this writing - Windows Server 2012 R2)
3782 bool   os::win32::_has_exit_bug              = true;
3783 
3784 void os::win32::initialize_system_info() {
3785   SYSTEM_INFO si;
3786   GetSystemInfo(&amp;si);
3787   _vm_page_size    = si.dwPageSize;
3788   _vm_allocation_granularity = si.dwAllocationGranularity;
3789   _processor_type  = si.dwProcessorType;
3790   _processor_level = si.wProcessorLevel;
3791   set_processor_count(si.dwNumberOfProcessors);
3792 
3793   MEMORYSTATUSEX ms;
3794   ms.dwLength = sizeof(ms);
3795 
3796   // also returns dwAvailPhys (free physical memory bytes), dwTotalVirtual, dwAvailVirtual,
3797   // dwMemoryLoad (% of memory in use)
3798   GlobalMemoryStatusEx(&amp;ms);
3799   _physical_memory = ms.ullTotalPhys;
3800 
3801   if (FLAG_IS_DEFAULT(MaxRAM)) {
3802     // Adjust MaxRAM according to the maximum virtual address space available.
3803     FLAG_SET_DEFAULT(MaxRAM, MIN2(MaxRAM, (uint64_t) ms.ullTotalVirtual));
3804   }
3805 
3806   OSVERSIONINFOEX oi;
3807   oi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
3808   GetVersionEx((OSVERSIONINFO*)&amp;oi);
3809   switch (oi.dwPlatformId) {
3810   case VER_PLATFORM_WIN32_NT:
3811     {
3812       int os_vers = oi.dwMajorVersion * 1000 + oi.dwMinorVersion;
3813       if (oi.wProductType == VER_NT_DOMAIN_CONTROLLER ||
3814           oi.wProductType == VER_NT_SERVER) {
3815         _is_windows_server = true;
3816       }
3817     }
3818     break;
3819   default: fatal("Unknown platform");
3820   }
3821 
3822   _default_stack_size = os::current_stack_size();
3823   assert(_default_stack_size &gt; (size_t) _vm_page_size, "invalid stack size");
3824   assert((_default_stack_size &amp; (_vm_page_size - 1)) == 0,
3825          "stack size not a multiple of page size");
3826 
3827   initialize_performance_counter();
3828 }
3829 
3830 
3831 HINSTANCE os::win32::load_Windows_dll(const char* name, char *ebuf,
3832                                       int ebuflen) {
3833   char path[MAX_PATH];
3834   DWORD size;
3835   DWORD pathLen = (DWORD)sizeof(path);
3836   HINSTANCE result = NULL;
3837 
3838   // only allow library name without path component
3839   assert(strchr(name, '\\') == NULL, "path not allowed");
3840   assert(strchr(name, ':') == NULL, "path not allowed");
3841   if (strchr(name, '\\') != NULL || strchr(name, ':') != NULL) {
3842     jio_snprintf(ebuf, ebuflen,
3843                  "Invalid parameter while calling os::win32::load_windows_dll(): cannot take path: %s", name);
3844     return NULL;
3845   }
3846 
3847   // search system directory
3848   if ((size = GetSystemDirectory(path, pathLen)) &gt; 0) {
3849     if (size &gt;= pathLen) {
3850       return NULL; // truncated
3851     }
3852     if (jio_snprintf(path + size, pathLen - size, "\\%s", name) == -1) {
3853       return NULL; // truncated
3854     }
3855     if ((result = (HINSTANCE)os::dll_load(path, ebuf, ebuflen)) != NULL) {
3856       return result;
3857     }
3858   }
3859 
3860   // try Windows directory
3861   if ((size = GetWindowsDirectory(path, pathLen)) &gt; 0) {
3862     if (size &gt;= pathLen) {
3863       return NULL; // truncated
3864     }
3865     if (jio_snprintf(path + size, pathLen - size, "\\%s", name) == -1) {
3866       return NULL; // truncated
3867     }
3868     if ((result = (HINSTANCE)os::dll_load(path, ebuf, ebuflen)) != NULL) {
3869       return result;
3870     }
3871   }
3872 
3873   jio_snprintf(ebuf, ebuflen,
3874                "os::win32::load_windows_dll() cannot load %s from system directories.", name);
3875   return NULL;
3876 }
3877 
3878 #define MAXIMUM_THREADS_TO_KEEP (16 * MAXIMUM_WAIT_OBJECTS)
3879 #define EXIT_TIMEOUT 300000 /* 5 minutes */
3880 
3881 static BOOL CALLBACK init_crit_sect_call(PINIT_ONCE, PVOID pcrit_sect, PVOID*) {
3882   InitializeCriticalSection((CRITICAL_SECTION*)pcrit_sect);
3883   return TRUE;
3884 }
3885 
3886 int os::win32::exit_process_or_thread(Ept what, int exit_code) {
3887   // Basic approach:
3888   //  - Each exiting thread registers its intent to exit and then does so.
3889   //  - A thread trying to terminate the process must wait for all
3890   //    threads currently exiting to complete their exit.
3891 
3892   if (os::win32::has_exit_bug()) {
3893     // The array holds handles of the threads that have started exiting by calling
3894     // _endthreadex().
3895     // Should be large enough to avoid blocking the exiting thread due to lack of
3896     // a free slot.
3897     static HANDLE handles[MAXIMUM_THREADS_TO_KEEP];
3898     static int handle_count = 0;
3899 
3900     static INIT_ONCE init_once_crit_sect = INIT_ONCE_STATIC_INIT;
3901     static CRITICAL_SECTION crit_sect;
3902     static volatile jint process_exiting = 0;
3903     int i, j;
3904     DWORD res;
3905     HANDLE hproc, hthr;
3906 
3907     // We only attempt to register threads until a process exiting
3908     // thread manages to set the process_exiting flag. Any threads
3909     // that come through here after the process_exiting flag is set
3910     // are unregistered and will be caught in the SuspendThread()
3911     // infinite loop below.
3912     bool registered = false;
3913 
3914     // The first thread that reached this point, initializes the critical section.
3915     if (!InitOnceExecuteOnce(&amp;init_once_crit_sect, init_crit_sect_call, &amp;crit_sect, NULL)) {
3916       warning("crit_sect initialization failed in %s: %d\n", __FILE__, __LINE__);
3917     } else if (OrderAccess::load_acquire(&amp;process_exiting) == 0) {
3918       if (what != EPT_THREAD) {
3919         // Atomically set process_exiting before the critical section
3920         // to increase the visibility between racing threads.
3921         Atomic::cmpxchg((jint)GetCurrentThreadId(), &amp;process_exiting, 0);
3922       }
3923       EnterCriticalSection(&amp;crit_sect);
3924 
3925       if (what == EPT_THREAD &amp;&amp; OrderAccess::load_acquire(&amp;process_exiting) == 0) {
3926         // Remove from the array those handles of the threads that have completed exiting.
3927         for (i = 0, j = 0; i &lt; handle_count; ++i) {
3928           res = WaitForSingleObject(handles[i], 0 /* don't wait */);
3929           if (res == WAIT_TIMEOUT) {
3930             handles[j++] = handles[i];
3931           } else {
3932             if (res == WAIT_FAILED) {
3933               warning("WaitForSingleObject failed (%u) in %s: %d\n",
3934                       GetLastError(), __FILE__, __LINE__);
3935             }
3936             // Don't keep the handle, if we failed waiting for it.
3937             CloseHandle(handles[i]);
3938           }
3939         }
3940 
3941         // If there's no free slot in the array of the kept handles, we'll have to
3942         // wait until at least one thread completes exiting.
3943         if ((handle_count = j) == MAXIMUM_THREADS_TO_KEEP) {
3944           // Raise the priority of the oldest exiting thread to increase its chances
3945           // to complete sooner.
3946           SetThreadPriority(handles[0], THREAD_PRIORITY_ABOVE_NORMAL);
3947           res = WaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, handles, FALSE, EXIT_TIMEOUT);
3948           if (res &gt;= WAIT_OBJECT_0 &amp;&amp; res &lt; (WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS)) {
3949             i = (res - WAIT_OBJECT_0);
3950             handle_count = MAXIMUM_THREADS_TO_KEEP - 1;
3951             for (; i &lt; handle_count; ++i) {
3952               handles[i] = handles[i + 1];
3953             }
3954           } else {
3955             warning("WaitForMultipleObjects %s (%u) in %s: %d\n",
3956                     (res == WAIT_FAILED ? "failed" : "timed out"),
3957                     GetLastError(), __FILE__, __LINE__);
3958             // Don't keep handles, if we failed waiting for them.
3959             for (i = 0; i &lt; MAXIMUM_THREADS_TO_KEEP; ++i) {
3960               CloseHandle(handles[i]);
3961             }
3962             handle_count = 0;
3963           }
3964         }
3965 
3966         // Store a duplicate of the current thread handle in the array of handles.
3967         hproc = GetCurrentProcess();
3968         hthr = GetCurrentThread();
3969         if (!DuplicateHandle(hproc, hthr, hproc, &amp;handles[handle_count],
3970                              0, FALSE, DUPLICATE_SAME_ACCESS)) {
3971           warning("DuplicateHandle failed (%u) in %s: %d\n",
3972                   GetLastError(), __FILE__, __LINE__);
3973 
3974           // We can't register this thread (no more handles) so this thread
3975           // may be racing with a thread that is calling exit(). If the thread
3976           // that is calling exit() has managed to set the process_exiting
3977           // flag, then this thread will be caught in the SuspendThread()
3978           // infinite loop below which closes that race. A small timing
3979           // window remains before the process_exiting flag is set, but it
3980           // is only exposed when we are out of handles.
3981         } else {
3982           ++handle_count;
3983           registered = true;
3984 
3985           // The current exiting thread has stored its handle in the array, and now
3986           // should leave the critical section before calling _endthreadex().
3987         }
3988 
3989       } else if (what != EPT_THREAD &amp;&amp; handle_count &gt; 0) {
3990         jlong start_time, finish_time, timeout_left;
3991         // Before ending the process, make sure all the threads that had called
3992         // _endthreadex() completed.
3993 
3994         // Set the priority level of the current thread to the same value as
3995         // the priority level of exiting threads.
3996         // This is to ensure it will be given a fair chance to execute if
3997         // the timeout expires.
3998         hthr = GetCurrentThread();
3999         SetThreadPriority(hthr, THREAD_PRIORITY_ABOVE_NORMAL);
4000         start_time = os::javaTimeNanos();
4001         finish_time = start_time + ((jlong)EXIT_TIMEOUT * 1000000L);
4002         for (i = 0; ; ) {
4003           int portion_count = handle_count - i;
4004           if (portion_count &gt; MAXIMUM_WAIT_OBJECTS) {
4005             portion_count = MAXIMUM_WAIT_OBJECTS;
4006           }
4007           for (j = 0; j &lt; portion_count; ++j) {
4008             SetThreadPriority(handles[i + j], THREAD_PRIORITY_ABOVE_NORMAL);
4009           }
4010           timeout_left = (finish_time - start_time) / 1000000L;
4011           if (timeout_left &lt; 0) {
4012             timeout_left = 0;
4013           }
4014           res = WaitForMultipleObjects(portion_count, handles + i, TRUE, timeout_left);
4015           if (res == WAIT_FAILED || res == WAIT_TIMEOUT) {
4016             warning("WaitForMultipleObjects %s (%u) in %s: %d\n",
4017                     (res == WAIT_FAILED ? "failed" : "timed out"),
4018                     GetLastError(), __FILE__, __LINE__);
4019             // Reset portion_count so we close the remaining
4020             // handles due to this error.
4021             portion_count = handle_count - i;
4022           }
4023           for (j = 0; j &lt; portion_count; ++j) {
4024             CloseHandle(handles[i + j]);
4025           }
4026           if ((i += portion_count) &gt;= handle_count) {
4027             break;
4028           }
4029           start_time = os::javaTimeNanos();
4030         }
4031         handle_count = 0;
4032       }
4033 
4034       LeaveCriticalSection(&amp;crit_sect);
4035     }
4036 
4037     if (!registered &amp;&amp;
4038         OrderAccess::load_acquire(&amp;process_exiting) != 0 &amp;&amp;
4039         process_exiting != (jint)GetCurrentThreadId()) {
4040       // Some other thread is about to call exit(), so we don't let
4041       // the current unregistered thread proceed to exit() or _endthreadex()
4042       while (true) {
4043         SuspendThread(GetCurrentThread());
4044         // Avoid busy-wait loop, if SuspendThread() failed.
4045         Sleep(EXIT_TIMEOUT);
4046       }
4047     }
4048   }
4049 
4050   // We are here if either
4051   // - there's no 'race at exit' bug on this OS release;
4052   // - initialization of the critical section failed (unlikely);
4053   // - the current thread has registered itself and left the critical section;
4054   // - the process-exiting thread has raised the flag and left the critical section.
4055   if (what == EPT_THREAD) {
4056     _endthreadex((unsigned)exit_code);
4057   } else if (what == EPT_PROCESS) {
4058     ::exit(exit_code);
4059   } else {
4060     _exit(exit_code);
4061   }
4062 
4063   // Should not reach here
4064   return exit_code;
4065 }
4066 
4067 #undef EXIT_TIMEOUT
4068 
4069 void os::win32::setmode_streams() {
4070   _setmode(_fileno(stdin), _O_BINARY);
4071   _setmode(_fileno(stdout), _O_BINARY);
4072   _setmode(_fileno(stderr), _O_BINARY);
4073 }
4074 
4075 
4076 bool os::is_debugger_attached() {
4077   return IsDebuggerPresent() ? true : false;
4078 }
4079 
4080 
4081 void os::wait_for_keypress_at_exit(void) {
4082   if (PauseAtExit) {
4083     fprintf(stderr, "Press any key to continue...\n");
4084     fgetc(stdin);
4085   }
4086 }
4087 
4088 
4089 bool os::message_box(const char* title, const char* message) {
4090   int result = MessageBox(NULL, message, title,
4091                           MB_YESNO | MB_ICONERROR | MB_SYSTEMMODAL | MB_DEFAULT_DESKTOP_ONLY);
4092   return result == IDYES;
4093 }
4094 
4095 #ifndef PRODUCT
4096 #ifndef _WIN64
4097 // Helpers to check whether NX protection is enabled
4098 int nx_exception_filter(_EXCEPTION_POINTERS *pex) {
4099   if (pex-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION &amp;&amp;
4100       pex-&gt;ExceptionRecord-&gt;NumberParameters &gt; 0 &amp;&amp;
4101       pex-&gt;ExceptionRecord-&gt;ExceptionInformation[0] ==
4102       EXCEPTION_INFO_EXEC_VIOLATION) {
4103     return EXCEPTION_EXECUTE_HANDLER;
4104   }
4105   return EXCEPTION_CONTINUE_SEARCH;
4106 }
4107 
4108 void nx_check_protection() {
4109   // If NX is enabled we'll get an exception calling into code on the stack
4110   char code[] = { (char)0xC3 }; // ret
4111   void *code_ptr = (void *)code;
4112   __try {
4113     __asm call code_ptr
4114   } __except(nx_exception_filter((_EXCEPTION_POINTERS*)_exception_info())) {
4115     tty-&gt;print_raw_cr("NX protection detected.");
4116   }
4117 }
4118 #endif // _WIN64
4119 #endif // PRODUCT
4120 
4121 // This is called _before_ the global arguments have been parsed
4122 void os::init(void) {
4123   _initial_pid = _getpid();
4124 
4125   init_random(1234567);
4126 
4127   win32::initialize_system_info();
4128   win32::setmode_streams();
4129   init_page_sizes((size_t) win32::vm_page_size());
4130 
4131   // This may be overridden later when argument processing is done.
4132   FLAG_SET_ERGO(bool, UseLargePagesIndividualAllocation, false);
4133 
4134   // Initialize main_process and main_thread
4135   main_process = GetCurrentProcess();  // Remember main_process is a pseudo handle
4136   if (!DuplicateHandle(main_process, GetCurrentThread(), main_process,
4137                        &amp;main_thread, THREAD_ALL_ACCESS, false, 0)) {
4138     fatal("DuplicateHandle failed\n");
4139   }
4140   main_thread_id = (int) GetCurrentThreadId();
4141 
4142   // initialize fast thread access - only used for 32-bit
4143   win32::initialize_thread_ptr_offset();
4144 }
4145 
4146 // To install functions for atexit processing
4147 extern "C" {
4148   static void perfMemory_exit_helper() {
4149     perfMemory_exit();
4150   }
4151 }
4152 
4153 static jint initSock();
4154 
4155 // this is called _after_ the global arguments have been parsed
4156 jint os::init_2(void) {
4157   // Allocate a single page and mark it as readable for safepoint polling
4158   address polling_page = (address)VirtualAlloc(NULL, os::vm_page_size(), MEM_RESERVE, PAGE_READONLY);
4159   guarantee(polling_page != NULL, "Reserve Failed for polling page");
4160 
4161   address return_page  = (address)VirtualAlloc(polling_page, os::vm_page_size(), MEM_COMMIT, PAGE_READONLY);
4162   guarantee(return_page != NULL, "Commit Failed for polling page");
4163 
4164   os::set_polling_page(polling_page);
4165   log_info(os)("SafePoint Polling address: " INTPTR_FORMAT, p2i(polling_page));
4166 
4167   if (!UseMembar) {
4168     address mem_serialize_page = (address)VirtualAlloc(NULL, os::vm_page_size(), MEM_RESERVE, PAGE_READWRITE);
4169     guarantee(mem_serialize_page != NULL, "Reserve Failed for memory serialize page");
4170 
4171     return_page  = (address)VirtualAlloc(mem_serialize_page, os::vm_page_size(), MEM_COMMIT, PAGE_READWRITE);
4172     guarantee(return_page != NULL, "Commit Failed for memory serialize page");
4173 
4174     os::set_memory_serialize_page(mem_serialize_page);
4175     log_info(os)("Memory Serialize Page address: " INTPTR_FORMAT, p2i(mem_serialize_page));
4176   }
4177 
4178   // Setup Windows Exceptions
4179 
4180   // for debugging float code generation bugs
4181   if (ForceFloatExceptions) {
4182 #ifndef  _WIN64
4183     static long fp_control_word = 0;
4184     __asm { fstcw fp_control_word }
4185     // see Intel PPro Manual, Vol. 2, p 7-16
4186     const long precision = 0x20;
4187     const long underflow = 0x10;
4188     const long overflow  = 0x08;
4189     const long zero_div  = 0x04;
4190     const long denorm    = 0x02;
4191     const long invalid   = 0x01;
4192     fp_control_word |= invalid;
4193     __asm { fldcw fp_control_word }
4194 #endif
4195   }
4196 
4197   // If stack_commit_size is 0, windows will reserve the default size,
4198   // but only commit a small portion of it.
4199   size_t stack_commit_size = round_to(ThreadStackSize*K, os::vm_page_size());
4200   size_t default_reserve_size = os::win32::default_stack_size();
4201   size_t actual_reserve_size = stack_commit_size;
4202   if (stack_commit_size &lt; default_reserve_size) {
4203     // If stack_commit_size == 0, we want this too
4204     actual_reserve_size = default_reserve_size;
4205   }
4206 
4207   // Check minimum allowable stack size for thread creation and to initialize
4208   // the java system classes, including StackOverflowError - depends on page
4209   // size.  Add two 4K pages for compiler2 recursion in main thread.
4210   // Add in 4*BytesPerWord 4K pages to account for VM stack during
4211   // class initialization depending on 32 or 64 bit VM.
4212   size_t min_stack_allowed =
4213             (size_t)(JavaThread::stack_guard_zone_size() +
4214                      JavaThread::stack_shadow_zone_size() +
4215                      (4*BytesPerWord COMPILER2_PRESENT(+2)) * 4 * K);
4216 
4217   min_stack_allowed = align_size_up(min_stack_allowed, os::vm_page_size());
4218 
4219   if (actual_reserve_size &lt; min_stack_allowed) {
4220     tty-&gt;print_cr("\nThe Java thread stack size specified is too small. "
4221                   "Specify at least %dk",
4222                   min_stack_allowed / K);
4223     return JNI_ERR;
4224   }
4225 
4226   JavaThread::set_stack_size_at_create(stack_commit_size);
4227 
4228   // Calculate theoretical max. size of Threads to guard gainst artifical
4229   // out-of-memory situations, where all available address-space has been
4230   // reserved by thread stacks.
4231   assert(actual_reserve_size != 0, "Must have a stack");
4232 
4233   // Calculate the thread limit when we should start doing Virtual Memory
4234   // banging. Currently when the threads will have used all but 200Mb of space.
4235   //
4236   // TODO: consider performing a similar calculation for commit size instead
4237   // as reserve size, since on a 64-bit platform we'll run into that more
4238   // often than running out of virtual memory space.  We can use the
4239   // lower value of the two calculations as the os_thread_limit.
4240   size_t max_address_space = ((size_t)1 &lt;&lt; (BitsPerWord - 1)) - (200 * K * K);
4241   win32::_os_thread_limit = (intx)(max_address_space / actual_reserve_size);
4242 
4243   // at exit methods are called in the reverse order of their registration.
4244   // there is no limit to the number of functions registered. atexit does
4245   // not set errno.
4246 
4247   if (PerfAllowAtExitRegistration) {
4248     // only register atexit functions if PerfAllowAtExitRegistration is set.
4249     // atexit functions can be delayed until process exit time, which
4250     // can be problematic for embedded VM situations. Embedded VMs should
4251     // call DestroyJavaVM() to assure that VM resources are released.
4252 
4253     // note: perfMemory_exit_helper atexit function may be removed in
4254     // the future if the appropriate cleanup code can be added to the
4255     // VM_Exit VMOperation's doit method.
4256     if (atexit(perfMemory_exit_helper) != 0) {
4257       warning("os::init_2 atexit(perfMemory_exit_helper) failed");
4258     }
4259   }
4260 
4261 #ifndef _WIN64
4262   // Print something if NX is enabled (win32 on AMD64)
4263   NOT_PRODUCT(if (PrintMiscellaneous &amp;&amp; Verbose) nx_check_protection());
4264 #endif
4265 
4266   // initialize thread priority policy
4267   prio_init();
4268 
4269   if (UseNUMA &amp;&amp; !ForceNUMA) {
4270     UseNUMA = false; // We don't fully support this yet
4271   }
4272 
4273   if (UseNUMAInterleaving) {
4274     // first check whether this Windows OS supports VirtualAllocExNuma, if not ignore this flag
4275     bool success = numa_interleaving_init();
4276     if (!success) UseNUMAInterleaving = false;
4277   }
4278 
4279   if (initSock() != JNI_OK) {
4280     return JNI_ERR;
4281   }
4282 
4283   return JNI_OK;
4284 }
4285 
4286 // Mark the polling page as unreadable
4287 void os::make_polling_page_unreadable(void) {
4288   DWORD old_status;
4289   if (!VirtualProtect((char *)_polling_page, os::vm_page_size(),
4290                       PAGE_NOACCESS, &amp;old_status)) {
4291     fatal("Could not disable polling page");
4292   }
4293 }
4294 
4295 // Mark the polling page as readable
4296 void os::make_polling_page_readable(void) {
4297   DWORD old_status;
4298   if (!VirtualProtect((char *)_polling_page, os::vm_page_size(),
4299                       PAGE_READONLY, &amp;old_status)) {
4300     fatal("Could not enable polling page");
4301   }
4302 }
4303 
4304 
4305 int os::stat(const char *path, struct stat *sbuf) {
4306   char pathbuf[MAX_PATH];
4307   if (strlen(path) &gt; MAX_PATH - 1) {
4308     errno = ENAMETOOLONG;
4309     return -1;
4310   }
4311   os::native_path(strcpy(pathbuf, path));
4312   int ret = ::stat(pathbuf, sbuf);
4313   if (sbuf != NULL &amp;&amp; UseUTCFileTimestamp) {
4314     // Fix for 6539723.  st_mtime returned from stat() is dependent on
4315     // the system timezone and so can return different values for the
4316     // same file if/when daylight savings time changes.  This adjustment
4317     // makes sure the same timestamp is returned regardless of the TZ.
4318     //
4319     // See:
4320     // http://msdn.microsoft.com/library/
4321     //   default.asp?url=/library/en-us/sysinfo/base/
4322     //   time_zone_information_str.asp
4323     // and
4324     // http://msdn.microsoft.com/library/default.asp?url=
4325     //   /library/en-us/sysinfo/base/settimezoneinformation.asp
4326     //
4327     // NOTE: there is a insidious bug here:  If the timezone is changed
4328     // after the call to stat() but before 'GetTimeZoneInformation()', then
4329     // the adjustment we do here will be wrong and we'll return the wrong
4330     // value (which will likely end up creating an invalid class data
4331     // archive).  Absent a better API for this, or some time zone locking
4332     // mechanism, we'll have to live with this risk.
4333     TIME_ZONE_INFORMATION tz;
4334     DWORD tzid = GetTimeZoneInformation(&amp;tz);
4335     int daylightBias =
4336       (tzid == TIME_ZONE_ID_DAYLIGHT) ?  tz.DaylightBias : tz.StandardBias;
4337     sbuf-&gt;st_mtime += (tz.Bias + daylightBias) * 60;
4338   }
4339   return ret;
4340 }
4341 
4342 
4343 #define FT2INT64(ft) \
4344   ((jlong)((jlong)(ft).dwHighDateTime &lt;&lt; 32 | (julong)(ft).dwLowDateTime))
4345 
4346 
4347 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
4348 // are used by JVM M&amp;M and JVMTI to get user+sys or user CPU time
4349 // of a thread.
4350 //
4351 // current_thread_cpu_time() and thread_cpu_time(Thread*) returns
4352 // the fast estimate available on the platform.
4353 
4354 // current_thread_cpu_time() is not optimized for Windows yet
4355 jlong os::current_thread_cpu_time() {
4356   // return user + sys since the cost is the same
4357   return os::thread_cpu_time(Thread::current(), true /* user+sys */);
4358 }
4359 
4360 jlong os::thread_cpu_time(Thread* thread) {
4361   // consistent with what current_thread_cpu_time() returns.
4362   return os::thread_cpu_time(thread, true /* user+sys */);
4363 }
4364 
4365 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
4366   return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
4367 }
4368 
4369 jlong os::thread_cpu_time(Thread* thread, bool user_sys_cpu_time) {
4370   // This code is copy from clasic VM -&gt; hpi::sysThreadCPUTime
4371   // If this function changes, os::is_thread_cpu_time_supported() should too
4372   FILETIME CreationTime;
4373   FILETIME ExitTime;
4374   FILETIME KernelTime;
4375   FILETIME UserTime;
4376 
4377   if (GetThreadTimes(thread-&gt;osthread()-&gt;thread_handle(), &amp;CreationTime,
4378                       &amp;ExitTime, &amp;KernelTime, &amp;UserTime) == 0) {
4379     return -1;
4380   } else if (user_sys_cpu_time) {
4381     return (FT2INT64(UserTime) + FT2INT64(KernelTime)) * 100;
4382   } else {
4383     return FT2INT64(UserTime) * 100;
4384   }
4385 }
4386 
4387 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
4388   info_ptr-&gt;max_value = ALL_64_BITS;        // the max value -- all 64 bits
4389   info_ptr-&gt;may_skip_backward = false;      // GetThreadTimes returns absolute time
4390   info_ptr-&gt;may_skip_forward = false;       // GetThreadTimes returns absolute time
4391   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;   // user+system time is returned
4392 }
4393 
4394 void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
4395   info_ptr-&gt;max_value = ALL_64_BITS;        // the max value -- all 64 bits
4396   info_ptr-&gt;may_skip_backward = false;      // GetThreadTimes returns absolute time
4397   info_ptr-&gt;may_skip_forward = false;       // GetThreadTimes returns absolute time
4398   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;   // user+system time is returned
4399 }
4400 
4401 bool os::is_thread_cpu_time_supported() {
4402   // see os::thread_cpu_time
4403   FILETIME CreationTime;
4404   FILETIME ExitTime;
4405   FILETIME KernelTime;
4406   FILETIME UserTime;
4407 
4408   if (GetThreadTimes(GetCurrentThread(), &amp;CreationTime, &amp;ExitTime,
4409                       &amp;KernelTime, &amp;UserTime) == 0) {
4410     return false;
4411   } else {
4412     return true;
4413   }
4414 }
4415 
4416 // Windows does't provide a loadavg primitive so this is stubbed out for now.
4417 // It does have primitives (PDH API) to get CPU usage and run queue length.
4418 // "\\Processor(_Total)\\% Processor Time", "\\System\\Processor Queue Length"
4419 // If we wanted to implement loadavg on Windows, we have a few options:
4420 //
4421 // a) Query CPU usage and run queue length and "fake" an answer by
4422 //    returning the CPU usage if it's under 100%, and the run queue
4423 //    length otherwise.  It turns out that querying is pretty slow
4424 //    on Windows, on the order of 200 microseconds on a fast machine.
4425 //    Note that on the Windows the CPU usage value is the % usage
4426 //    since the last time the API was called (and the first call
4427 //    returns 100%), so we'd have to deal with that as well.
4428 //
4429 // b) Sample the "fake" answer using a sampling thread and store
4430 //    the answer in a global variable.  The call to loadavg would
4431 //    just return the value of the global, avoiding the slow query.
4432 //
4433 // c) Sample a better answer using exponential decay to smooth the
4434 //    value.  This is basically the algorithm used by UNIX kernels.
4435 //
4436 // Note that sampling thread starvation could affect both (b) and (c).
4437 int os::loadavg(double loadavg[], int nelem) {
4438   return -1;
4439 }
4440 
4441 
4442 // DontYieldALot=false by default: dutifully perform all yields as requested by JVM_Yield()
4443 bool os::dont_yield() {
4444   return DontYieldALot;
4445 }
4446 
4447 // This method is a slightly reworked copy of JDK's sysOpen
4448 // from src/windows/hpi/src/sys_api_md.c
4449 
4450 int os::open(const char *path, int oflag, int mode) {
4451   char pathbuf[MAX_PATH];
4452 
4453   if (strlen(path) &gt; MAX_PATH - 1) {
4454     errno = ENAMETOOLONG;
4455     return -1;
4456   }
4457   os::native_path(strcpy(pathbuf, path));
4458   return ::open(pathbuf, oflag | O_BINARY | O_NOINHERIT, mode);
4459 }
4460 
4461 FILE* os::open(int fd, const char* mode) {
4462   return ::_fdopen(fd, mode);
4463 }
4464 
4465 // Is a (classpath) directory empty?
4466 bool os::dir_is_empty(const char* path) {
4467   WIN32_FIND_DATA fd;
4468   HANDLE f = FindFirstFile(path, &amp;fd);
4469   if (f == INVALID_HANDLE_VALUE) {
4470     return true;
4471   }
4472   FindClose(f);
4473   return false;
4474 }
4475 
4476 // create binary file, rewriting existing file if required
4477 int os::create_binary_file(const char* path, bool rewrite_existing) {
4478   int oflags = _O_CREAT | _O_WRONLY | _O_BINARY;
4479   if (!rewrite_existing) {
4480     oflags |= _O_EXCL;
4481   }
4482   return ::open(path, oflags, _S_IREAD | _S_IWRITE);
4483 }
4484 
4485 // return current position of file pointer
4486 jlong os::current_file_offset(int fd) {
4487   return (jlong)::_lseeki64(fd, (__int64)0L, SEEK_CUR);
4488 }
4489 
4490 // move file pointer to the specified offset
4491 jlong os::seek_to_file_offset(int fd, jlong offset) {
4492   return (jlong)::_lseeki64(fd, (__int64)offset, SEEK_SET);
4493 }
4494 
4495 
4496 jlong os::lseek(int fd, jlong offset, int whence) {
4497   return (jlong) ::_lseeki64(fd, offset, whence);
4498 }
4499 
4500 size_t os::read_at(int fd, void *buf, unsigned int nBytes, jlong offset) {
4501   OVERLAPPED ov;
4502   DWORD nread;
4503   BOOL result;
4504 
4505   ZeroMemory(&amp;ov, sizeof(ov));
4506   ov.Offset = (DWORD)offset;
4507   ov.OffsetHigh = (DWORD)(offset &gt;&gt; 32);
4508 
4509   HANDLE h = (HANDLE)::_get_osfhandle(fd);
4510 
4511   result = ReadFile(h, (LPVOID)buf, nBytes, &amp;nread, &amp;ov);
4512 
4513   return result ? nread : 0;
4514 }
4515 
4516 
4517 // This method is a slightly reworked copy of JDK's sysNativePath
4518 // from src/windows/hpi/src/path_md.c
4519 
4520 // Convert a pathname to native format.  On win32, this involves forcing all
4521 // separators to be '\\' rather than '/' (both are legal inputs, but Win95
4522 // sometimes rejects '/') and removing redundant separators.  The input path is
4523 // assumed to have been converted into the character encoding used by the local
4524 // system.  Because this might be a double-byte encoding, care is taken to
4525 // treat double-byte lead characters correctly.
4526 //
4527 // This procedure modifies the given path in place, as the result is never
4528 // longer than the original.  There is no error return; this operation always
4529 // succeeds.
4530 char * os::native_path(char *path) {
4531   char *src = path, *dst = path, *end = path;
4532   char *colon = NULL;  // If a drive specifier is found, this will
4533                        // point to the colon following the drive letter
4534 
4535   // Assumption: '/', '\\', ':', and drive letters are never lead bytes
4536   assert(((!::IsDBCSLeadByte('/')) &amp;&amp; (!::IsDBCSLeadByte('\\'))
4537           &amp;&amp; (!::IsDBCSLeadByte(':'))), "Illegal lead byte");
4538 
4539   // Check for leading separators
4540 #define isfilesep(c) ((c) == '/' || (c) == '\\')
4541   while (isfilesep(*src)) {
4542     src++;
4543   }
4544 
4545   if (::isalpha(*src) &amp;&amp; !::IsDBCSLeadByte(*src) &amp;&amp; src[1] == ':') {
4546     // Remove leading separators if followed by drive specifier.  This
4547     // hack is necessary to support file URLs containing drive
4548     // specifiers (e.g., "file://c:/path").  As a side effect,
4549     // "/c:/path" can be used as an alternative to "c:/path".
4550     *dst++ = *src++;
4551     colon = dst;
4552     *dst++ = ':';
4553     src++;
4554   } else {
4555     src = path;
4556     if (isfilesep(src[0]) &amp;&amp; isfilesep(src[1])) {
4557       // UNC pathname: Retain first separator; leave src pointed at
4558       // second separator so that further separators will be collapsed
4559       // into the second separator.  The result will be a pathname
4560       // beginning with "\\\\" followed (most likely) by a host name.
4561       src = dst = path + 1;
4562       path[0] = '\\';     // Force first separator to '\\'
4563     }
4564   }
4565 
4566   end = dst;
4567 
4568   // Remove redundant separators from remainder of path, forcing all
4569   // separators to be '\\' rather than '/'. Also, single byte space
4570   // characters are removed from the end of the path because those
4571   // are not legal ending characters on this operating system.
4572   //
4573   while (*src != '\0') {
4574     if (isfilesep(*src)) {
4575       *dst++ = '\\'; src++;
4576       while (isfilesep(*src)) src++;
4577       if (*src == '\0') {
4578         // Check for trailing separator
4579         end = dst;
4580         if (colon == dst - 2) break;  // "z:\\"
4581         if (dst == path + 1) break;   // "\\"
4582         if (dst == path + 2 &amp;&amp; isfilesep(path[0])) {
4583           // "\\\\" is not collapsed to "\\" because "\\\\" marks the
4584           // beginning of a UNC pathname.  Even though it is not, by
4585           // itself, a valid UNC pathname, we leave it as is in order
4586           // to be consistent with the path canonicalizer as well
4587           // as the win32 APIs, which treat this case as an invalid
4588           // UNC pathname rather than as an alias for the root
4589           // directory of the current drive.
4590           break;
4591         }
4592         end = --dst;  // Path does not denote a root directory, so
4593                       // remove trailing separator
4594         break;
4595       }
4596       end = dst;
4597     } else {
4598       if (::IsDBCSLeadByte(*src)) {  // Copy a double-byte character
4599         *dst++ = *src++;
4600         if (*src) *dst++ = *src++;
4601         end = dst;
4602       } else {  // Copy a single-byte character
4603         char c = *src++;
4604         *dst++ = c;
4605         // Space is not a legal ending character
4606         if (c != ' ') end = dst;
4607       }
4608     }
4609   }
4610 
4611   *end = '\0';
4612 
4613   // For "z:", add "." to work around a bug in the C runtime library
4614   if (colon == dst - 1) {
4615     path[2] = '.';
4616     path[3] = '\0';
4617   }
4618 
4619   return path;
4620 }
4621 
4622 // This code is a copy of JDK's sysSetLength
4623 // from src/windows/hpi/src/sys_api_md.c
4624 
4625 int os::ftruncate(int fd, jlong length) {
4626   HANDLE h = (HANDLE)::_get_osfhandle(fd);
4627   long high = (long)(length &gt;&gt; 32);
4628   DWORD ret;
4629 
4630   if (h == (HANDLE)(-1)) {
4631     return -1;
4632   }
4633 
4634   ret = ::SetFilePointer(h, (long)(length), &amp;high, FILE_BEGIN);
4635   if ((ret == 0xFFFFFFFF) &amp;&amp; (::GetLastError() != NO_ERROR)) {
4636     return -1;
4637   }
4638 
4639   if (::SetEndOfFile(h) == FALSE) {
4640     return -1;
4641   }
4642 
4643   return 0;
4644 }
4645 
4646 int os::get_fileno(FILE* fp) {
4647   return _fileno(fp);
4648 }
4649 
4650 // This code is a copy of JDK's sysSync
4651 // from src/windows/hpi/src/sys_api_md.c
4652 // except for the legacy workaround for a bug in Win 98
4653 
4654 int os::fsync(int fd) {
4655   HANDLE handle = (HANDLE)::_get_osfhandle(fd);
4656 
4657   if ((!::FlushFileBuffers(handle)) &amp;&amp;
4658       (GetLastError() != ERROR_ACCESS_DENIED)) {
4659     // from winerror.h
4660     return -1;
4661   }
4662   return 0;
4663 }
4664 
4665 static int nonSeekAvailable(int, long *);
4666 static int stdinAvailable(int, long *);
4667 
4668 #define S_ISCHR(mode)   (((mode) &amp; _S_IFCHR) == _S_IFCHR)
4669 #define S_ISFIFO(mode)  (((mode) &amp; _S_IFIFO) == _S_IFIFO)
4670 
4671 // This code is a copy of JDK's sysAvailable
4672 // from src/windows/hpi/src/sys_api_md.c
4673 
4674 int os::available(int fd, jlong *bytes) {
4675   jlong cur, end;
4676   struct _stati64 stbuf64;
4677 
4678   if (::_fstati64(fd, &amp;stbuf64) &gt;= 0) {
4679     int mode = stbuf64.st_mode;
4680     if (S_ISCHR(mode) || S_ISFIFO(mode)) {
4681       int ret;
4682       long lpbytes;
4683       if (fd == 0) {
4684         ret = stdinAvailable(fd, &amp;lpbytes);
4685       } else {
4686         ret = nonSeekAvailable(fd, &amp;lpbytes);
4687       }
4688       (*bytes) = (jlong)(lpbytes);
4689       return ret;
4690     }
4691     if ((cur = ::_lseeki64(fd, 0L, SEEK_CUR)) == -1) {
4692       return FALSE;
4693     } else if ((end = ::_lseeki64(fd, 0L, SEEK_END)) == -1) {
4694       return FALSE;
4695     } else if (::_lseeki64(fd, cur, SEEK_SET) == -1) {
4696       return FALSE;
4697     }
4698     *bytes = end - cur;
4699     return TRUE;
4700   } else {
4701     return FALSE;
4702   }
4703 }
4704 
4705 void os::flockfile(FILE* fp) {
4706   _lock_file(fp);
4707 }
4708 
4709 void os::funlockfile(FILE* fp) {
4710   _unlock_file(fp);
4711 }
4712 
4713 // This code is a copy of JDK's nonSeekAvailable
4714 // from src/windows/hpi/src/sys_api_md.c
4715 
4716 static int nonSeekAvailable(int fd, long *pbytes) {
4717   // This is used for available on non-seekable devices
4718   // (like both named and anonymous pipes, such as pipes
4719   //  connected to an exec'd process).
4720   // Standard Input is a special case.
4721   HANDLE han;
4722 
4723   if ((han = (HANDLE) ::_get_osfhandle(fd)) == (HANDLE)(-1)) {
4724     return FALSE;
4725   }
4726 
4727   if (! ::PeekNamedPipe(han, NULL, 0, NULL, (LPDWORD)pbytes, NULL)) {
4728     // PeekNamedPipe fails when at EOF.  In that case we
4729     // simply make *pbytes = 0 which is consistent with the
4730     // behavior we get on Solaris when an fd is at EOF.
4731     // The only alternative is to raise an Exception,
4732     // which isn't really warranted.
4733     //
4734     if (::GetLastError() != ERROR_BROKEN_PIPE) {
4735       return FALSE;
4736     }
4737     *pbytes = 0;
4738   }
4739   return TRUE;
4740 }
4741 
4742 #define MAX_INPUT_EVENTS 2000
4743 
4744 // This code is a copy of JDK's stdinAvailable
4745 // from src/windows/hpi/src/sys_api_md.c
4746 
4747 static int stdinAvailable(int fd, long *pbytes) {
4748   HANDLE han;
4749   DWORD numEventsRead = 0;  // Number of events read from buffer
4750   DWORD numEvents = 0;      // Number of events in buffer
4751   DWORD i = 0;              // Loop index
4752   DWORD curLength = 0;      // Position marker
4753   DWORD actualLength = 0;   // Number of bytes readable
4754   BOOL error = FALSE;       // Error holder
4755   INPUT_RECORD *lpBuffer;   // Pointer to records of input events
4756 
4757   if ((han = ::GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE) {
4758     return FALSE;
4759   }
4760 
4761   // Construct an array of input records in the console buffer
4762   error = ::GetNumberOfConsoleInputEvents(han, &amp;numEvents);
4763   if (error == 0) {
4764     return nonSeekAvailable(fd, pbytes);
4765   }
4766 
4767   // lpBuffer must fit into 64K or else PeekConsoleInput fails
4768   if (numEvents &gt; MAX_INPUT_EVENTS) {
4769     numEvents = MAX_INPUT_EVENTS;
4770   }
4771 
4772   lpBuffer = (INPUT_RECORD *)os::malloc(numEvents * sizeof(INPUT_RECORD), mtInternal);
4773   if (lpBuffer == NULL) {
4774     return FALSE;
4775   }
4776 
4777   error = ::PeekConsoleInput(han, lpBuffer, numEvents, &amp;numEventsRead);
4778   if (error == 0) {
4779     os::free(lpBuffer);
4780     return FALSE;
4781   }
4782 
4783   // Examine input records for the number of bytes available
4784   for (i=0; i&lt;numEvents; i++) {
4785     if (lpBuffer[i].EventType == KEY_EVENT) {
4786 
4787       KEY_EVENT_RECORD *keyRecord = (KEY_EVENT_RECORD *)
4788                                       &amp;(lpBuffer[i].Event);
4789       if (keyRecord-&gt;bKeyDown == TRUE) {
4790         CHAR *keyPressed = (CHAR *) &amp;(keyRecord-&gt;uChar);
4791         curLength++;
4792         if (*keyPressed == '\r') {
4793           actualLength = curLength;
4794         }
4795       }
4796     }
4797   }
4798 
4799   if (lpBuffer != NULL) {
4800     os::free(lpBuffer);
4801   }
4802 
4803   *pbytes = (long) actualLength;
4804   return TRUE;
4805 }
4806 
4807 // Map a block of memory.
4808 char* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,
4809                         char *addr, size_t bytes, bool read_only,
4810                         bool allow_exec) {
4811   HANDLE hFile;
4812   char* base;
4813 
4814   hFile = CreateFile(file_name, GENERIC_READ, FILE_SHARE_READ, NULL,
4815                      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
4816   if (hFile == NULL) {
4817     log_info(os)("CreateFile() failed: GetLastError-&gt;%ld.", GetLastError());
4818     return NULL;
4819   }
4820 
4821   if (allow_exec) {
4822     // CreateFileMapping/MapViewOfFileEx can't map executable memory
4823     // unless it comes from a PE image (which the shared archive is not.)
4824     // Even VirtualProtect refuses to give execute access to mapped memory
4825     // that was not previously executable.
4826     //
4827     // Instead, stick the executable region in anonymous memory.  Yuck.
4828     // Penalty is that ~4 pages will not be shareable - in the future
4829     // we might consider DLLizing the shared archive with a proper PE
4830     // header so that mapping executable + sharing is possible.
4831 
4832     base = (char*) VirtualAlloc(addr, bytes, MEM_COMMIT | MEM_RESERVE,
4833                                 PAGE_READWRITE);
4834     if (base == NULL) {
4835       log_info(os)("VirtualAlloc() failed: GetLastError-&gt;%ld.", GetLastError());
4836       CloseHandle(hFile);
4837       return NULL;
4838     }
4839 
4840     DWORD bytes_read;
4841     OVERLAPPED overlapped;
4842     overlapped.Offset = (DWORD)file_offset;
4843     overlapped.OffsetHigh = 0;
4844     overlapped.hEvent = NULL;
4845     // ReadFile guarantees that if the return value is true, the requested
4846     // number of bytes were read before returning.
4847     bool res = ReadFile(hFile, base, (DWORD)bytes, &amp;bytes_read, &amp;overlapped) != 0;
4848     if (!res) {
4849       log_info(os)("ReadFile() failed: GetLastError-&gt;%ld.", GetLastError());
4850       release_memory(base, bytes);
4851       CloseHandle(hFile);
4852       return NULL;
4853     }
4854   } else {
4855     HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0,
4856                                     NULL /* file_name */);
4857     if (hMap == NULL) {
4858       log_info(os)("CreateFileMapping() failed: GetLastError-&gt;%ld.", GetLastError());
4859       CloseHandle(hFile);
4860       return NULL;
4861     }
4862 
4863     DWORD access = read_only ? FILE_MAP_READ : FILE_MAP_COPY;
4864     base = (char*)MapViewOfFileEx(hMap, access, 0, (DWORD)file_offset,
4865                                   (DWORD)bytes, addr);
4866     if (base == NULL) {
4867       log_info(os)("MapViewOfFileEx() failed: GetLastError-&gt;%ld.", GetLastError());
4868       CloseHandle(hMap);
4869       CloseHandle(hFile);
4870       return NULL;
4871     }
4872 
4873     if (CloseHandle(hMap) == 0) {
4874       log_info(os)("CloseHandle(hMap) failed: GetLastError-&gt;%ld.", GetLastError());
4875       CloseHandle(hFile);
4876       return base;
4877     }
4878   }
4879 
4880   if (allow_exec) {
4881     DWORD old_protect;
4882     DWORD exec_access = read_only ? PAGE_EXECUTE_READ : PAGE_EXECUTE_READWRITE;
4883     bool res = VirtualProtect(base, bytes, exec_access, &amp;old_protect) != 0;
4884 
4885     if (!res) {
4886       log_info(os)("VirtualProtect() failed: GetLastError-&gt;%ld.", GetLastError());
4887       // Don't consider this a hard error, on IA32 even if the
4888       // VirtualProtect fails, we should still be able to execute
4889       CloseHandle(hFile);
4890       return base;
4891     }
4892   }
4893 
4894   if (CloseHandle(hFile) == 0) {
4895     log_info(os)("CloseHandle(hFile) failed: GetLastError-&gt;%ld.", GetLastError());
4896     return base;
4897   }
4898 
4899   return base;
4900 }
4901 
4902 
4903 // Remap a block of memory.
4904 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
4905                           char *addr, size_t bytes, bool read_only,
4906                           bool allow_exec) {
4907   // This OS does not allow existing memory maps to be remapped so we
4908   // have to unmap the memory before we remap it.
4909   if (!os::unmap_memory(addr, bytes)) {
4910     return NULL;
4911   }
4912 
4913   // There is a very small theoretical window between the unmap_memory()
4914   // call above and the map_memory() call below where a thread in native
4915   // code may be able to access an address that is no longer mapped.
4916 
4917   return os::map_memory(fd, file_name, file_offset, addr, bytes,
4918                         read_only, allow_exec);
4919 }
4920 
4921 
4922 // Unmap a block of memory.
4923 // Returns true=success, otherwise false.
4924 
4925 bool os::pd_unmap_memory(char* addr, size_t bytes) {
4926   MEMORY_BASIC_INFORMATION mem_info;
4927   if (VirtualQuery(addr, &amp;mem_info, sizeof(mem_info)) == 0) {
4928     log_info(os)("VirtualQuery() failed: GetLastError-&gt;%ld.", GetLastError());
4929     return false;
4930   }
4931 
4932   // Executable memory was not mapped using CreateFileMapping/MapViewOfFileEx.
4933   // Instead, executable region was allocated using VirtualAlloc(). See
4934   // pd_map_memory() above.
4935   //
4936   // The following flags should match the 'exec_access' flages used for
4937   // VirtualProtect() in pd_map_memory().
4938   if (mem_info.Protect == PAGE_EXECUTE_READ ||
4939       mem_info.Protect == PAGE_EXECUTE_READWRITE) {
4940     return pd_release_memory(addr, bytes);
4941   }
4942 
4943   BOOL result = UnmapViewOfFile(addr);
4944   if (result == 0) {
4945     log_info(os)("UnmapViewOfFile() failed: GetLastError-&gt;%ld.", GetLastError());
4946     return false;
4947   }
4948   return true;
4949 }
4950 
4951 void os::pause() {
4952   char filename[MAX_PATH];
4953   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
4954     jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);
4955   } else {
4956     jio_snprintf(filename, MAX_PATH, "./vm.paused.%d", current_process_id());
4957   }
4958 
4959   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
4960   if (fd != -1) {
4961     struct stat buf;
4962     ::close(fd);
4963     while (::stat(filename, &amp;buf) == 0) {
4964       Sleep(100);
4965     }
4966   } else {
4967     jio_fprintf(stderr,
4968                 "Could not open pause file '%s', continuing immediately.\n", filename);
4969   }
4970 }
4971 
4972 os::WatcherThreadCrashProtection::WatcherThreadCrashProtection() {
4973   assert(Thread::current()-&gt;is_Watcher_thread(), "Must be WatcherThread");
4974 }
4975 
4976 // See the caveats for this class in os_windows.hpp
4977 // Protects the callback call so that raised OS EXCEPTIONS causes a jump back
4978 // into this method and returns false. If no OS EXCEPTION was raised, returns
4979 // true.
4980 // The callback is supposed to provide the method that should be protected.
4981 //
4982 bool os::WatcherThreadCrashProtection::call(os::CrashProtectionCallback&amp; cb) {
4983   assert(Thread::current()-&gt;is_Watcher_thread(), "Only for WatcherThread");
4984   assert(!WatcherThread::watcher_thread()-&gt;has_crash_protection(),
4985          "crash_protection already set?");
4986 
4987   bool success = true;
4988   __try {
4989     WatcherThread::watcher_thread()-&gt;set_crash_protection(this);
4990     cb.call();
4991   } __except(EXCEPTION_EXECUTE_HANDLER) {
4992     // only for protection, nothing to do
4993     success = false;
4994   }
4995   WatcherThread::watcher_thread()-&gt;set_crash_protection(NULL);
4996   return success;
4997 }
4998 
4999 // An Event wraps a win32 "CreateEvent" kernel handle.
5000 //
5001 // We have a number of choices regarding "CreateEvent" win32 handle leakage:
5002 //
5003 // 1:  When a thread dies return the Event to the EventFreeList, clear the ParkHandle
5004 //     field, and call CloseHandle() on the win32 event handle.  Unpark() would
5005 //     need to be modified to tolerate finding a NULL (invalid) win32 event handle.
5006 //     In addition, an unpark() operation might fetch the handle field, but the
5007 //     event could recycle between the fetch and the SetEvent() operation.
5008 //     SetEvent() would either fail because the handle was invalid, or inadvertently work,
5009 //     as the win32 handle value had been recycled.  In an ideal world calling SetEvent()
5010 //     on an stale but recycled handle would be harmless, but in practice this might
5011 //     confuse other non-Sun code, so it's not a viable approach.
5012 //
5013 // 2:  Once a win32 event handle is associated with an Event, it remains associated
5014 //     with the Event.  The event handle is never closed.  This could be construed
5015 //     as handle leakage, but only up to the maximum # of threads that have been extant
5016 //     at any one time.  This shouldn't be an issue, as windows platforms typically
5017 //     permit a process to have hundreds of thousands of open handles.
5018 //
5019 // 3:  Same as (1), but periodically, at stop-the-world time, rundown the EventFreeList
5020 //     and release unused handles.
5021 //
5022 // 4:  Add a CRITICAL_SECTION to the Event to protect LD+SetEvent from LD;ST(null);CloseHandle.
5023 //     It's not clear, however, that we wouldn't be trading one type of leak for another.
5024 //
5025 // 5.  Use an RCU-like mechanism (Read-Copy Update).
5026 //     Or perhaps something similar to Maged Michael's "Hazard pointers".
5027 //
5028 // We use (2).
5029 //
5030 // TODO-FIXME:
5031 // 1.  Reconcile Doug's JSR166 j.u.c park-unpark with the objectmonitor implementation.
5032 // 2.  Consider wrapping the WaitForSingleObject(Ex) calls in SEH try/finally blocks
5033 //     to recover from (or at least detect) the dreaded Windows 841176 bug.
5034 // 3.  Collapse the interrupt_event, the JSR166 parker event, and the objectmonitor ParkEvent
5035 //     into a single win32 CreateEvent() handle.
5036 //
5037 // Assumption:
5038 //    Only one parker can exist on an event, which is why we allocate
5039 //    them per-thread. Multiple unparkers can coexist.
5040 //
5041 // _Event transitions in park()
5042 //   -1 =&gt; -1 : illegal
5043 //    1 =&gt;  0 : pass - return immediately
5044 //    0 =&gt; -1 : block; then set _Event to 0 before returning
5045 //
5046 // _Event transitions in unpark()
5047 //    0 =&gt; 1 : just return
5048 //    1 =&gt; 1 : just return
5049 //   -1 =&gt; either 0 or 1; must signal target thread
5050 //         That is, we can safely transition _Event from -1 to either
5051 //         0 or 1.
5052 //
5053 // _Event serves as a restricted-range semaphore.
5054 //   -1 : thread is blocked, i.e. there is a waiter
5055 //    0 : neutral: thread is running or ready,
5056 //        could have been signaled after a wait started
5057 //    1 : signaled - thread is running or ready
5058 //
5059 // Another possible encoding of _Event would be with
5060 // explicit "PARKED" == 01b and "SIGNALED" == 10b bits.
5061 //
5062 
5063 int os::PlatformEvent::park(jlong Millis) {
5064   // Transitions for _Event:
5065   //   -1 =&gt; -1 : illegal
5066   //    1 =&gt;  0 : pass - return immediately
5067   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5068 
5069   guarantee(_ParkHandle != NULL , "Invariant");
5070   guarantee(Millis &gt; 0          , "Invariant");
5071 
5072   // CONSIDER: defer assigning a CreateEvent() handle to the Event until
5073   // the initial park() operation.
5074   // Consider: use atomic decrement instead of CAS-loop
5075 
5076   int v;
5077   for (;;) {
5078     v = _Event;
5079     if (Atomic::cmpxchg(v-1, &amp;_Event, v) == v) break;
5080   }
5081   guarantee((v == 0) || (v == 1), "invariant");
5082   if (v != 0) return OS_OK;
5083 
5084   // Do this the hard way by blocking ...
5085   // TODO: consider a brief spin here, gated on the success of recent
5086   // spin attempts by this thread.
5087   //
5088   // We decompose long timeouts into series of shorter timed waits.
5089   // Evidently large timo values passed in WaitForSingleObject() are problematic on some
5090   // versions of Windows.  See EventWait() for details.  This may be superstition.  Or not.
5091   // We trust the WAIT_TIMEOUT indication and don't track the elapsed wait time
5092   // with os::javaTimeNanos().  Furthermore, we assume that spurious returns from
5093   // ::WaitForSingleObject() caused by latent ::setEvent() operations will tend
5094   // to happen early in the wait interval.  Specifically, after a spurious wakeup (rv ==
5095   // WAIT_OBJECT_0 but _Event is still &lt; 0) we don't bother to recompute Millis to compensate
5096   // for the already waited time.  This policy does not admit any new outcomes.
5097   // In the future, however, we might want to track the accumulated wait time and
5098   // adjust Millis accordingly if we encounter a spurious wakeup.
5099 
5100   const int MAXTIMEOUT = 0x10000000;
5101   DWORD rv = WAIT_TIMEOUT;
5102   while (_Event &lt; 0 &amp;&amp; Millis &gt; 0) {
5103     DWORD prd = Millis;     // set prd = MAX (Millis, MAXTIMEOUT)
5104     if (Millis &gt; MAXTIMEOUT) {
5105       prd = MAXTIMEOUT;
5106     }
5107     rv = ::WaitForSingleObject(_ParkHandle, prd);
5108     assert(rv == WAIT_OBJECT_0 || rv == WAIT_TIMEOUT, "WaitForSingleObject failed");
5109     if (rv == WAIT_TIMEOUT) {
5110       Millis -= prd;
5111     }
5112   }
5113   v = _Event;
5114   _Event = 0;
5115   // see comment at end of os::PlatformEvent::park() below:
5116   OrderAccess::fence();
5117   // If we encounter a nearly simultanous timeout expiry and unpark()
5118   // we return OS_OK indicating we awoke via unpark().
5119   // Implementor's license -- returning OS_TIMEOUT would be equally valid, however.
5120   return (v &gt;= 0) ? OS_OK : OS_TIMEOUT;
5121 }
5122 
5123 void os::PlatformEvent::park() {
5124   // Transitions for _Event:
5125   //   -1 =&gt; -1 : illegal
5126   //    1 =&gt;  0 : pass - return immediately
5127   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5128 
5129   guarantee(_ParkHandle != NULL, "Invariant");
5130   // Invariant: Only the thread associated with the Event/PlatformEvent
5131   // may call park().
5132   // Consider: use atomic decrement instead of CAS-loop
5133   int v;
5134   for (;;) {
5135     v = _Event;
5136     if (Atomic::cmpxchg(v-1, &amp;_Event, v) == v) break;
5137   }
5138   guarantee((v == 0) || (v == 1), "invariant");
5139   if (v != 0) return;
5140 
5141   // Do this the hard way by blocking ...
5142   // TODO: consider a brief spin here, gated on the success of recent
5143   // spin attempts by this thread.
5144   while (_Event &lt; 0) {
5145     DWORD rv = ::WaitForSingleObject(_ParkHandle, INFINITE);
5146     assert(rv == WAIT_OBJECT_0, "WaitForSingleObject failed");
5147   }
5148 
5149   // Usually we'll find _Event == 0 at this point, but as
5150   // an optional optimization we clear it, just in case can
5151   // multiple unpark() operations drove _Event up to 1.
5152   _Event = 0;
5153   OrderAccess::fence();
5154   guarantee(_Event &gt;= 0, "invariant");
5155 }
5156 
5157 void os::PlatformEvent::unpark() {
5158   guarantee(_ParkHandle != NULL, "Invariant");
5159 
5160   // Transitions for _Event:
5161   //    0 =&gt; 1 : just return
5162   //    1 =&gt; 1 : just return
5163   //   -1 =&gt; either 0 or 1; must signal target thread
5164   //         That is, we can safely transition _Event from -1 to either
5165   //         0 or 1.
5166   // See also: "Semaphores in Plan 9" by Mullender &amp; Cox
5167   //
5168   // Note: Forcing a transition from "-1" to "1" on an unpark() means
5169   // that it will take two back-to-back park() calls for the owning
5170   // thread to block. This has the benefit of forcing a spurious return
5171   // from the first park() call after an unpark() call which will help
5172   // shake out uses of park() and unpark() without condition variables.
5173 
5174   if (Atomic::xchg(1, &amp;_Event) &gt;= 0) return;
5175 
5176   ::SetEvent(_ParkHandle);
5177 }
5178 
5179 
5180 // JSR166
5181 // -------------------------------------------------------
5182 
5183 // The Windows implementation of Park is very straightforward: Basic
5184 // operations on Win32 Events turn out to have the right semantics to
5185 // use them directly. We opportunistically resuse the event inherited
5186 // from Monitor.
5187 
5188 void Parker::park(bool isAbsolute, jlong time) {
5189   guarantee(_ParkEvent != NULL, "invariant");
5190   // First, demultiplex/decode time arguments
5191   if (time &lt; 0) { // don't wait
5192     return;
5193   } else if (time == 0 &amp;&amp; !isAbsolute) {
5194     time = INFINITE;
5195   } else if (isAbsolute) {
5196     time -= os::javaTimeMillis(); // convert to relative time
5197     if (time &lt;= 0) {  // already elapsed
5198       return;
5199     }
5200   } else { // relative
5201     time /= 1000000;  // Must coarsen from nanos to millis
5202     if (time == 0) {  // Wait for the minimal time unit if zero
5203       time = 1;
5204     }
5205   }
5206 
5207   JavaThread* thread = JavaThread::current();
5208 
5209   // Don't wait if interrupted or already triggered
5210   if (Thread::is_interrupted(thread, false) ||
5211       WaitForSingleObject(_ParkEvent, 0) == WAIT_OBJECT_0) {
5212     ResetEvent(_ParkEvent);
5213     return;
5214   } else {
5215     ThreadBlockInVM tbivm(thread);
5216     OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
5217     thread-&gt;set_suspend_equivalent();
5218 
5219     WaitForSingleObject(_ParkEvent, time);
5220     ResetEvent(_ParkEvent);
5221 
5222     // If externally suspended while waiting, re-suspend
5223     if (thread-&gt;handle_special_suspend_equivalent_condition()) {
5224       thread-&gt;java_suspend_self();
5225     }
5226   }
5227 }
5228 
5229 void Parker::unpark() {
5230   guarantee(_ParkEvent != NULL, "invariant");
5231   SetEvent(_ParkEvent);
5232 }
5233 
5234 // Run the specified command in a separate process. Return its exit value,
5235 // or -1 on failure (e.g. can't create a new process).
5236 int os::fork_and_exec(char* cmd) {
5237   STARTUPINFO si;
5238   PROCESS_INFORMATION pi;
5239 
5240   memset(&amp;si, 0, sizeof(si));
5241   si.cb = sizeof(si);
5242   memset(&amp;pi, 0, sizeof(pi));
5243   BOOL rslt = CreateProcess(NULL,   // executable name - use command line
5244                             cmd,    // command line
5245                             NULL,   // process security attribute
5246                             NULL,   // thread security attribute
5247                             TRUE,   // inherits system handles
5248                             0,      // no creation flags
5249                             NULL,   // use parent's environment block
5250                             NULL,   // use parent's starting directory
5251                             &amp;si,    // (in) startup information
5252                             &amp;pi);   // (out) process information
5253 
5254   if (rslt) {
5255     // Wait until child process exits.
5256     WaitForSingleObject(pi.hProcess, INFINITE);
5257 
5258     DWORD exit_code;
5259     GetExitCodeProcess(pi.hProcess, &amp;exit_code);
5260 
5261     // Close process and thread handles.
5262     CloseHandle(pi.hProcess);
5263     CloseHandle(pi.hThread);
5264 
5265     return (int)exit_code;
5266   } else {
5267     return -1;
5268   }
5269 }
5270 
5271 bool os::find(address addr, outputStream* st) {
5272   int offset = -1;
5273   bool result = false;
5274   char buf[256];
5275   if (os::dll_address_to_library_name(addr, buf, sizeof(buf), &amp;offset)) {
5276     st-&gt;print(PTR_FORMAT " ", addr);
5277     if (strlen(buf) &lt; sizeof(buf) - 1) {
5278       char* p = strrchr(buf, '\\');
5279       if (p) {
5280         st-&gt;print("%s", p + 1);
5281       } else {
5282         st-&gt;print("%s", buf);
5283       }
5284     } else {
5285         // The library name is probably truncated. Let's omit the library name.
5286         // See also JDK-8147512.
5287     }
5288     if (os::dll_address_to_function_name(addr, buf, sizeof(buf), &amp;offset)) {
5289       st-&gt;print("::%s + 0x%x", buf, offset);
5290     }
5291     st-&gt;cr();
5292     result = true;
5293   }
5294   return result;
5295 }
5296 
5297 LONG WINAPI os::win32::serialize_fault_filter(struct _EXCEPTION_POINTERS* e) {
5298   DWORD exception_code = e-&gt;ExceptionRecord-&gt;ExceptionCode;
5299 
5300   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
5301     JavaThread* thread = JavaThread::current();
5302     PEXCEPTION_RECORD exceptionRecord = e-&gt;ExceptionRecord;
5303     address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
5304 
5305     if (os::is_memory_serialize_page(thread, addr)) {
5306       return EXCEPTION_CONTINUE_EXECUTION;
5307     }
5308   }
5309 
5310   return EXCEPTION_CONTINUE_SEARCH;
5311 }
5312 
5313 // We don't build a headless jre for Windows
5314 bool os::is_headless_jre() { return false; }
5315 
5316 static jint initSock() {
5317   WSADATA wsadata;
5318 
5319   if (WSAStartup(MAKEWORD(2,2), &amp;wsadata) != 0) {
5320     jio_fprintf(stderr, "Could not initialize Winsock (error: %d)\n",
5321                 ::GetLastError());
5322     return JNI_ERR;
5323   }
5324   return JNI_OK;
5325 }
5326 
5327 struct hostent* os::get_host_by_name(char* name) {
5328   return (struct hostent*)gethostbyname(name);
5329 }
5330 
5331 int os::socket_close(int fd) {
5332   return ::closesocket(fd);
5333 }
5334 
5335 int os::socket(int domain, int type, int protocol) {
5336   return ::socket(domain, type, protocol);
5337 }
5338 
5339 int os::connect(int fd, struct sockaddr* him, socklen_t len) {
5340   return ::connect(fd, him, len);
5341 }
5342 
5343 int os::recv(int fd, char* buf, size_t nBytes, uint flags) {
5344   return ::recv(fd, buf, (int)nBytes, flags);
5345 }
5346 
5347 int os::send(int fd, char* buf, size_t nBytes, uint flags) {
5348   return ::send(fd, buf, (int)nBytes, flags);
5349 }
5350 
5351 int os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {
5352   return ::send(fd, buf, (int)nBytes, flags);
5353 }
5354 
5355 // WINDOWS CONTEXT Flags for THREAD_SAMPLING
5356 #if defined(IA32)
5357   #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS)
5358 #elif defined (AMD64)
5359   #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
5360 #endif
5361 
5362 // returns true if thread could be suspended,
5363 // false otherwise
5364 static bool do_suspend(HANDLE* h) {
5365   if (h != NULL) {
5366     if (SuspendThread(*h) != ~0) {
5367       return true;
5368     }
5369   }
5370   return false;
5371 }
5372 
5373 // resume the thread
5374 // calling resume on an active thread is a no-op
5375 static void do_resume(HANDLE* h) {
5376   if (h != NULL) {
5377     ResumeThread(*h);
5378   }
5379 }
5380 
5381 // retrieve a suspend/resume context capable handle
5382 // from the tid. Caller validates handle return value.
5383 void get_thread_handle_for_extended_context(HANDLE* h,
5384                                             OSThread::thread_id_t tid) {
5385   if (h != NULL) {
5386     *h = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);
5387   }
5388 }
5389 
5390 // Thread sampling implementation
5391 //
5392 void os::SuspendedThreadTask::internal_do_task() {
5393   CONTEXT    ctxt;
5394   HANDLE     h = NULL;
5395 
5396   // get context capable handle for thread
5397   get_thread_handle_for_extended_context(&amp;h, _thread-&gt;osthread()-&gt;thread_id());
5398 
5399   // sanity
5400   if (h == NULL || h == INVALID_HANDLE_VALUE) {
5401     return;
5402   }
5403 
5404   // suspend the thread
5405   if (do_suspend(&amp;h)) {
5406     ctxt.ContextFlags = sampling_context_flags;
5407     // get thread context
5408     GetThreadContext(h, &amp;ctxt);
5409     SuspendedThreadTaskContext context(_thread, &amp;ctxt);
5410     // pass context to Thread Sampling impl
5411     do_task(context);
5412     // resume thread
5413     do_resume(&amp;h);
5414   }
5415 
5416   // close handle
5417   CloseHandle(h);
5418 }
5419 
5420 bool os::start_debugging(char *buf, int buflen) {
5421   int len = (int)strlen(buf);
5422   char *p = &amp;buf[len];
5423 
5424   jio_snprintf(p, buflen-len,
5425              "\n\n"
5426              "Do you want to debug the problem?\n\n"
5427              "To debug, attach Visual Studio to process %d; then switch to thread 0x%x\n"
5428              "Select 'Yes' to launch Visual Studio automatically (PATH must include msdev)\n"
5429              "Otherwise, select 'No' to abort...",
5430              os::current_process_id(), os::current_thread_id());
5431 
5432   bool yes = os::message_box("Unexpected Error", buf);
5433 
5434   if (yes) {
5435     // os::breakpoint() calls DebugBreak(), which causes a breakpoint
5436     // exception. If VM is running inside a debugger, the debugger will
5437     // catch the exception. Otherwise, the breakpoint exception will reach
5438     // the default windows exception handler, which can spawn a debugger and
5439     // automatically attach to the dying VM.
5440     os::breakpoint();
5441     yes = false;
5442   }
5443   return yes;
5444 }
5445 
5446 void* os::get_default_process_handle() {
5447   return (void*)GetModuleHandle(NULL);
5448 }
5449 
5450 // Builds a platform dependent Agent_OnLoad_&lt;lib_name&gt; function name
5451 // which is used to find statically linked in agents.
5452 // Additionally for windows, takes into account __stdcall names.
5453 // Parameters:
5454 //            sym_name: Symbol in library we are looking for
5455 //            lib_name: Name of library to look in, NULL for shared libs.
5456 //            is_absolute_path == true if lib_name is absolute path to agent
5457 //                                     such as "C:/a/b/L.dll"
5458 //            == false if only the base name of the library is passed in
5459 //               such as "L"
5460 char* os::build_agent_function_name(const char *sym_name, const char *lib_name,
5461                                     bool is_absolute_path) {
5462   char *agent_entry_name;
5463   size_t len;
5464   size_t name_len;
5465   size_t prefix_len = strlen(JNI_LIB_PREFIX);
5466   size_t suffix_len = strlen(JNI_LIB_SUFFIX);
5467   const char *start;
5468 
5469   if (lib_name != NULL) {
5470     len = name_len = strlen(lib_name);
5471     if (is_absolute_path) {
5472       // Need to strip path, prefix and suffix
5473       if ((start = strrchr(lib_name, *os::file_separator())) != NULL) {
5474         lib_name = ++start;
5475       } else {
5476         // Need to check for drive prefix
5477         if ((start = strchr(lib_name, ':')) != NULL) {
5478           lib_name = ++start;
5479         }
5480       }
5481       if (len &lt;= (prefix_len + suffix_len)) {
5482         return NULL;
5483       }
5484       lib_name += prefix_len;
5485       name_len = strlen(lib_name) - suffix_len;
5486     }
5487   }
5488   len = (lib_name != NULL ? name_len : 0) + strlen(sym_name) + 2;
5489   agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);
5490   if (agent_entry_name == NULL) {
5491     return NULL;
5492   }
5493   if (lib_name != NULL) {
5494     const char *p = strrchr(sym_name, '@');
5495     if (p != NULL &amp;&amp; p != sym_name) {
5496       // sym_name == _Agent_OnLoad@XX
5497       strncpy(agent_entry_name, sym_name, (p - sym_name));
5498       agent_entry_name[(p-sym_name)] = '\0';
5499       // agent_entry_name == _Agent_OnLoad
5500       strcat(agent_entry_name, "_");
5501       strncat(agent_entry_name, lib_name, name_len);
5502       strcat(agent_entry_name, p);
5503       // agent_entry_name == _Agent_OnLoad_lib_name@XX
5504     } else {
5505       strcpy(agent_entry_name, sym_name);
5506       strcat(agent_entry_name, "_");
5507       strncat(agent_entry_name, lib_name, name_len);
5508     }
5509   } else {
5510     strcpy(agent_entry_name, sym_name);
5511   }
5512   return agent_entry_name;
5513 }
5514 
5515 #ifndef PRODUCT
5516 
5517 // test the code path in reserve_memory_special() that tries to allocate memory in a single
5518 // contiguous memory block at a particular address.
5519 // The test first tries to find a good approximate address to allocate at by using the same
5520 // method to allocate some memory at any address. The test then tries to allocate memory in
5521 // the vicinity (not directly after it to avoid possible by-chance use of that location)
5522 // This is of course only some dodgy assumption, there is no guarantee that the vicinity of
5523 // the previously allocated memory is available for allocation. The only actual failure
5524 // that is reported is when the test tries to allocate at a particular location but gets a
5525 // different valid one. A NULL return value at this point is not considered an error but may
5526 // be legitimate.
5527 // If -XX:+VerboseInternalVMTests is enabled, print some explanatory messages.
5528 void TestReserveMemorySpecial_test() {
5529   if (!UseLargePages) {
5530     if (VerboseInternalVMTests) {
5531       tty-&gt;print("Skipping test because large pages are disabled");
5532     }
5533     return;
5534   }
5535   // save current value of globals
5536   bool old_use_large_pages_individual_allocation = UseLargePagesIndividualAllocation;
5537   bool old_use_numa_interleaving = UseNUMAInterleaving;
5538 
5539   // set globals to make sure we hit the correct code path
5540   UseLargePagesIndividualAllocation = UseNUMAInterleaving = false;
5541 
5542   // do an allocation at an address selected by the OS to get a good one.
5543   const size_t large_allocation_size = os::large_page_size() * 4;
5544   char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), NULL, false);
5545   if (result == NULL) {
5546     if (VerboseInternalVMTests) {
5547       tty-&gt;print("Failed to allocate control block with size " SIZE_FORMAT ". Skipping remainder of test.",
5548                           large_allocation_size);
5549     }
5550   } else {
5551     os::release_memory_special(result, large_allocation_size);
5552 
5553     // allocate another page within the recently allocated memory area which seems to be a good location. At least
5554     // we managed to get it once.
5555     const size_t expected_allocation_size = os::large_page_size();
5556     char* expected_location = result + os::large_page_size();
5557     char* actual_location = os::reserve_memory_special(expected_allocation_size, os::large_page_size(), expected_location, false);
5558     if (actual_location == NULL) {
5559       if (VerboseInternalVMTests) {
5560         tty-&gt;print("Failed to allocate any memory at " PTR_FORMAT " size " SIZE_FORMAT ". Skipping remainder of test.",
5561                             expected_location, large_allocation_size);
5562       }
5563     } else {
5564       // release memory
5565       os::release_memory_special(actual_location, expected_allocation_size);
5566       // only now check, after releasing any memory to avoid any leaks.
5567       assert(actual_location == expected_location,
5568              "Failed to allocate memory at requested location " PTR_FORMAT " of size " SIZE_FORMAT ", is " PTR_FORMAT " instead",
5569              expected_location, expected_allocation_size, actual_location);
5570     }
5571   }
5572 
5573   // restore globals
5574   UseLargePagesIndividualAllocation = old_use_large_pages_individual_allocation;
5575   UseNUMAInterleaving = old_use_numa_interleaving;
5576 }
5577 #endif // PRODUCT
5578 
5579 /*
5580   All the defined signal names for Windows.
5581 
5582   NOTE that not all of these names are accepted by FindSignal!
5583 
5584   For various reasons some of these may be rejected at runtime.
5585 
5586   Here are the names currently accepted by a user of sun.misc.Signal with
5587   1.4.1 (ignoring potential interaction with use of chaining, etc):
5588 
5589      (LIST TBD)
5590 
5591 */
5592 int os::get_signal_number(const char* name) {
5593   static const struct {
5594     char* name;
5595     int   number;
5596   } siglabels [] =
5597     // derived from version 6.0 VC98/include/signal.h
5598   {"ABRT",      SIGABRT,        // abnormal termination triggered by abort cl
5599   "FPE",        SIGFPE,         // floating point exception
5600   "SEGV",       SIGSEGV,        // segment violation
5601   "INT",        SIGINT,         // interrupt
5602   "TERM",       SIGTERM,        // software term signal from kill
5603   "BREAK",      SIGBREAK,       // Ctrl-Break sequence
5604   "ILL",        SIGILL};        // illegal instruction
5605   for (unsigned i = 0; i &lt; ARRAY_SIZE(siglabels); ++i) {
5606     if (strcmp(name, siglabels[i].name) == 0) {
5607       return siglabels[i].number;
5608     }
5609   }
5610   return -1;
5611 }
5612 
5613 // Fast current thread access
5614 
5615 int os::win32::_thread_ptr_offset = 0;
5616 
5617 static void call_wrapper_dummy() {}
5618 
5619 // We need to call the os_exception_wrapper once so that it sets
5620 // up the offset from FS of the thread pointer.
5621 void os::win32::initialize_thread_ptr_offset() {
5622   os::os_exception_wrapper((java_call_t)call_wrapper_dummy,
5623                            NULL, NULL, NULL, NULL);
5624 }
</pre></body></html>
