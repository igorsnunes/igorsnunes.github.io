<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/os_cpu/solaris_x86/vm </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/os_cpu/linux_x86/vm/os_linux_x86.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/share/vm/classfile/classLoader.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/os_cpu/solaris_x86/vm/os_solaris_x86.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 238   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);
 239   return frame(sp, fp, epc.pc());
 240 }
 241 
 242 frame os::fetch_frame_from_ucontext(Thread* thread, void* ucVoid) {
 243   intptr_t* sp;
 244   intptr_t* fp;
 245   ExtendedPC epc = os::Solaris::fetch_frame_from_ucontext(thread, (ucontext_t*)ucVoid, &amp;sp, &amp;fp);
 246   return frame(sp, fp, epc.pc());
 247 }
 248 
 249 bool os::Solaris::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
 250  address pc = (address) os::Solaris::ucontext_get_pc(uc);
 251   if (Interpreter::contains(pc)) {
 252     // interpreter performs stack banging after the fixed frame header has
 253     // been generated while the compilers perform it before. To maintain
 254     // semantic consistency between interpreted and compiled frames, the
 255     // method returns the Java sender of the current frame.
 256     *fr = os::fetch_frame_from_ucontext(thread, uc);
 257     if (!fr-&gt;is_first_java_frame()) {
<span class="changed"> 258       assert(fr-&gt;safe_for_sender(thread), "Safety check");</span>


 259       *fr = fr-&gt;java_sender();
 260     }
 261   } else {
 262     // more complex code with compiled code
 263     assert(!Interpreter::contains(pc), "Interpreted methods should have been handled above");
 264     CodeBlob* cb = CodeCache::find_blob(pc);
 265     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
 266       // Not sure where the pc points to, fallback to default
 267       // stack overflow handling
 268       return false;
 269     } else {
 270       // in compiled code, the stack banging is performed just after the return pc
 271       // has been pushed on the stack
 272       intptr_t* fp = os::Solaris::ucontext_get_fp(uc);
 273       intptr_t* sp = os::Solaris::ucontext_get_sp(uc);
 274       *fr = frame(sp + 1, fp, (address)*sp);
 275       if (!fr-&gt;is_java_frame()) {
<span class="changed"> 276         assert(fr-&gt;safe_for_sender(thread), "Safety check");</span>
 277         *fr = fr-&gt;java_sender();
 278       }
 279     }
 280   }
 281   assert(fr-&gt;is_java_frame(), "Safety check");
 282   return true;
 283 }
 284 
 285 frame os::get_sender_for_C_frame(frame* fr) {
 286   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
 287 }
 288 
 289 extern "C" intptr_t *_get_current_sp();  // in .il file
 290 
 291 address os::current_stack_pointer() {
 292   return (address)_get_current_sp();
 293 }
 294 
 295 extern "C" intptr_t *_get_current_fp();  // in .il file
 296 

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 238   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);
 239   return frame(sp, fp, epc.pc());
 240 }
 241 
 242 frame os::fetch_frame_from_ucontext(Thread* thread, void* ucVoid) {
 243   intptr_t* sp;
 244   intptr_t* fp;
 245   ExtendedPC epc = os::Solaris::fetch_frame_from_ucontext(thread, (ucontext_t*)ucVoid, &amp;sp, &amp;fp);
 246   return frame(sp, fp, epc.pc());
 247 }
 248 
 249 bool os::Solaris::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
 250  address pc = (address) os::Solaris::ucontext_get_pc(uc);
 251   if (Interpreter::contains(pc)) {
 252     // interpreter performs stack banging after the fixed frame header has
 253     // been generated while the compilers perform it before. To maintain
 254     // semantic consistency between interpreted and compiled frames, the
 255     // method returns the Java sender of the current frame.
 256     *fr = os::fetch_frame_from_ucontext(thread, uc);
 257     if (!fr-&gt;is_first_java_frame()) {
<span class="changed"> 258       // get_frame_at_stack_banging_point() is only called when we</span>
<span class="changed"> 259       // have well defined stacks so java_sender() calls do not need</span>
<span class="changed"> 260       // to assert safe_for_sender() first.</span>
 261       *fr = fr-&gt;java_sender();
 262     }
 263   } else {
 264     // more complex code with compiled code
 265     assert(!Interpreter::contains(pc), "Interpreted methods should have been handled above");
 266     CodeBlob* cb = CodeCache::find_blob(pc);
 267     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
 268       // Not sure where the pc points to, fallback to default
 269       // stack overflow handling
 270       return false;
 271     } else {
 272       // in compiled code, the stack banging is performed just after the return pc
 273       // has been pushed on the stack
 274       intptr_t* fp = os::Solaris::ucontext_get_fp(uc);
 275       intptr_t* sp = os::Solaris::ucontext_get_sp(uc);
 276       *fr = frame(sp + 1, fp, (address)*sp);
 277       if (!fr-&gt;is_java_frame()) {
<span class="changed"> 278         // See java_sender() comment above.</span>
 279         *fr = fr-&gt;java_sender();
 280       }
 281     }
 282   }
 283   assert(fr-&gt;is_java_frame(), "Safety check");
 284   return true;
 285 }
 286 
 287 frame os::get_sender_for_C_frame(frame* fr) {
 288   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
 289 }
 290 
 291 extern "C" intptr_t *_get_current_sp();  // in .il file
 292 
 293 address os::current_stack_pointer() {
 294   return (address)_get_current_sp();
 295 }
 296 
 297 extern "C" intptr_t *_get_current_fp();  // in .il file
 298 

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/os_cpu/linux_x86/vm/os_linux_x86.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/share/vm/classfile/classLoader.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
