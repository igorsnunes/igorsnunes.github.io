<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12651">12651</a> : Sha2 intrinsics implementation</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2016 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_PPC_VM_ASSEMBLER_PPC_HPP
  27 #define CPU_PPC_VM_ASSEMBLER_PPC_HPP
  28 
  29 #include "asm/register.hpp"
  30 
  31 // Address is an abstraction used to represent a memory location
  32 // as used in assembler instructions.
  33 // PPC instructions grok either baseReg + indexReg or baseReg + disp.
  34 class Address VALUE_OBJ_CLASS_SPEC {
  35  private:
  36   Register _base;         // Base register.
  37   Register _index;        // Index register.
  38   intptr_t _disp;         // Displacement.
  39 
  40  public:
  41   Address(Register b, Register i, address d = 0)
  42     : _base(b), _index(i), _disp((intptr_t)d) {
  43     assert(i == noreg || d == 0, "can't have both");
  44   }
  45 
  46   Address(Register b, address d = 0)
  47     : _base(b), _index(noreg), _disp((intptr_t)d) {}
  48 
  49   Address(Register b, intptr_t d)
  50     : _base(b), _index(noreg), _disp(d) {}
  51 
  52   Address(Register b, RegisterOrConstant roc)
  53     : _base(b), _index(noreg), _disp(0) {
  54     if (roc.is_constant()) _disp = roc.as_constant(); else _index = roc.as_register();
  55   }
  56 
  57   Address()
  58     : _base(noreg), _index(noreg), _disp(0) {}
  59 
  60   // accessors
  61   Register base()  const { return _base; }
  62   Register index() const { return _index; }
  63   int      disp()  const { return (int)_disp; }
  64   bool     is_const() const { return _base == noreg &amp;&amp; _index == noreg; }
  65 };
  66 
  67 class AddressLiteral VALUE_OBJ_CLASS_SPEC {
  68  private:
  69   address          _address;
  70   RelocationHolder _rspec;
  71 
  72   RelocationHolder rspec_from_rtype(relocInfo::relocType rtype, address addr) {
  73     switch (rtype) {
  74     case relocInfo::external_word_type:
  75       return external_word_Relocation::spec(addr);
  76     case relocInfo::internal_word_type:
  77       return internal_word_Relocation::spec(addr);
  78     case relocInfo::opt_virtual_call_type:
  79       return opt_virtual_call_Relocation::spec();
  80     case relocInfo::static_call_type:
  81       return static_call_Relocation::spec();
  82     case relocInfo::runtime_call_type:
  83       return runtime_call_Relocation::spec();
  84     case relocInfo::none:
  85       return RelocationHolder();
  86     default:
  87       ShouldNotReachHere();
  88       return RelocationHolder();
  89     }
  90   }
  91 
  92  protected:
  93   // creation
  94   AddressLiteral() : _address(NULL), _rspec(NULL) {}
  95 
  96  public:
  97   AddressLiteral(address addr, RelocationHolder const&amp; rspec)
  98     : _address(addr),
  99       _rspec(rspec) {}
 100 
 101   AddressLiteral(address addr, relocInfo::relocType rtype = relocInfo::none)
 102     : _address((address) addr),
 103       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 104 
 105   AddressLiteral(oop* addr, relocInfo::relocType rtype = relocInfo::none)
 106     : _address((address) addr),
 107       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 108 
 109   intptr_t value() const { return (intptr_t) _address; }
 110 
 111   const RelocationHolder&amp; rspec() const { return _rspec; }
 112 };
 113 
 114 // Argument is an abstraction used to represent an outgoing
 115 // actual argument or an incoming formal parameter, whether
 116 // it resides in memory or in a register, in a manner consistent
 117 // with the PPC Application Binary Interface, or ABI. This is
 118 // often referred to as the native or C calling convention.
 119 
 120 class Argument VALUE_OBJ_CLASS_SPEC {
 121  private:
 122   int _number;  // The number of the argument.
 123  public:
 124   enum {
 125     // Only 8 registers may contain integer parameters.
 126     n_register_parameters = 8,
 127     // Can have up to 8 floating registers.
 128     n_float_register_parameters = 8,
 129 
 130     // PPC C calling conventions.
 131     // The first eight arguments are passed in int regs if they are int.
 132     n_int_register_parameters_c = 8,
 133     // The first thirteen float arguments are passed in float regs.
 134     n_float_register_parameters_c = 13,
 135     // Only the first 8 parameters are not placed on the stack. Aix disassembly
 136     // shows that xlC places all float args after argument 8 on the stack AND
 137     // in a register. This is not documented, but we follow this convention, too.
 138     n_regs_not_on_stack_c = 8,
 139   };
 140   // creation
 141   Argument(int number) : _number(number) {}
 142 
 143   int  number() const { return _number; }
 144 
 145   // Locating register-based arguments:
 146   bool is_register() const { return _number &lt; n_register_parameters; }
 147 
 148   Register as_register() const {
 149     assert(is_register(), "must be a register argument");
 150     return as_Register(number() + R3_ARG1-&gt;encoding());
 151   }
 152 };
 153 
 154 #if !defined(ABI_ELFv2)
 155 // A ppc64 function descriptor.
 156 struct FunctionDescriptor VALUE_OBJ_CLASS_SPEC {
 157  private:
 158   address _entry;
 159   address _toc;
 160   address _env;
 161 
 162  public:
 163   inline address entry() const { return _entry; }
 164   inline address toc()   const { return _toc; }
 165   inline address env()   const { return _env; }
 166 
 167   inline void set_entry(address entry) { _entry = entry; }
 168   inline void set_toc(  address toc)   { _toc   = toc; }
 169   inline void set_env(  address env)   { _env   = env; }
 170 
 171   inline static ByteSize entry_offset() { return byte_offset_of(FunctionDescriptor, _entry); }
 172   inline static ByteSize toc_offset()   { return byte_offset_of(FunctionDescriptor, _toc); }
 173   inline static ByteSize env_offset()   { return byte_offset_of(FunctionDescriptor, _env); }
 174 
 175   // Friend functions can be called without loading toc and env.
 176   enum {
 177     friend_toc = 0xcafe,
 178     friend_env = 0xc0de
 179   };
 180 
 181   inline bool is_friend_function() const {
 182     return (toc() == (address) friend_toc) &amp;&amp; (env() == (address) friend_env);
 183   }
 184 
 185   // Constructor for stack-allocated instances.
 186   FunctionDescriptor() {
 187     _entry = (address) 0xbad;
 188     _toc   = (address) 0xbad;
 189     _env   = (address) 0xbad;
 190   }
 191 };
 192 #endif
 193 
 194 
 195 // The PPC Assembler: Pure assembler doing NO optimizations on the
 196 // instruction level; i.e., what you write is what you get. The
 197 // Assembler is generating code into a CodeBuffer.
 198 
 199 class Assembler : public AbstractAssembler {
 200  protected:
 201   // Displacement routines
 202   static int  patched_branch(int dest_pos, int inst, int inst_pos);
 203   static int  branch_destination(int inst, int pos);
 204 
 205   friend class AbstractAssembler;
 206 
 207   // Code patchers need various routines like inv_wdisp()
 208   friend class NativeInstruction;
 209   friend class NativeGeneralJump;
 210   friend class Relocation;
 211 
 212  public:
 213 
 214   enum shifts {
 215     XO_21_29_SHIFT = 2,
 216     XO_21_30_SHIFT = 1,
 217     XO_27_29_SHIFT = 2,
 218     XO_30_31_SHIFT = 0,
 219     SPR_5_9_SHIFT  = 11u, // SPR_5_9 field in bits 11 -- 15
 220     SPR_0_4_SHIFT  = 16u, // SPR_0_4 field in bits 16 -- 20
 221     RS_SHIFT       = 21u, // RS field in bits 21 -- 25
 222     OPCODE_SHIFT   = 26u, // opcode in bits 26 -- 31
 223   };
 224 
 225   enum opcdxos_masks {
 226     XL_FORM_OPCODE_MASK = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 227     ADDI_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 228     ADDIS_OPCODE_MASK   = (63u &lt;&lt; OPCODE_SHIFT),
 229     BXX_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 230     BCXX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 231     // trap instructions
 232     TDI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 233     TWI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 234     TD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 235     TW_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 236     LD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (3u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 237     STD_OPCODE_MASK     = LD_OPCODE_MASK,
 238     STDU_OPCODE_MASK    = STD_OPCODE_MASK,
 239     STDX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 240     STDUX_OPCODE_MASK   = STDX_OPCODE_MASK,
 241     STW_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 242     STWU_OPCODE_MASK    = STW_OPCODE_MASK,
 243     STWX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 244     STWUX_OPCODE_MASK   = STWX_OPCODE_MASK,
 245     MTCTR_OPCODE_MASK   = ~(31u &lt;&lt; RS_SHIFT),
 246     ORI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 247     ORIS_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 248     RLDICR_OPCODE_MASK  = (63u &lt;&lt; OPCODE_SHIFT) | (7u &lt;&lt; XO_27_29_SHIFT)
 249   };
 250 
 251   enum opcdxos {
 252     ADD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 266u &lt;&lt; 1),
 253     ADDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  10u &lt;&lt; 1),
 254     ADDI_OPCODE   = (14u &lt;&lt; OPCODE_SHIFT),
 255     ADDIS_OPCODE  = (15u &lt;&lt; OPCODE_SHIFT),
 256     ADDIC__OPCODE = (13u &lt;&lt; OPCODE_SHIFT),
 257     ADDE_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 138u &lt;&lt; 1),
 258     ADDME_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 234u &lt;&lt; 1),
 259     ADDZE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 202u &lt;&lt; 1),
 260     SUBF_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  40u &lt;&lt; 1),
 261     SUBFC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   8u &lt;&lt; 1),
 262     SUBFE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 136u &lt;&lt; 1),
 263     SUBFIC_OPCODE = (8u  &lt;&lt; OPCODE_SHIFT),
 264     SUBFME_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 232u &lt;&lt; 1),
 265     SUBFZE_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 200u &lt;&lt; 1),
 266     DIVW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 491u &lt;&lt; 1),
 267     MULLW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 235u &lt;&lt; 1),
 268     MULHW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  75u &lt;&lt; 1),
 269     MULHWU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  11u &lt;&lt; 1),
 270     MULLI_OPCODE  = (7u  &lt;&lt; OPCODE_SHIFT),
 271     AND_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  28u &lt;&lt; 1),
 272     ANDI_OPCODE   = (28u &lt;&lt; OPCODE_SHIFT),
 273     ANDIS_OPCODE  = (29u &lt;&lt; OPCODE_SHIFT),
 274     ANDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  60u &lt;&lt; 1),
 275     ORC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 412u &lt;&lt; 1),
 276     OR_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT | 444u &lt;&lt; 1),
 277     ORI_OPCODE    = (24u &lt;&lt; OPCODE_SHIFT),
 278     ORIS_OPCODE   = (25u &lt;&lt; OPCODE_SHIFT),
 279     XOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 316u &lt;&lt; 1),
 280     XORI_OPCODE   = (26u &lt;&lt; OPCODE_SHIFT),
 281     XORIS_OPCODE  = (27u &lt;&lt; OPCODE_SHIFT),
 282 
 283     NEG_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 104u &lt;&lt; 1),
 284 
 285     RLWINM_OPCODE = (21u &lt;&lt; OPCODE_SHIFT),
 286     CLRRWI_OPCODE = RLWINM_OPCODE,
 287     CLRLWI_OPCODE = RLWINM_OPCODE,
 288 
 289     RLWIMI_OPCODE = (20u &lt;&lt; OPCODE_SHIFT),
 290 
 291     SLW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  24u &lt;&lt; 1),
 292     SLWI_OPCODE   = RLWINM_OPCODE,
 293     SRW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 536u &lt;&lt; 1),
 294     SRWI_OPCODE   = RLWINM_OPCODE,
 295     SRAW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 792u &lt;&lt; 1),
 296     SRAWI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 824u &lt;&lt; 1),
 297 
 298     CMP_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; 1),
 299     CMPI_OPCODE   = (11u &lt;&lt; OPCODE_SHIFT),
 300     CMPL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  32u &lt;&lt; 1),
 301     CMPLI_OPCODE  = (10u &lt;&lt; OPCODE_SHIFT),
 302 
 303     ISEL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  15u &lt;&lt; 1),
 304 
 305     // Special purpose registers
 306     MTSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 467u &lt;&lt; 1),
 307     MFSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 339u &lt;&lt; 1),
 308 
 309     MTXER_OPCODE  = (MTSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 310     MFXER_OPCODE  = (MFSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 311 
 312     MTDSCR_OPCODE = (MTSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 313     MFDSCR_OPCODE = (MFSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 314 
 315     MTLR_OPCODE   = (MTSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 316     MFLR_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 317 
 318     MTCTR_OPCODE  = (MTSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 319     MFCTR_OPCODE  = (MFSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 320 
 321     // Attention: Higher and lower half are inserted in reversed order.
 322     MTTFHAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 323     MFTFHAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 324     MTTFIAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 325     MFTFIAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 326     MTTEXASR_OPCODE  = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 327     MFTEXASR_OPCODE  = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 328     MTTEXASRU_OPCODE = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 329     MFTEXASRU_OPCODE = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 330 
 331     MTVRSAVE_OPCODE  = (MTSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 332     MFVRSAVE_OPCODE  = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 333 
 334     MFTB_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 12 &lt;&lt; SPR_0_4_SHIFT),
 335 
 336     MTCRF_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 144u &lt;&lt; 1),
 337     MFCR_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 19u &lt;&lt; 1),
 338     MCRF_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 0u &lt;&lt; 1),
 339 
 340     // condition register logic instructions
 341     CRAND_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 257u &lt;&lt; 1),
 342     CRNAND_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 225u &lt;&lt; 1),
 343     CROR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 449u &lt;&lt; 1),
 344     CRXOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 193u &lt;&lt; 1),
 345     CRNOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT |  33u &lt;&lt; 1),
 346     CREQV_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 289u &lt;&lt; 1),
 347     CRANDC_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 129u &lt;&lt; 1),
 348     CRORC_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 417u &lt;&lt; 1),
 349 
 350     BCLR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 16u &lt;&lt; 1),
 351     BXX_OPCODE      = (18u &lt;&lt; OPCODE_SHIFT),
 352     BCXX_OPCODE     = (16u &lt;&lt; OPCODE_SHIFT),
 353 
 354     // CTR-related opcodes
 355     BCCTR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 528u &lt;&lt; 1),
 356 
 357     LWZ_OPCODE   = (32u &lt;&lt; OPCODE_SHIFT),
 358     LWZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  23u &lt;&lt; 1),
 359     LWZU_OPCODE  = (33u &lt;&lt; OPCODE_SHIFT),
 360     LWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  534 &lt;&lt; 1),
 361 
 362     LHA_OPCODE   = (42u &lt;&lt; OPCODE_SHIFT),
 363     LHAX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 343u &lt;&lt; 1),
 364     LHAU_OPCODE  = (43u &lt;&lt; OPCODE_SHIFT),
 365 
 366     LHZ_OPCODE   = (40u &lt;&lt; OPCODE_SHIFT),
 367     LHZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 279u &lt;&lt; 1),
 368     LHZU_OPCODE  = (41u &lt;&lt; OPCODE_SHIFT),
 369     LHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  790 &lt;&lt; 1),
 370 
 371     LBZ_OPCODE   = (34u &lt;&lt; OPCODE_SHIFT),
 372     LBZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  87u &lt;&lt; 1),
 373     LBZU_OPCODE  = (35u &lt;&lt; OPCODE_SHIFT),
 374 
 375     STW_OPCODE   = (36u &lt;&lt; OPCODE_SHIFT),
 376     STWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 151u &lt;&lt; 1),
 377     STWU_OPCODE  = (37u &lt;&lt; OPCODE_SHIFT),
 378     STWUX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 183u &lt;&lt; 1),
 379 
 380     STH_OPCODE   = (44u &lt;&lt; OPCODE_SHIFT),
 381     STHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 407u &lt;&lt; 1),
 382     STHU_OPCODE  = (45u &lt;&lt; OPCODE_SHIFT),
 383 
 384     STB_OPCODE   = (38u &lt;&lt; OPCODE_SHIFT),
 385     STBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 215u &lt;&lt; 1),
 386     STBU_OPCODE  = (39u &lt;&lt; OPCODE_SHIFT),
 387 
 388     EXTSB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 954u &lt;&lt; 1),
 389     EXTSH_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 922u &lt;&lt; 1),
 390     EXTSW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 986u &lt;&lt; 1),               // X-FORM
 391 
 392     // 32 bit opcode encodings
 393 
 394     LWA_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 395     LWAX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 341u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 396 
 397     CNTLZW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  26u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 398 
 399     // 64 bit opcode encodings
 400 
 401     LD_OPCODE     = (58u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 402     LDU_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 403     LDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; XO_21_30_SHIFT), // X-FORM
<a name="1" id="anc1"></a><span class="new"> 404     LDBRX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  532 &lt;&lt; 1),              // X-FORM</span>
 405 
 406     STD_OPCODE    = (62u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 407     STDU_OPCODE   = (62u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 408     STDUX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 181u &lt;&lt; 1),                  // X-FORM
 409     STDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 149u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 410 
 411     RLDICR_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 412     RLDICL_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 413     RLDIC_OPCODE  = (30u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 414     RLDIMI_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   3u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 415 
 416     SRADI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 413u &lt;&lt; XO_21_29_SHIFT), // XS-FORM
 417 
 418     SLD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  27u &lt;&lt; 1),              // X-FORM
 419     SRD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 539u &lt;&lt; 1),              // X-FORM
 420     SRAD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 794u &lt;&lt; 1),              // X-FORM
 421 
 422     MULLD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 233u &lt;&lt; 1),              // XO-FORM
 423     MULHD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  73u &lt;&lt; 1),              // XO-FORM
 424     MULHDU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |   9u &lt;&lt; 1),              // XO-FORM
 425     DIVD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 489u &lt;&lt; 1),              // XO-FORM
 426 
 427     CNTLZD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  58u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 428     NAND_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 476u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 429     NOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 124u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 430 
 431 
 432     // opcodes only used for floating arithmetic
 433     FADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 434     FADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 435     FCMPU_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  00u &lt;&lt; 1),
 436     FDIV_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 437     FDIVS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 438     FMR_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  72u &lt;&lt; 1),
 439     // These are special Power6 opcodes, reused for "lfdepx" and "stfdepx"
 440     // on Power7.  Do not use.
 441     // MFFGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 607u &lt;&lt; 1),
 442     // MFTGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 735u &lt;&lt; 1),
 443     CMPB_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  508  &lt;&lt; 1),
 444     POPCNTB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  122  &lt;&lt; 1),
 445     POPCNTW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  378  &lt;&lt; 1),
 446     POPCNTD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  506  &lt;&lt; 1),
 447     FABS_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  264u &lt;&lt; 1),
 448     FNABS_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  136u &lt;&lt; 1),
 449     FMUL_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 450     FMULS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 451     FNEG_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   40u &lt;&lt; 1),
 452     FSUB_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 453     FSUBS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 454 
 455     // PPC64-internal FPU conversion opcodes
 456     FCFID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 457     FCFIDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 458     FCTID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 459     FCTIDZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  815u &lt;&lt; 1),
 460     FCTIW_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   14u &lt;&lt; 1),
 461     FCTIWZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   15u &lt;&lt; 1),
 462     FRSP_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   12u &lt;&lt; 1),
 463 
 464     // Fused multiply-accumulate instructions.
 465     FMADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 466     FMADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 467     FMSUB_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 468     FMSUBS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 469     FNMADD_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 470     FNMADDS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 471     FNMSUB_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 472     FNMSUBS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 473 
 474     LFD_OPCODE     = (50u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 475     LFDU_OPCODE    = (51u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 476     LFDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  599u &lt;&lt; 1),
 477     LFS_OPCODE     = (48u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 478     LFSU_OPCODE    = (49u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 479     LFSX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  535u &lt;&lt; 1),
 480 
 481     STFD_OPCODE    = (54u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 482     STFDU_OPCODE   = (55u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 483     STFDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  727u &lt;&lt; 1),
 484     STFS_OPCODE    = (52u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 485     STFSU_OPCODE   = (53u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 486     STFSX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  663u &lt;&lt; 1),
 487 
 488     FSQRT_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 489     FSQRTS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 490 
 491     // Vector instruction support for &gt;= Power6
 492     // Vector Storage Access
 493     LVEBX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |    7u &lt;&lt; 1),
 494     LVEHX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   39u &lt;&lt; 1),
 495     LVEWX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   71u &lt;&lt; 1),
 496     LVX_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT |  103u &lt;&lt; 1),
 497     LVXL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  359u &lt;&lt; 1),
 498     STVEBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  135u &lt;&lt; 1),
 499     STVEHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  167u &lt;&lt; 1),
 500     STVEWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  199u &lt;&lt; 1),
 501     STVX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  231u &lt;&lt; 1),
 502     STVXL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  487u &lt;&lt; 1),
 503     LVSL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |    6u &lt;&lt; 1),
 504     LVSR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   38u &lt;&lt; 1),
 505 
 506     // Vector-Scalar (VSX) instruction support.
 507     LXVD2X_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  844u &lt;&lt; 1),
 508     STXVD2X_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  972u &lt;&lt; 1),
 509     MTVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  179u &lt;&lt; 1),
<a name="2" id="anc2"></a><span class="new"> 510     MTVSRWZ_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  243u &lt;&lt; 1),</span>
 511     MFVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   51u &lt;&lt; 1),
<a name="3" id="anc3"></a><span class="new"> 512     MFVSRWZ_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  115u &lt;&lt; 1),</span>
<span class="new"> 513     XXPERMDI_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |   10u &lt;&lt; 3),</span>
<span class="new"> 514     XXMRGHW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   18u &lt;&lt; 3),</span>
<span class="new"> 515     XXMRGLW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   50u &lt;&lt; 3),</span>
 516 
 517     // Vector Permute and Formatting
 518     VPKPX_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  782u     ),
 519     VPKSHSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  398u     ),
 520     VPKSWSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  462u     ),
 521     VPKSHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  270u     ),
 522     VPKSWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  334u     ),
 523     VPKUHUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   14u     ),
 524     VPKUWUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   78u     ),
 525     VPKUHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  142u     ),
 526     VPKUWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  206u     ),
 527     VUPKHPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  846u     ),
 528     VUPKHSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  526u     ),
 529     VUPKHSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  590u     ),
 530     VUPKLPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  974u     ),
 531     VUPKLSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  654u     ),
 532     VUPKLSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  718u     ),
 533 
 534     VMRGHB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   12u     ),
 535     VMRGHW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  140u     ),
 536     VMRGHH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   76u     ),
 537     VMRGLB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  268u     ),
 538     VMRGLW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  396u     ),
 539     VMRGLH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  332u     ),
 540 
 541     VSPLT_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  524u     ),
 542     VSPLTH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  588u     ),
 543     VSPLTW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  652u     ),
 544     VSPLTISB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  780u     ),
 545     VSPLTISH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  844u     ),
 546     VSPLTISW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  908u     ),
 547 
 548     VPERM_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |   43u     ),
 549     VSEL_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   42u     ),
 550 
 551     VSL_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  452u     ),
 552     VSLDOI_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   44u     ),
 553     VSLO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1036u     ),
 554     VSR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  708u     ),
 555     VSRO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1100u     ),
 556 
 557     // Vector Integer
 558     VADDCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  384u     ),
 559     VADDSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  832u     ),
 560     VADDSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  768u     ),
 561     VADDSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  896u     ),
 562     VADDUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    0u     ),
 563     VADDUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  128u     ),
 564     VADDUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   64u     ),
<a name="4" id="anc4"></a><span class="new"> 565     VADDUDM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  192u     ),</span>
 566     VADDUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  512u     ),
 567     VADDUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  640u     ),
 568     VADDUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  576u     ),
 569     VSUBCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1408u     ),
 570     VSUBSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1856u     ),
 571     VSUBSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1792u     ),
 572     VSUBSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1920u     ),
 573     VSUBUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1024u     ),
 574     VSUBUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1152u     ),
 575     VSUBUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1088u     ),
 576     VSUBUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1536u     ),
 577     VSUBUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1664u     ),
 578     VSUBUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1600u     ),
 579 
 580     VMULESB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  776u     ),
 581     VMULEUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  520u     ),
 582     VMULESH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  840u     ),
 583     VMULEUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  584u     ),
 584     VMULOSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  264u     ),
 585     VMULOUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    8u     ),
 586     VMULOSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  328u     ),
 587     VMULOUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   72u     ),
 588     VMHADDSHS_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   32u     ),
 589     VMHRADDSHS_OPCODE=(4u &lt;&lt; OPCODE_SHIFT |   33u     ),
 590     VMLADDUHM_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   34u     ),
 591     VMSUBUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   36u     ),
 592     VMSUMMBM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   37u     ),
 593     VMSUMSHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   40u     ),
 594     VMSUMSHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   41u     ),
 595     VMSUMUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   38u     ),
 596     VMSUMUHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   39u     ),
 597 
 598     VSUMSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1928u     ),
 599     VSUM2SWS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1672u     ),
 600     VSUM4SBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1800u     ),
 601     VSUM4UBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1544u     ),
 602     VSUM4SHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1608u     ),
 603 
 604     VAVGSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1282u     ),
 605     VAVGSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1410u     ),
 606     VAVGSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1346u     ),
 607     VAVGUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1026u     ),
 608     VAVGUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1154u     ),
 609     VAVGUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1090u     ),
 610 
 611     VMAXSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  258u     ),
 612     VMAXSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  386u     ),
 613     VMAXSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  322u     ),
 614     VMAXUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |    2u     ),
 615     VMAXUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  130u     ),
 616     VMAXUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   66u     ),
 617     VMINSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  770u     ),
 618     VMINSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  898u     ),
 619     VMINSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  834u     ),
 620     VMINUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  514u     ),
 621     VMINUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  642u     ),
 622     VMINUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  578u     ),
 623 
 624     VCMPEQUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |    6u     ),
 625     VCMPEQUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   70u     ),
 626     VCMPEQUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  134u     ),
 627     VCMPGTSH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  838u     ),
 628     VCMPGTSB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  774u     ),
 629     VCMPGTSW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  902u     ),
 630     VCMPGTUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  518u     ),
 631     VCMPGTUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  582u     ),
 632     VCMPGTUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  646u     ),
 633 
 634     VAND_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1028u     ),
 635     VANDC_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1092u     ),
 636     VNOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1284u     ),
 637     VOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1156u     ),
 638     VXOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1220u     ),
 639     VRLD_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  196u     ),
 640     VRLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |    4u     ),
 641     VRLW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  132u     ),
 642     VRLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   68u     ),
 643     VSLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  260u     ),
 644     VSKW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  388u     ),
 645     VSLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  324u     ),
 646     VSRB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  516u     ),
 647     VSRW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  644u     ),
 648     VSRH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  580u     ),
 649     VSRAB_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  772u     ),
 650     VSRAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  900u     ),
 651     VSRAH_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  836u     ),
 652 
 653     // Vector Floating-Point
 654     // not implemented yet
 655 
 656     // Vector Status and Control
 657     MTVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1604u     ),
 658     MFVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1540u     ),
 659 
 660     // AES (introduced with Power 8)
 661     VCIPHER_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1288u),
 662     VCIPHERLAST_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1289u),
 663     VNCIPHER_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1352u),
 664     VNCIPHERLAST_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1353u),
 665     VSBOX_OPCODE        = (4u  &lt;&lt; OPCODE_SHIFT | 1480u),
 666 
 667     // SHA (introduced with Power 8)
 668     VSHASIGMAD_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1730u),
 669     VSHASIGMAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1666u),
 670 
 671     // Vector Binary Polynomial Multiplication (introduced with Power 8)
 672     VPMSUMB_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1032u),
 673     VPMSUMD_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1224u),
 674     VPMSUMH_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1096u),
 675     VPMSUMW_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1160u),
 676 
 677     // Vector Permute and Xor (introduced with Power 8)
 678     VPERMXOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |   45u),
 679 
 680     // Transactional Memory instructions (introduced with Power 8)
 681     TBEGIN_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  654u &lt;&lt; 1),
 682     TEND_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |  686u &lt;&lt; 1),
 683     TABORT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  910u &lt;&lt; 1),
 684     TABORTWC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  782u &lt;&lt; 1),
 685     TABORTWCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 686     TABORTDC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 687     TABORTDCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  878u &lt;&lt; 1),
 688     TSR_OPCODE       = (31u &lt;&lt; OPCODE_SHIFT |  750u &lt;&lt; 1),
 689     TCHECK_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  718u &lt;&lt; 1),
 690 
 691     // Icache and dcache related instructions
 692     DCBA_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  758u &lt;&lt; 1),
 693     DCBZ_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 1014u &lt;&lt; 1),
 694     DCBST_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   54u &lt;&lt; 1),
 695     DCBF_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   86u &lt;&lt; 1),
 696 
 697     DCBT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  278u &lt;&lt; 1),
 698     DCBTST_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  246u &lt;&lt; 1),
 699     ICBI_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  982u &lt;&lt; 1),
 700 
 701     // Instruction synchronization
 702     ISYNC_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 703     // Memory barriers
 704     SYNC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  598u &lt;&lt; 1),
 705     EIEIO_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  854u &lt;&lt; 1),
 706 
 707     // Wait instructions for polling.
 708     WAIT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   62u &lt;&lt; 1),
 709 
 710     // Trap instructions
 711     TDI_OPCODE     = (2u  &lt;&lt; OPCODE_SHIFT),
 712     TWI_OPCODE     = (3u  &lt;&lt; OPCODE_SHIFT),
 713     TD_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |   68u &lt;&lt; 1),
 714     TW_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |    4u &lt;&lt; 1),
 715 
 716     // Atomics.
 717     LBARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   52u &lt;&lt; 1),
 718     LHARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  116u &lt;&lt; 1),
 719     LWARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 720     LDARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   84u &lt;&lt; 1),
 721     LQARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  276u &lt;&lt; 1),
 722     STBCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  694u &lt;&lt; 1),
 723     STHCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  726u &lt;&lt; 1),
 724     STWCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 725     STDCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  214u &lt;&lt; 1),
 726     STQCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  182u &lt;&lt; 1)
 727 
 728   };
 729 
 730   // Trap instructions TO bits
 731   enum trap_to_bits {
 732     // single bits
 733     traptoLessThanSigned      = 1 &lt;&lt; 4, // 0, left end
 734     traptoGreaterThanSigned   = 1 &lt;&lt; 3,
 735     traptoEqual               = 1 &lt;&lt; 2,
 736     traptoLessThanUnsigned    = 1 &lt;&lt; 1,
 737     traptoGreaterThanUnsigned = 1 &lt;&lt; 0, // 4, right end
 738 
 739     // compound ones
 740     traptoUnconditional       = (traptoLessThanSigned |
 741                                  traptoGreaterThanSigned |
 742                                  traptoEqual |
 743                                  traptoLessThanUnsigned |
 744                                  traptoGreaterThanUnsigned)
 745   };
 746 
 747   // Branch hints BH field
 748   enum branch_hint_bh {
 749     // bclr cases:
 750     bhintbhBCLRisReturn            = 0,
 751     bhintbhBCLRisNotReturnButSame  = 1,
 752     bhintbhBCLRisNotPredictable    = 3,
 753 
 754     // bcctr cases:
 755     bhintbhBCCTRisNotReturnButSame = 0,
 756     bhintbhBCCTRisNotPredictable   = 3
 757   };
 758 
 759   // Branch prediction hints AT field
 760   enum branch_hint_at {
 761     bhintatNoHint     = 0,  // at=00
 762     bhintatIsNotTaken = 2,  // at=10
 763     bhintatIsTaken    = 3   // at=11
 764   };
 765 
 766   // Branch prediction hints
 767   enum branch_hint_concept {
 768     // Use the same encoding as branch_hint_at to simply code.
 769     bhintNoHint       = bhintatNoHint,
 770     bhintIsNotTaken   = bhintatIsNotTaken,
 771     bhintIsTaken      = bhintatIsTaken
 772   };
 773 
 774   // Used in BO field of branch instruction.
 775   enum branch_condition {
 776     bcondCRbiIs0      =  4, // bo=001at
 777     bcondCRbiIs1      = 12, // bo=011at
 778     bcondAlways       = 20  // bo=10100
 779   };
 780 
 781   // Branch condition with combined prediction hints.
 782   enum branch_condition_with_hint {
 783     bcondCRbiIs0_bhintNoHint     = bcondCRbiIs0 | bhintatNoHint,
 784     bcondCRbiIs0_bhintIsNotTaken = bcondCRbiIs0 | bhintatIsNotTaken,
 785     bcondCRbiIs0_bhintIsTaken    = bcondCRbiIs0 | bhintatIsTaken,
 786     bcondCRbiIs1_bhintNoHint     = bcondCRbiIs1 | bhintatNoHint,
 787     bcondCRbiIs1_bhintIsNotTaken = bcondCRbiIs1 | bhintatIsNotTaken,
 788     bcondCRbiIs1_bhintIsTaken    = bcondCRbiIs1 | bhintatIsTaken,
 789   };
 790 
 791   // Elemental Memory Barriers (&gt;=Power 8)
 792   enum Elemental_Membar_mask_bits {
 793     StoreStore = 1 &lt;&lt; 0,
 794     StoreLoad  = 1 &lt;&lt; 1,
 795     LoadStore  = 1 &lt;&lt; 2,
 796     LoadLoad   = 1 &lt;&lt; 3
 797   };
 798 
 799   // Branch prediction hints.
 800   inline static int add_bhint_to_boint(const int bhint, const int boint) {
 801     switch (boint) {
 802       case bcondCRbiIs0:
 803       case bcondCRbiIs1:
 804         // branch_hint and branch_hint_at have same encodings
 805         assert(   (int)bhintNoHint     == (int)bhintatNoHint
 806                &amp;&amp; (int)bhintIsNotTaken == (int)bhintatIsNotTaken
 807                &amp;&amp; (int)bhintIsTaken    == (int)bhintatIsTaken,
 808                "wrong encodings");
 809         assert((bhint &amp; 0x03) == bhint, "wrong encodings");
 810         return (boint &amp; ~0x03) | bhint;
 811       case bcondAlways:
 812         // no branch_hint
 813         return boint;
 814       default:
 815         ShouldNotReachHere();
 816         return 0;
 817     }
 818   }
 819 
 820   // Extract bcond from boint.
 821   inline static int inv_boint_bcond(const int boint) {
 822     int r_bcond = boint &amp; ~0x03;
 823     assert(r_bcond == bcondCRbiIs0 ||
 824            r_bcond == bcondCRbiIs1 ||
 825            r_bcond == bcondAlways,
 826            "bad branch condition");
 827     return r_bcond;
 828   }
 829 
 830   // Extract bhint from boint.
 831   inline static int inv_boint_bhint(const int boint) {
 832     int r_bhint = boint &amp; 0x03;
 833     assert(r_bhint == bhintatNoHint ||
 834            r_bhint == bhintatIsNotTaken ||
 835            r_bhint == bhintatIsTaken,
 836            "bad branch hint");
 837     return r_bhint;
 838   }
 839 
 840   // Calculate opposite of given bcond.
 841   inline static int opposite_bcond(const int bcond) {
 842     switch (bcond) {
 843       case bcondCRbiIs0:
 844         return bcondCRbiIs1;
 845       case bcondCRbiIs1:
 846         return bcondCRbiIs0;
 847       default:
 848         ShouldNotReachHere();
 849         return 0;
 850     }
 851   }
 852 
 853   // Calculate opposite of given bhint.
 854   inline static int opposite_bhint(const int bhint) {
 855     switch (bhint) {
 856       case bhintatNoHint:
 857         return bhintatNoHint;
 858       case bhintatIsNotTaken:
 859         return bhintatIsTaken;
 860       case bhintatIsTaken:
 861         return bhintatIsNotTaken;
 862       default:
 863         ShouldNotReachHere();
 864         return 0;
 865     }
 866   }
 867 
 868   // PPC branch instructions
 869   enum ppcops {
 870     b_op    = 18,
 871     bc_op   = 16,
 872     bcr_op  = 19
 873   };
 874 
 875   enum Condition {
 876     negative         = 0,
 877     less             = 0,
 878     positive         = 1,
 879     greater          = 1,
 880     zero             = 2,
 881     equal            = 2,
 882     summary_overflow = 3,
 883   };
 884 
 885  public:
 886   // Helper functions for groups of instructions
 887 
 888   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 889 
 890   // Instruction must start at passed address.
 891   static int instr_len(unsigned char *instr) { return BytesPerInstWord; }
 892 
 893   // longest instructions
 894   static int instr_maxlen() { return BytesPerInstWord; }
 895 
 896   // Test if x is within signed immediate range for nbits.
 897   static bool is_simm(int x, unsigned int nbits) {
 898     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, "out of bounds");
 899     const int   min      = -(((int)1) &lt;&lt; nbits-1);
 900     const int   maxplus1 =  (((int)1) &lt;&lt; nbits-1);
 901     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 902   }
 903 
 904   static bool is_simm(jlong x, unsigned int nbits) {
 905     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, "out of bounds");
 906     const jlong min      = -(((jlong)1) &lt;&lt; nbits-1);
 907     const jlong maxplus1 =  (((jlong)1) &lt;&lt; nbits-1);
 908     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 909   }
 910 
 911   // Test if x is within unsigned immediate range for nbits.
 912   static bool is_uimm(int x, unsigned int nbits) {
 913     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, "out of bounds");
 914     const unsigned int maxplus1 = (((unsigned int)1) &lt;&lt; nbits);
 915     return (unsigned int)x &lt; maxplus1;
 916   }
 917 
 918   static bool is_uimm(jlong x, unsigned int nbits) {
 919     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, "out of bounds");
 920     const julong maxplus1 = (((julong)1) &lt;&lt; nbits);
 921     return (julong)x &lt; maxplus1;
 922   }
 923 
 924  protected:
 925   // helpers
 926 
 927   // X is supposed to fit in a field "nbits" wide
 928   // and be sign-extended. Check the range.
 929   static void assert_signed_range(intptr_t x, int nbits) {
 930     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 931            "value out of range");
 932   }
 933 
 934   static void assert_signed_word_disp_range(intptr_t x, int nbits) {
 935     assert((x &amp; 3) == 0, "not word aligned");
 936     assert_signed_range(x, nbits + 2);
 937   }
 938 
 939   static void assert_unsigned_const(int x, int nbits) {
 940     assert(juint(x) &lt; juint(1 &lt;&lt; nbits), "unsigned constant out of range");
 941   }
 942 
 943   static int fmask(juint hi_bit, juint lo_bit) {
 944     assert(hi_bit &gt;= lo_bit &amp;&amp; hi_bit &lt; 32, "bad bits");
 945     return (1 &lt;&lt; ( hi_bit-lo_bit + 1 )) - 1;
 946   }
 947 
 948   // inverse of u_field
 949   static int inv_u_field(int x, int hi_bit, int lo_bit) {
 950     juint r = juint(x) &gt;&gt; lo_bit;
 951     r &amp;= fmask(hi_bit, lo_bit);
 952     return int(r);
 953   }
 954 
 955   // signed version: extract from field and sign-extend
 956   static int inv_s_field_ppc(int x, int hi_bit, int lo_bit) {
 957     x = x &lt;&lt; (31-hi_bit);
 958     x = x &gt;&gt; (31-hi_bit+lo_bit);
 959     return x;
 960   }
 961 
 962   static int u_field(int x, int hi_bit, int lo_bit) {
 963     assert((x &amp; ~fmask(hi_bit, lo_bit)) == 0, "value out of range");
 964     int r = x &lt;&lt; lo_bit;
 965     assert(inv_u_field(r, hi_bit, lo_bit) == x, "just checking");
 966     return r;
 967   }
 968 
 969   // Same as u_field for signed values
 970   static int s_field(int x, int hi_bit, int lo_bit) {
 971     int nbits = hi_bit - lo_bit + 1;
 972     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 973       "value out of range");
 974     x &amp;= fmask(hi_bit, lo_bit);
 975     int r = x &lt;&lt; lo_bit;
 976     return r;
 977   }
 978 
 979   // inv_op for ppc instructions
 980   static int inv_op_ppc(int x) { return inv_u_field(x, 31, 26); }
 981 
 982   // Determine target address from li, bd field of branch instruction.
 983   static intptr_t inv_li_field(int x) {
 984     intptr_t r = inv_s_field_ppc(x, 25, 2);
 985     r = (r &lt;&lt; 2);
 986     return r;
 987   }
 988   static intptr_t inv_bd_field(int x, intptr_t pos) {
 989     intptr_t r = inv_s_field_ppc(x, 15, 2);
 990     r = (r &lt;&lt; 2) + pos;
 991     return r;
 992   }
 993 
 994   #define inv_opp_u_field(x, hi_bit, lo_bit) inv_u_field(x, 31-(lo_bit), 31-(hi_bit))
 995   #define inv_opp_s_field(x, hi_bit, lo_bit) inv_s_field_ppc(x, 31-(lo_bit), 31-(hi_bit))
 996   // Extract instruction fields from instruction words.
 997  public:
 998   static int inv_ra_field(int x)  { return inv_opp_u_field(x, 15, 11); }
 999   static int inv_rb_field(int x)  { return inv_opp_u_field(x, 20, 16); }
1000   static int inv_rt_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1001   static int inv_rta_field(int x) { return inv_opp_u_field(x, 15, 11); }
1002   static int inv_rs_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1003   // Ds uses opp_s_field(x, 31, 16), but lowest 2 bits must be 0.
1004   // Inv_ds_field uses range (x, 29, 16) but shifts by 2 to ensure that lowest bits are 0.
1005   static int inv_ds_field(int x)  { return inv_opp_s_field(x, 29, 16) &lt;&lt; 2; }
1006   static int inv_d1_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1007   static int inv_si_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1008   static int inv_to_field(int x)  { return inv_opp_u_field(x, 10, 6);  }
1009   static int inv_lk_field(int x)  { return inv_opp_u_field(x, 31, 31); }
1010   static int inv_bo_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1011   static int inv_bi_field(int x)  { return inv_opp_u_field(x, 15, 11); }
1012 
1013   #define opp_u_field(x, hi_bit, lo_bit) u_field(x, 31-(lo_bit), 31-(hi_bit))
1014   #define opp_s_field(x, hi_bit, lo_bit) s_field(x, 31-(lo_bit), 31-(hi_bit))
1015 
1016   // instruction fields
1017   static int aa(       int         x)  { return  opp_u_field(x,             30, 30); }
1018   static int ba(       int         x)  { return  opp_u_field(x,             15, 11); }
1019   static int bb(       int         x)  { return  opp_u_field(x,             20, 16); }
1020   static int bc(       int         x)  { return  opp_u_field(x,             25, 21); }
1021   static int bd(       int         x)  { return  opp_s_field(x,             29, 16); }
1022   static int bf( ConditionRegister cr) { return  bf(cr-&gt;encoding()); }
1023   static int bf(       int         x)  { return  opp_u_field(x,              8,  6); }
1024   static int bfa(ConditionRegister cr) { return  bfa(cr-&gt;encoding()); }
1025   static int bfa(      int         x)  { return  opp_u_field(x,             13, 11); }
1026   static int bh(       int         x)  { return  opp_u_field(x,             20, 19); }
1027   static int bi(       int         x)  { return  opp_u_field(x,             15, 11); }
1028   static int bi0(ConditionRegister cr, Condition c) { return (cr-&gt;encoding() &lt;&lt; 2) | c; }
1029   static int bo(       int         x)  { return  opp_u_field(x,             10,  6); }
1030   static int bt(       int         x)  { return  opp_u_field(x,             10,  6); }
1031   static int d1(       int         x)  { return  opp_s_field(x,             31, 16); }
1032   static int ds(       int         x)  { assert((x &amp; 0x3) == 0, "unaligned offset"); return opp_s_field(x, 31, 16); }
1033   static int eh(       int         x)  { return  opp_u_field(x,             31, 31); }
1034   static int flm(      int         x)  { return  opp_u_field(x,             14,  7); }
1035   static int fra(    FloatRegister r)  { return  fra(r-&gt;encoding());}
1036   static int frb(    FloatRegister r)  { return  frb(r-&gt;encoding());}
1037   static int frc(    FloatRegister r)  { return  frc(r-&gt;encoding());}
1038   static int frs(    FloatRegister r)  { return  frs(r-&gt;encoding());}
1039   static int frt(    FloatRegister r)  { return  frt(r-&gt;encoding());}
1040   static int fra(      int         x)  { return  opp_u_field(x,             15, 11); }
1041   static int frb(      int         x)  { return  opp_u_field(x,             20, 16); }
1042   static int frc(      int         x)  { return  opp_u_field(x,             25, 21); }
1043   static int frs(      int         x)  { return  opp_u_field(x,             10,  6); }
1044   static int frt(      int         x)  { return  opp_u_field(x,             10,  6); }
1045   static int fxm(      int         x)  { return  opp_u_field(x,             19, 12); }
1046   static int l10(      int         x)  { return  opp_u_field(x,             10, 10); }
1047   static int l15(      int         x)  { return  opp_u_field(x,             15, 15); }
1048   static int l910(     int         x)  { return  opp_u_field(x,             10,  9); }
1049   static int e1215(    int         x)  { return  opp_u_field(x,             15, 12); }
1050   static int lev(      int         x)  { return  opp_u_field(x,             26, 20); }
1051   static int li(       int         x)  { return  opp_s_field(x,             29,  6); }
1052   static int lk(       int         x)  { return  opp_u_field(x,             31, 31); }
1053   static int mb2125(   int         x)  { return  opp_u_field(x,             25, 21); }
1054   static int me2630(   int         x)  { return  opp_u_field(x,             30, 26); }
1055   static int mb2126(   int         x)  { return  opp_u_field(((x &amp; 0x1f) &lt;&lt; 1) | ((x &amp; 0x20) &gt;&gt; 5), 26, 21); }
1056   static int me2126(   int         x)  { return  mb2126(x); }
1057   static int nb(       int         x)  { return  opp_u_field(x,             20, 16); }
1058   //static int opcd(   int         x)  { return  opp_u_field(x,              5,  0); } // is contained in our opcodes
1059   static int oe(       int         x)  { return  opp_u_field(x,             21, 21); }
1060   static int ra(       Register    r)  { return  ra(r-&gt;encoding()); }
1061   static int ra(       int         x)  { return  opp_u_field(x,             15, 11); }
1062   static int rb(       Register    r)  { return  rb(r-&gt;encoding()); }
1063   static int rb(       int         x)  { return  opp_u_field(x,             20, 16); }
1064   static int rc(       int         x)  { return  opp_u_field(x,             31, 31); }
1065   static int rs(       Register    r)  { return  rs(r-&gt;encoding()); }
1066   static int rs(       int         x)  { return  opp_u_field(x,             10,  6); }
1067   // we don't want to use R0 in memory accesses, because it has value `0' then
1068   static int ra0mem(   Register    r)  { assert(r != R0, "cannot use register R0 in memory access"); return ra(r); }
1069   static int ra0mem(   int         x)  { assert(x != 0,  "cannot use register 0 in memory access");  return ra(x); }
1070 
1071   // register r is target
1072   static int rt(       Register    r)  { return rs(r); }
1073   static int rt(       int         x)  { return rs(x); }
1074   static int rta(      Register    r)  { return ra(r); }
1075   static int rta0mem(  Register    r)  { rta(r); return ra0mem(r); }
1076 
1077   static int sh1620(   int         x)  { return  opp_u_field(x,             20, 16); }
1078   static int sh30(     int         x)  { return  opp_u_field(x,             30, 30); }
1079   static int sh162030( int         x)  { return  sh1620(x &amp; 0x1f) | sh30((x &amp; 0x20) &gt;&gt; 5); }
1080   static int si(       int         x)  { return  opp_s_field(x,             31, 16); }
1081   static int spr(      int         x)  { return  opp_u_field(x,             20, 11); }
1082   static int sr(       int         x)  { return  opp_u_field(x,             15, 12); }
1083   static int tbr(      int         x)  { return  opp_u_field(x,             20, 11); }
1084   static int th(       int         x)  { return  opp_u_field(x,             10,  7); }
1085   static int thct(     int         x)  { assert((x&amp;8) == 0, "must be valid cache specification");  return th(x); }
1086   static int thds(     int         x)  { assert((x&amp;8) == 8, "must be valid stream specification"); return th(x); }
1087   static int to(       int         x)  { return  opp_u_field(x,             10,  6); }
1088   static int u(        int         x)  { return  opp_u_field(x,             19, 16); }
1089   static int ui(       int         x)  { return  opp_u_field(x,             31, 16); }
1090 
1091   // Support vector instructions for &gt;= Power6.
1092   static int vra(      int         x)  { return  opp_u_field(x,             15, 11); }
1093   static int vrb(      int         x)  { return  opp_u_field(x,             20, 16); }
1094   static int vrc(      int         x)  { return  opp_u_field(x,             25, 21); }
1095   static int vrs(      int         x)  { return  opp_u_field(x,             10,  6); }
1096   static int vrt(      int         x)  { return  opp_u_field(x,             10,  6); }
1097 
1098   static int vra(   VectorRegister r)  { return  vra(r-&gt;encoding());}
1099   static int vrb(   VectorRegister r)  { return  vrb(r-&gt;encoding());}
1100   static int vrc(   VectorRegister r)  { return  vrc(r-&gt;encoding());}
1101   static int vrs(   VectorRegister r)  { return  vrs(r-&gt;encoding());}
1102   static int vrt(   VectorRegister r)  { return  vrt(r-&gt;encoding());}
1103 
<a name="5" id="anc5"></a><span class="new">1104   // Only used on SHA sigma instructions (VX-form)</span>
<span class="new">1105   static int vst(      int         x)  { return  opp_u_field(x,             16, 16); }</span>
<span class="new">1106   static int vsix(     int         x)  { return  opp_u_field(x,             20, 17); }</span>
<span class="new">1107 </span>
1108   // Support Vector-Scalar (VSX) instructions.
<a name="6" id="anc6"></a><span class="changed">1109   static int vsra(      int         x)  { return  opp_u_field(x &amp; 0x1F,     15, 11) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 29, 29); }</span>
<span class="changed">1110   static int vsrb(      int         x)  { return  opp_u_field(x &amp; 0x1F,     20, 16) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 30, 30); }</span>
<span class="changed">1111   static int vsrs(      int         x)  { return  opp_u_field(x &amp; 0x1F,     10,  6) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 31, 31); }</span>
<span class="changed">1112   static int vsrt(      int         x)  { return  vsrs(x); }</span>
<span class="changed">1113   static int vsdm(      int         x)  { return  opp_u_field(x,            23, 22); }</span>
1114 
1115   static int vsra(   VectorSRegister r)  { return  vsra(r-&gt;encoding());}
1116   static int vsrb(   VectorSRegister r)  { return  vsrb(r-&gt;encoding());}
<a name="7" id="anc7"></a>
1117   static int vsrs(   VectorSRegister r)  { return  vsrs(r-&gt;encoding());}
1118   static int vsrt(   VectorSRegister r)  { return  vsrt(r-&gt;encoding());}
1119 
1120   static int vsplt_uim( int        x)  { return  opp_u_field(x,             15, 12); } // for vsplt* instructions
1121   static int vsplti_sim(int        x)  { return  opp_u_field(x,             15, 11); } // for vsplti* instructions
1122   static int vsldoi_shb(int        x)  { return  opp_u_field(x,             25, 22); } // for vsldoi instruction
1123   static int vcmp_rc(   int        x)  { return  opp_u_field(x,             21, 21); } // for vcmp* instructions
1124 
1125   //static int xo1(     int        x)  { return  opp_u_field(x,             29, 21); }// is contained in our opcodes
1126   //static int xo2(     int        x)  { return  opp_u_field(x,             30, 21); }// is contained in our opcodes
1127   //static int xo3(     int        x)  { return  opp_u_field(x,             30, 22); }// is contained in our opcodes
1128   //static int xo4(     int        x)  { return  opp_u_field(x,             30, 26); }// is contained in our opcodes
1129   //static int xo5(     int        x)  { return  opp_u_field(x,             29, 27); }// is contained in our opcodes
1130   //static int xo6(     int        x)  { return  opp_u_field(x,             30, 27); }// is contained in our opcodes
1131   //static int xo7(     int        x)  { return  opp_u_field(x,             31, 30); }// is contained in our opcodes
1132 
1133  protected:
1134   // Compute relative address for branch.
1135   static intptr_t disp(intptr_t x, intptr_t off) {
1136     int xx = x - off;
1137     xx = xx &gt;&gt; 2;
1138     return xx;
1139   }
1140 
1141  public:
1142   // signed immediate, in low bits, nbits long
1143   static int simm(int x, int nbits) {
1144     assert_signed_range(x, nbits);
1145     return x &amp; ((1 &lt;&lt; nbits) - 1);
1146   }
1147 
1148   // unsigned immediate, in low bits, nbits long
1149   static int uimm(int x, int nbits) {
1150     assert_unsigned_const(x, nbits);
1151     return x &amp; ((1 &lt;&lt; nbits) - 1);
1152   }
1153 
1154   static void set_imm(int* instr, short s) {
1155     // imm is always in the lower 16 bits of the instruction,
1156     // so this is endian-neutral. Same for the get_imm below.
1157     uint32_t w = *(uint32_t *)instr;
1158     *instr = (int)((w &amp; ~0x0000FFFF) | (s &amp; 0x0000FFFF));
1159   }
1160 
1161   static int get_imm(address a, int instruction_number) {
1162     return (short)((int *)a)[instruction_number];
1163   }
1164 
1165   static inline int hi16_signed(  int x) { return (int)(int16_t)(x &gt;&gt; 16); }
1166   static inline int lo16_unsigned(int x) { return x &amp; 0xffff; }
1167 
1168  protected:
1169 
1170   // Extract the top 32 bits in a 64 bit word.
1171   static int32_t hi32(int64_t x) {
1172     int32_t r = int32_t((uint64_t)x &gt;&gt; 32);
1173     return r;
1174   }
1175 
1176  public:
1177 
1178   static inline unsigned int align_addr(unsigned int addr, unsigned int a) {
1179     return ((addr + (a - 1)) &amp; ~(a - 1));
1180   }
1181 
1182   static inline bool is_aligned(unsigned int addr, unsigned int a) {
1183     return (0 == addr % a);
1184   }
1185 
1186   void flush() {
1187     AbstractAssembler::flush();
1188   }
1189 
1190   inline void emit_int32(int);  // shadows AbstractAssembler::emit_int32
1191   inline void emit_data(int);
1192   inline void emit_data(int, RelocationHolder const&amp;);
1193   inline void emit_data(int, relocInfo::relocType rtype);
1194 
1195   // Emit an address.
1196   inline address emit_addr(const address addr = NULL);
1197 
1198 #if !defined(ABI_ELFv2)
1199   // Emit a function descriptor with the specified entry point, TOC,
1200   // and ENV. If the entry point is NULL, the descriptor will point
1201   // just past the descriptor.
1202   // Use values from friend functions as defaults.
1203   inline address emit_fd(address entry = NULL,
1204                          address toc = (address) FunctionDescriptor::friend_toc,
1205                          address env = (address) FunctionDescriptor::friend_env);
1206 #endif
1207 
1208   /////////////////////////////////////////////////////////////////////////////////////
1209   // PPC instructions
1210   /////////////////////////////////////////////////////////////////////////////////////
1211 
1212   // Memory instructions use r0 as hard coded 0, e.g. to simulate loading
1213   // immediates. The normal instruction encoders enforce that r0 is not
1214   // passed to them. Use either extended mnemonics encoders or the special ra0
1215   // versions.
1216 
1217   // Issue an illegal instruction.
1218   inline void illtrap();
1219   static inline bool is_illtrap(int x);
1220 
1221   // PPC 1, section 3.3.8, Fixed-Point Arithmetic Instructions
1222   inline void addi( Register d, Register a, int si16);
1223   inline void addis(Register d, Register a, int si16);
1224  private:
1225   inline void addi_r0ok( Register d, Register a, int si16);
1226   inline void addis_r0ok(Register d, Register a, int si16);
1227  public:
1228   inline void addic_( Register d, Register a, int si16);
1229   inline void subfic( Register d, Register a, int si16);
1230   inline void add(    Register d, Register a, Register b);
1231   inline void add_(   Register d, Register a, Register b);
1232   inline void subf(   Register d, Register a, Register b);  // d = b - a    "Sub_from", as in ppc spec.
1233   inline void sub(    Register d, Register a, Register b);  // d = a - b    Swap operands of subf for readability.
1234   inline void subf_(  Register d, Register a, Register b);
1235   inline void addc(   Register d, Register a, Register b);
1236   inline void addc_(  Register d, Register a, Register b);
1237   inline void subfc(  Register d, Register a, Register b);
1238   inline void subfc_( Register d, Register a, Register b);
1239   inline void adde(   Register d, Register a, Register b);
1240   inline void adde_(  Register d, Register a, Register b);
1241   inline void subfe(  Register d, Register a, Register b);
1242   inline void subfe_( Register d, Register a, Register b);
1243   inline void addme(  Register d, Register a);
1244   inline void addme_( Register d, Register a);
1245   inline void subfme( Register d, Register a);
1246   inline void subfme_(Register d, Register a);
1247   inline void addze(  Register d, Register a);
1248   inline void addze_( Register d, Register a);
1249   inline void subfze( Register d, Register a);
1250   inline void subfze_(Register d, Register a);
1251   inline void neg(    Register d, Register a);
1252   inline void neg_(   Register d, Register a);
1253   inline void mulli(  Register d, Register a, int si16);
1254   inline void mulld(  Register d, Register a, Register b);
1255   inline void mulld_( Register d, Register a, Register b);
1256   inline void mullw(  Register d, Register a, Register b);
1257   inline void mullw_( Register d, Register a, Register b);
1258   inline void mulhw(  Register d, Register a, Register b);
1259   inline void mulhw_( Register d, Register a, Register b);
1260   inline void mulhwu( Register d, Register a, Register b);
1261   inline void mulhwu_(Register d, Register a, Register b);
1262   inline void mulhd(  Register d, Register a, Register b);
1263   inline void mulhd_( Register d, Register a, Register b);
1264   inline void mulhdu( Register d, Register a, Register b);
1265   inline void mulhdu_(Register d, Register a, Register b);
1266   inline void divd(   Register d, Register a, Register b);
1267   inline void divd_(  Register d, Register a, Register b);
1268   inline void divw(   Register d, Register a, Register b);
1269   inline void divw_(  Register d, Register a, Register b);
1270 
1271   // Fixed-Point Arithmetic Instructions with Overflow detection
1272   inline void addo(    Register d, Register a, Register b);
1273   inline void addo_(   Register d, Register a, Register b);
1274   inline void subfo(   Register d, Register a, Register b);
1275   inline void subfo_(  Register d, Register a, Register b);
1276   inline void addco(   Register d, Register a, Register b);
1277   inline void addco_(  Register d, Register a, Register b);
1278   inline void subfco(  Register d, Register a, Register b);
1279   inline void subfco_( Register d, Register a, Register b);
1280   inline void addeo(   Register d, Register a, Register b);
1281   inline void addeo_(  Register d, Register a, Register b);
1282   inline void subfeo(  Register d, Register a, Register b);
1283   inline void subfeo_( Register d, Register a, Register b);
1284   inline void addmeo(  Register d, Register a);
1285   inline void addmeo_( Register d, Register a);
1286   inline void subfmeo( Register d, Register a);
1287   inline void subfmeo_(Register d, Register a);
1288   inline void addzeo(  Register d, Register a);
1289   inline void addzeo_( Register d, Register a);
1290   inline void subfzeo( Register d, Register a);
1291   inline void subfzeo_(Register d, Register a);
1292   inline void nego(    Register d, Register a);
1293   inline void nego_(   Register d, Register a);
1294   inline void mulldo(  Register d, Register a, Register b);
1295   inline void mulldo_( Register d, Register a, Register b);
1296   inline void mullwo(  Register d, Register a, Register b);
1297   inline void mullwo_( Register d, Register a, Register b);
1298   inline void divdo(   Register d, Register a, Register b);
1299   inline void divdo_(  Register d, Register a, Register b);
1300   inline void divwo(   Register d, Register a, Register b);
1301   inline void divwo_(  Register d, Register a, Register b);
1302 
1303   // extended mnemonics
1304   inline void li(   Register d, int si16);
1305   inline void lis(  Register d, int si16);
1306   inline void addir(Register d, int si16, Register a);
1307 
1308   static bool is_addi(int x) {
1309      return ADDI_OPCODE == (x &amp; ADDI_OPCODE_MASK);
1310   }
1311   static bool is_addis(int x) {
1312      return ADDIS_OPCODE == (x &amp; ADDIS_OPCODE_MASK);
1313   }
1314   static bool is_bxx(int x) {
1315      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK);
1316   }
1317   static bool is_b(int x) {
1318      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 0;
1319   }
1320   static bool is_bl(int x) {
1321      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 1;
1322   }
1323   static bool is_bcxx(int x) {
1324      return BCXX_OPCODE == (x &amp; BCXX_OPCODE_MASK);
1325   }
1326   static bool is_bxx_or_bcxx(int x) {
1327      return is_bxx(x) || is_bcxx(x);
1328   }
1329   static bool is_bctrl(int x) {
1330      return x == 0x4e800421;
1331   }
1332   static bool is_bctr(int x) {
1333      return x == 0x4e800420;
1334   }
1335   static bool is_bclr(int x) {
1336      return BCLR_OPCODE == (x &amp; XL_FORM_OPCODE_MASK);
1337   }
1338   static bool is_li(int x) {
1339      return is_addi(x) &amp;&amp; inv_ra_field(x)==0;
1340   }
1341   static bool is_lis(int x) {
1342      return is_addis(x) &amp;&amp; inv_ra_field(x)==0;
1343   }
1344   static bool is_mtctr(int x) {
1345      return MTCTR_OPCODE == (x &amp; MTCTR_OPCODE_MASK);
1346   }
1347   static bool is_ld(int x) {
1348      return LD_OPCODE == (x &amp; LD_OPCODE_MASK);
1349   }
1350   static bool is_std(int x) {
1351      return STD_OPCODE == (x &amp; STD_OPCODE_MASK);
1352   }
1353   static bool is_stdu(int x) {
1354      return STDU_OPCODE == (x &amp; STDU_OPCODE_MASK);
1355   }
1356   static bool is_stdx(int x) {
1357      return STDX_OPCODE == (x &amp; STDX_OPCODE_MASK);
1358   }
1359   static bool is_stdux(int x) {
1360      return STDUX_OPCODE == (x &amp; STDUX_OPCODE_MASK);
1361   }
1362   static bool is_stwx(int x) {
1363      return STWX_OPCODE == (x &amp; STWX_OPCODE_MASK);
1364   }
1365   static bool is_stwux(int x) {
1366      return STWUX_OPCODE == (x &amp; STWUX_OPCODE_MASK);
1367   }
1368   static bool is_stw(int x) {
1369      return STW_OPCODE == (x &amp; STW_OPCODE_MASK);
1370   }
1371   static bool is_stwu(int x) {
1372      return STWU_OPCODE == (x &amp; STWU_OPCODE_MASK);
1373   }
1374   static bool is_ori(int x) {
1375      return ORI_OPCODE == (x &amp; ORI_OPCODE_MASK);
1376   };
1377   static bool is_oris(int x) {
1378      return ORIS_OPCODE == (x &amp; ORIS_OPCODE_MASK);
1379   };
1380   static bool is_rldicr(int x) {
1381      return (RLDICR_OPCODE == (x &amp; RLDICR_OPCODE_MASK));
1382   };
1383   static bool is_nop(int x) {
1384     return x == 0x60000000;
1385   }
1386   // endgroup opcode for Power6
1387   static bool is_endgroup(int x) {
1388     return is_ori(x) &amp;&amp; inv_ra_field(x) == 1 &amp;&amp; inv_rs_field(x) == 1 &amp;&amp; inv_d1_field(x) == 0;
1389   }
1390 
1391 
1392  private:
1393   // PPC 1, section 3.3.9, Fixed-Point Compare Instructions
1394   inline void cmpi( ConditionRegister bf, int l, Register a, int si16);
1395   inline void cmp(  ConditionRegister bf, int l, Register a, Register b);
1396   inline void cmpli(ConditionRegister bf, int l, Register a, int ui16);
1397   inline void cmpl( ConditionRegister bf, int l, Register a, Register b);
1398 
1399  public:
1400   // extended mnemonics of Compare Instructions
1401   inline void cmpwi( ConditionRegister crx, Register a, int si16);
1402   inline void cmpdi( ConditionRegister crx, Register a, int si16);
1403   inline void cmpw(  ConditionRegister crx, Register a, Register b);
1404   inline void cmpd(  ConditionRegister crx, Register a, Register b);
1405   inline void cmplwi(ConditionRegister crx, Register a, int ui16);
1406   inline void cmpldi(ConditionRegister crx, Register a, int ui16);
1407   inline void cmplw( ConditionRegister crx, Register a, Register b);
1408   inline void cmpld( ConditionRegister crx, Register a, Register b);
1409 
1410   inline void isel(   Register d, Register a, Register b, int bc);
1411   // Convenient version which takes: Condition register, Condition code and invert flag. Omit b to keep old value.
1412   inline void isel(   Register d, ConditionRegister cr, Condition cc, bool inv, Register a, Register b = noreg);
1413   // Set d = 0 if (cr.cc) equals 1, otherwise b.
1414   inline void isel_0( Register d, ConditionRegister cr, Condition cc, Register b = noreg);
1415 
1416   // PPC 1, section 3.3.11, Fixed-Point Logical Instructions
1417          void andi(   Register a, Register s, long ui16);   // optimized version
1418   inline void andi_(  Register a, Register s, int ui16);
1419   inline void andis_( Register a, Register s, int ui16);
1420   inline void ori(    Register a, Register s, int ui16);
1421   inline void oris(   Register a, Register s, int ui16);
1422   inline void xori(   Register a, Register s, int ui16);
1423   inline void xoris(  Register a, Register s, int ui16);
1424   inline void andr(   Register a, Register s, Register b);  // suffixed by 'r' as 'and' is C++ keyword
1425   inline void and_(   Register a, Register s, Register b);
1426   // Turn or0(rx,rx,rx) into a nop and avoid that we accidently emit a
1427   // SMT-priority change instruction (see SMT instructions below).
1428   inline void or_unchecked(Register a, Register s, Register b);
1429   inline void orr(    Register a, Register s, Register b);  // suffixed by 'r' as 'or' is C++ keyword
1430   inline void or_(    Register a, Register s, Register b);
1431   inline void xorr(   Register a, Register s, Register b);  // suffixed by 'r' as 'xor' is C++ keyword
1432   inline void xor_(   Register a, Register s, Register b);
1433   inline void nand(   Register a, Register s, Register b);
1434   inline void nand_(  Register a, Register s, Register b);
1435   inline void nor(    Register a, Register s, Register b);
1436   inline void nor_(   Register a, Register s, Register b);
1437   inline void andc(   Register a, Register s, Register b);
1438   inline void andc_(  Register a, Register s, Register b);
1439   inline void orc(    Register a, Register s, Register b);
1440   inline void orc_(   Register a, Register s, Register b);
1441   inline void extsb(  Register a, Register s);
1442   inline void extsb_( Register a, Register s);
1443   inline void extsh(  Register a, Register s);
1444   inline void extsh_( Register a, Register s);
1445   inline void extsw(  Register a, Register s);
1446   inline void extsw_( Register a, Register s);
1447 
1448   // extended mnemonics
1449   inline void nop();
1450   // NOP for FP and BR units (different versions to allow them to be in one group)
1451   inline void fpnop0();
1452   inline void fpnop1();
1453   inline void brnop0();
1454   inline void brnop1();
1455   inline void brnop2();
1456 
1457   inline void mr(      Register d, Register s);
1458   inline void ori_opt( Register d, int ui16);
1459   inline void oris_opt(Register d, int ui16);
1460 
1461   // endgroup opcode for Power6
1462   inline void endgroup();
1463 
1464   // count instructions
1465   inline void cntlzw(  Register a, Register s);
1466   inline void cntlzw_( Register a, Register s);
1467   inline void cntlzd(  Register a, Register s);
1468   inline void cntlzd_( Register a, Register s);
1469 
1470   // PPC 1, section 3.3.12, Fixed-Point Rotate and Shift Instructions
1471   inline void sld(     Register a, Register s, Register b);
1472   inline void sld_(    Register a, Register s, Register b);
1473   inline void slw(     Register a, Register s, Register b);
1474   inline void slw_(    Register a, Register s, Register b);
1475   inline void srd(     Register a, Register s, Register b);
1476   inline void srd_(    Register a, Register s, Register b);
1477   inline void srw(     Register a, Register s, Register b);
1478   inline void srw_(    Register a, Register s, Register b);
1479   inline void srad(    Register a, Register s, Register b);
1480   inline void srad_(   Register a, Register s, Register b);
1481   inline void sraw(    Register a, Register s, Register b);
1482   inline void sraw_(   Register a, Register s, Register b);
1483   inline void sradi(   Register a, Register s, int sh6);
1484   inline void sradi_(  Register a, Register s, int sh6);
1485   inline void srawi(   Register a, Register s, int sh5);
1486   inline void srawi_(  Register a, Register s, int sh5);
1487 
1488   // extended mnemonics for Shift Instructions
1489   inline void sldi(    Register a, Register s, int sh6);
1490   inline void sldi_(   Register a, Register s, int sh6);
1491   inline void slwi(    Register a, Register s, int sh5);
1492   inline void slwi_(   Register a, Register s, int sh5);
1493   inline void srdi(    Register a, Register s, int sh6);
1494   inline void srdi_(   Register a, Register s, int sh6);
1495   inline void srwi(    Register a, Register s, int sh5);
1496   inline void srwi_(   Register a, Register s, int sh5);
1497 
1498   inline void clrrdi(  Register a, Register s, int ui6);
1499   inline void clrrdi_( Register a, Register s, int ui6);
1500   inline void clrldi(  Register a, Register s, int ui6);
1501   inline void clrldi_( Register a, Register s, int ui6);
1502   inline void clrlsldi(Register a, Register s, int clrl6, int shl6);
1503   inline void clrlsldi_(Register a, Register s, int clrl6, int shl6);
1504   inline void extrdi(  Register a, Register s, int n, int b);
1505   // testbit with condition register
1506   inline void testbitdi(ConditionRegister cr, Register a, Register s, int ui6);
1507 
1508   // rotate instructions
1509   inline void rotldi(  Register a, Register s, int n);
1510   inline void rotrdi(  Register a, Register s, int n);
1511   inline void rotlwi(  Register a, Register s, int n);
1512   inline void rotrwi(  Register a, Register s, int n);
1513 
1514   // Rotate Instructions
1515   inline void rldic(   Register a, Register s, int sh6, int mb6);
1516   inline void rldic_(  Register a, Register s, int sh6, int mb6);
1517   inline void rldicr(  Register a, Register s, int sh6, int mb6);
1518   inline void rldicr_( Register a, Register s, int sh6, int mb6);
1519   inline void rldicl(  Register a, Register s, int sh6, int mb6);
1520   inline void rldicl_( Register a, Register s, int sh6, int mb6);
1521   inline void rlwinm(  Register a, Register s, int sh5, int mb5, int me5);
1522   inline void rlwinm_( Register a, Register s, int sh5, int mb5, int me5);
1523   inline void rldimi(  Register a, Register s, int sh6, int mb6);
1524   inline void rldimi_( Register a, Register s, int sh6, int mb6);
1525   inline void rlwimi(  Register a, Register s, int sh5, int mb5, int me5);
1526   inline void insrdi(  Register a, Register s, int n,   int b);
1527   inline void insrwi(  Register a, Register s, int n,   int b);
1528 
1529   // PPC 1, section 3.3.2 Fixed-Point Load Instructions
1530   // 4 bytes
1531   inline void lwzx( Register d, Register s1, Register s2);
1532   inline void lwz(  Register d, int si16,    Register s1);
1533   inline void lwzu( Register d, int si16,    Register s1);
1534 
1535   // 4 bytes
1536   inline void lwax( Register d, Register s1, Register s2);
1537   inline void lwa(  Register d, int si16,    Register s1);
1538 
1539   // 4 bytes reversed
1540   inline void lwbrx( Register d, Register s1, Register s2);
1541 
1542   // 2 bytes
1543   inline void lhzx( Register d, Register s1, Register s2);
1544   inline void lhz(  Register d, int si16,    Register s1);
1545   inline void lhzu( Register d, int si16,    Register s1);
1546 
1547   // 2 bytes reversed
1548   inline void lhbrx( Register d, Register s1, Register s2);
1549 
1550   // 2 bytes
1551   inline void lhax( Register d, Register s1, Register s2);
1552   inline void lha(  Register d, int si16,    Register s1);
1553   inline void lhau( Register d, int si16,    Register s1);
1554 
1555   // 1 byte
1556   inline void lbzx( Register d, Register s1, Register s2);
1557   inline void lbz(  Register d, int si16,    Register s1);
1558   inline void lbzu( Register d, int si16,    Register s1);
1559 
1560   // 8 bytes
1561   inline void ldx(  Register d, Register s1, Register s2);
1562   inline void ld(   Register d, int si16,    Register s1);
1563   inline void ldu(  Register d, int si16,    Register s1);
1564 
<a name="8" id="anc8"></a><span class="new">1565   // 8 bytes reversed</span>
<span class="new">1566   inline void ldbrx( Register d, Register s1, Register s2);</span>
<span class="new">1567 </span>
1568   // For convenience. Load pointer into d from b+s1.
1569   inline void ld_ptr(Register d, int b, Register s1);
1570   DEBUG_ONLY(inline void ld_ptr(Register d, ByteSize b, Register s1);)
1571 
1572   //  PPC 1, section 3.3.3 Fixed-Point Store Instructions
1573   inline void stwx( Register d, Register s1, Register s2);
1574   inline void stw(  Register d, int si16,    Register s1);
1575   inline void stwu( Register d, int si16,    Register s1);
1576 
1577   inline void sthx( Register d, Register s1, Register s2);
1578   inline void sth(  Register d, int si16,    Register s1);
1579   inline void sthu( Register d, int si16,    Register s1);
1580 
1581   inline void stbx( Register d, Register s1, Register s2);
1582   inline void stb(  Register d, int si16,    Register s1);
1583   inline void stbu( Register d, int si16,    Register s1);
1584 
1585   inline void stdx( Register d, Register s1, Register s2);
1586   inline void std(  Register d, int si16,    Register s1);
1587   inline void stdu( Register d, int si16,    Register s1);
1588   inline void stdux(Register s, Register a,  Register b);
1589 
1590   inline void st_ptr(Register d, int si16,    Register s1);
1591   DEBUG_ONLY(inline void st_ptr(Register d, ByteSize b, Register s1);)
1592 
1593   // PPC 1, section 3.3.13 Move To/From System Register Instructions
1594   inline void mtlr( Register s1);
1595   inline void mflr( Register d);
1596   inline void mtctr(Register s1);
1597   inline void mfctr(Register d);
1598   inline void mtcrf(int fxm, Register s);
1599   inline void mfcr( Register d);
1600   inline void mcrf( ConditionRegister crd, ConditionRegister cra);
1601   inline void mtcr( Register s);
1602 
1603   // Special purpose registers
1604   // Exception Register
1605   inline void mtxer(Register s1);
1606   inline void mfxer(Register d);
1607   // Vector Register Save Register
1608   inline void mtvrsave(Register s1);
1609   inline void mfvrsave(Register d);
1610   // Timebase
1611   inline void mftb(Register d);
1612   // Introduced with Power 8:
1613   // Data Stream Control Register
1614   inline void mtdscr(Register s1);
1615   inline void mfdscr(Register d );
1616   // Transactional Memory Registers
1617   inline void mftfhar(Register d);
1618   inline void mftfiar(Register d);
1619   inline void mftexasr(Register d);
1620   inline void mftexasru(Register d);
1621 
1622   // TEXASR bit description
1623   enum transaction_failure_reason {
1624     // Upper half (TEXASRU):
1625     tm_failure_persistent =  7, // The failure is likely to recur on each execution.
1626     tm_disallowed         =  8, // The instruction is not permitted.
1627     tm_nesting_of         =  9, // The maximum transaction level was exceeded.
1628     tm_footprint_of       = 10, // The tracking limit for transactional storage accesses was exceeded.
1629     tm_self_induced_cf    = 11, // A self-induced conflict occurred in Suspended state.
1630     tm_non_trans_cf       = 12, // A conflict occurred with a non-transactional access by another processor.
1631     tm_trans_cf           = 13, // A conflict occurred with another transaction.
1632     tm_translation_cf     = 14, // A conflict occurred with a TLB invalidation.
1633     tm_inst_fetch_cf      = 16, // An instruction fetch was performed from a block that was previously written transactionally.
1634     tm_tabort             = 31, // Termination was caused by the execution of an abort instruction.
1635     // Lower half:
1636     tm_suspended          = 32, // Failure was recorded in Suspended state.
1637     tm_failure_summary    = 36, // Failure has been detected and recorded.
1638     tm_tfiar_exact        = 37, // Value in the TFIAR is exact.
1639     tm_rot                = 38, // Rollback-only transaction.
1640   };
1641 
1642   // PPC 1, section 2.4.1 Branch Instructions
1643   inline void b(  address a, relocInfo::relocType rt = relocInfo::none);
1644   inline void b(  Label&amp; L);
1645   inline void bl( address a, relocInfo::relocType rt = relocInfo::none);
1646   inline void bl( Label&amp; L);
1647   inline void bc( int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1648   inline void bc( int boint, int biint, Label&amp; L);
1649   inline void bcl(int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1650   inline void bcl(int boint, int biint, Label&amp; L);
1651 
1652   inline void bclr(  int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1653   inline void bclrl( int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1654   inline void bcctr( int boint, int biint, int bhint = bhintbhBCCTRisNotReturnButSame,
1655                          relocInfo::relocType rt = relocInfo::none);
1656   inline void bcctrl(int boint, int biint, int bhint = bhintbhBCLRisReturn,
1657                          relocInfo::relocType rt = relocInfo::none);
1658 
1659   // helper function for b, bcxx
1660   inline bool is_within_range_of_b(address a, address pc);
1661   inline bool is_within_range_of_bcxx(address a, address pc);
1662 
1663   // get the destination of a bxx branch (b, bl, ba, bla)
1664   static inline address  bxx_destination(address baddr);
1665   static inline address  bxx_destination(int instr, address pc);
1666   static inline intptr_t bxx_destination_offset(int instr, intptr_t bxx_pos);
1667 
1668   // extended mnemonics for branch instructions
1669   inline void blt(ConditionRegister crx, Label&amp; L);
1670   inline void bgt(ConditionRegister crx, Label&amp; L);
1671   inline void beq(ConditionRegister crx, Label&amp; L);
1672   inline void bso(ConditionRegister crx, Label&amp; L);
1673   inline void bge(ConditionRegister crx, Label&amp; L);
1674   inline void ble(ConditionRegister crx, Label&amp; L);
1675   inline void bne(ConditionRegister crx, Label&amp; L);
1676   inline void bns(ConditionRegister crx, Label&amp; L);
1677 
1678   // Branch instructions with static prediction hints.
1679   inline void blt_predict_taken(    ConditionRegister crx, Label&amp; L);
1680   inline void bgt_predict_taken(    ConditionRegister crx, Label&amp; L);
1681   inline void beq_predict_taken(    ConditionRegister crx, Label&amp; L);
1682   inline void bso_predict_taken(    ConditionRegister crx, Label&amp; L);
1683   inline void bge_predict_taken(    ConditionRegister crx, Label&amp; L);
1684   inline void ble_predict_taken(    ConditionRegister crx, Label&amp; L);
1685   inline void bne_predict_taken(    ConditionRegister crx, Label&amp; L);
1686   inline void bns_predict_taken(    ConditionRegister crx, Label&amp; L);
1687   inline void blt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1688   inline void bgt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1689   inline void beq_predict_not_taken(ConditionRegister crx, Label&amp; L);
1690   inline void bso_predict_not_taken(ConditionRegister crx, Label&amp; L);
1691   inline void bge_predict_not_taken(ConditionRegister crx, Label&amp; L);
1692   inline void ble_predict_not_taken(ConditionRegister crx, Label&amp; L);
1693   inline void bne_predict_not_taken(ConditionRegister crx, Label&amp; L);
1694   inline void bns_predict_not_taken(ConditionRegister crx, Label&amp; L);
1695 
1696   // for use in conjunction with testbitdi:
1697   inline void btrue( ConditionRegister crx, Label&amp; L);
1698   inline void bfalse(ConditionRegister crx, Label&amp; L);
1699 
1700   inline void bltl(ConditionRegister crx, Label&amp; L);
1701   inline void bgtl(ConditionRegister crx, Label&amp; L);
1702   inline void beql(ConditionRegister crx, Label&amp; L);
1703   inline void bsol(ConditionRegister crx, Label&amp; L);
1704   inline void bgel(ConditionRegister crx, Label&amp; L);
1705   inline void blel(ConditionRegister crx, Label&amp; L);
1706   inline void bnel(ConditionRegister crx, Label&amp; L);
1707   inline void bnsl(ConditionRegister crx, Label&amp; L);
1708 
1709   // extended mnemonics for Branch Instructions via LR
1710   // We use `blr' for returns.
1711   inline void blr(relocInfo::relocType rt = relocInfo::none);
1712 
1713   // extended mnemonics for Branch Instructions with CTR
1714   // bdnz means `decrement CTR and jump to L if CTR is not zero'
1715   inline void bdnz(Label&amp; L);
1716   // Decrement and branch if result is zero.
1717   inline void bdz(Label&amp; L);
1718   // we use `bctr[l]' for jumps/calls in function descriptor glue
1719   // code, e.g. calls to runtime functions
1720   inline void bctr( relocInfo::relocType rt = relocInfo::none);
1721   inline void bctrl(relocInfo::relocType rt = relocInfo::none);
1722   // conditional jumps/branches via CTR
1723   inline void beqctr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1724   inline void beqctrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1725   inline void bnectr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1726   inline void bnectrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1727 
1728   // condition register logic instructions
1729   // NOTE: There's a preferred form: d and s2 should point into the same condition register.
1730   inline void crand( int d, int s1, int s2);
1731   inline void crnand(int d, int s1, int s2);
1732   inline void cror(  int d, int s1, int s2);
1733   inline void crxor( int d, int s1, int s2);
1734   inline void crnor( int d, int s1, int s2);
1735   inline void creqv( int d, int s1, int s2);
1736   inline void crandc(int d, int s1, int s2);
1737   inline void crorc( int d, int s1, int s2);
1738 
1739   // More convenient version.
1740   int condition_register_bit(ConditionRegister cr, Condition c) {
1741     return 4 * (int)(intptr_t)cr + c;
1742   }
1743   void crand( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1744   void crnand(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1745   void cror(  ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1746   void crxor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1747   void crnor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1748   void creqv( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1749   void crandc(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1750   void crorc( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1751 
1752   // icache and dcache related instructions
1753   inline void icbi(  Register s1, Register s2);
1754   //inline void dcba(Register s1, Register s2); // Instruction for embedded processor only.
1755   inline void dcbz(  Register s1, Register s2);
1756   inline void dcbst( Register s1, Register s2);
1757   inline void dcbf(  Register s1, Register s2);
1758 
1759   enum ct_cache_specification {
1760     ct_primary_cache   = 0,
1761     ct_secondary_cache = 2
1762   };
1763   // dcache read hint
1764   inline void dcbt(    Register s1, Register s2);
1765   inline void dcbtct(  Register s1, Register s2, int ct);
1766   inline void dcbtds(  Register s1, Register s2, int ds);
1767   // dcache write hint
1768   inline void dcbtst(  Register s1, Register s2);
1769   inline void dcbtstct(Register s1, Register s2, int ct);
1770 
1771   //  machine barrier instructions:
1772   //
1773   //  - sync    two-way memory barrier, aka fence
1774   //  - lwsync  orders  Store|Store,
1775   //                     Load|Store,
1776   //                     Load|Load,
1777   //            but not Store|Load
1778   //  - eieio   orders memory accesses for device memory (only)
1779   //  - isync   invalidates speculatively executed instructions
1780   //            From the Power ISA 2.06 documentation:
1781   //             "[...] an isync instruction prevents the execution of
1782   //            instructions following the isync until instructions
1783   //            preceding the isync have completed, [...]"
1784   //            From IBM's AIX assembler reference:
1785   //             "The isync [...] instructions causes the processor to
1786   //            refetch any instructions that might have been fetched
1787   //            prior to the isync instruction. The instruction isync
1788   //            causes the processor to wait for all previous instructions
1789   //            to complete. Then any instructions already fetched are
1790   //            discarded and instruction processing continues in the
1791   //            environment established by the previous instructions."
1792   //
1793   //  semantic barrier instructions:
1794   //  (as defined in orderAccess.hpp)
1795   //
1796   //  - release  orders Store|Store,       (maps to lwsync)
1797   //                     Load|Store
1798   //  - acquire  orders  Load|Store,       (maps to lwsync)
1799   //                     Load|Load
1800   //  - fence    orders Store|Store,       (maps to sync)
1801   //                     Load|Store,
1802   //                     Load|Load,
1803   //                    Store|Load
1804   //
1805  private:
1806   inline void sync(int l);
1807  public:
1808   inline void sync();
1809   inline void lwsync();
1810   inline void ptesync();
1811   inline void eieio();
1812   inline void isync();
1813   inline void elemental_membar(int e); // Elemental Memory Barriers (&gt;=Power 8)
1814 
1815   // Wait instructions for polling. Attention: May result in SIGILL.
1816   inline void wait();
1817   inline void waitrsv(); // &gt;=Power7
1818 
1819   // atomics
1820   inline void lbarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1821   inline void lharx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1822   inline void lwarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1823   inline void ldarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1824   inline void lqarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1825   inline bool lxarx_hint_exclusive_access();
1826   inline void lbarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1827   inline void lharx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1828   inline void lwarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1829   inline void ldarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1830   inline void lqarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1831   inline void stbcx_( Register s, Register a, Register b);
1832   inline void sthcx_( Register s, Register a, Register b);
1833   inline void stwcx_( Register s, Register a, Register b);
1834   inline void stdcx_( Register s, Register a, Register b);
1835   inline void stqcx_( Register s, Register a, Register b);
1836 
1837   // Instructions for adjusting thread priority for simultaneous
1838   // multithreading (SMT) on Power5.
1839  private:
1840   inline void smt_prio_very_low();
1841   inline void smt_prio_medium_high();
1842   inline void smt_prio_high();
1843 
1844  public:
1845   inline void smt_prio_low();
1846   inline void smt_prio_medium_low();
1847   inline void smt_prio_medium();
1848   // &gt;= Power7
1849   inline void smt_yield();
1850   inline void smt_mdoio();
1851   inline void smt_mdoom();
1852   // &gt;= Power8
1853   inline void smt_miso();
1854 
1855   // trap instructions
1856   inline void twi_0(Register a); // for load with acquire semantics use load+twi_0+isync (trap can't occur)
1857   // NOT FOR DIRECT USE!!
1858  protected:
1859   inline void tdi_unchecked(int tobits, Register a, int si16);
1860   inline void twi_unchecked(int tobits, Register a, int si16);
1861   inline void tdi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1862   inline void twi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1863   inline void td(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1864   inline void tw(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1865 
1866   static bool is_tdi(int x, int tobits, int ra, int si16) {
1867      return (TDI_OPCODE == (x &amp; TDI_OPCODE_MASK))
1868          &amp;&amp; (tobits == inv_to_field(x))
1869          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1870          &amp;&amp; (si16 == inv_si_field(x));
1871   }
1872 
1873   static bool is_twi(int x, int tobits, int ra, int si16) {
1874      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1875          &amp;&amp; (tobits == inv_to_field(x))
1876          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1877          &amp;&amp; (si16 == inv_si_field(x));
1878   }
1879 
1880   static bool is_twi(int x, int tobits, int ra) {
1881      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1882          &amp;&amp; (tobits == inv_to_field(x))
1883          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x));
1884   }
1885 
1886   static bool is_td(int x, int tobits, int ra, int rb) {
1887      return (TD_OPCODE == (x &amp; TD_OPCODE_MASK))
1888          &amp;&amp; (tobits == inv_to_field(x))
1889          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1890          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1891   }
1892 
1893   static bool is_tw(int x, int tobits, int ra, int rb) {
1894      return (TW_OPCODE == (x &amp; TW_OPCODE_MASK))
1895          &amp;&amp; (tobits == inv_to_field(x))
1896          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1897          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1898   }
1899 
1900  public:
1901   // PPC floating point instructions
1902   // PPC 1, section 4.6.2 Floating-Point Load Instructions
1903   inline void lfs(  FloatRegister d, int si16,   Register a);
1904   inline void lfsu( FloatRegister d, int si16,   Register a);
1905   inline void lfsx( FloatRegister d, Register a, Register b);
1906   inline void lfd(  FloatRegister d, int si16,   Register a);
1907   inline void lfdu( FloatRegister d, int si16,   Register a);
1908   inline void lfdx( FloatRegister d, Register a, Register b);
1909 
1910   // PPC 1, section 4.6.3 Floating-Point Store Instructions
1911   inline void stfs(  FloatRegister s, int si16,   Register a);
1912   inline void stfsu( FloatRegister s, int si16,   Register a);
1913   inline void stfsx( FloatRegister s, Register a, Register b);
1914   inline void stfd(  FloatRegister s, int si16,   Register a);
1915   inline void stfdu( FloatRegister s, int si16,   Register a);
1916   inline void stfdx( FloatRegister s, Register a, Register b);
1917 
1918   // PPC 1, section 4.6.4 Floating-Point Move Instructions
1919   inline void fmr(  FloatRegister d, FloatRegister b);
1920   inline void fmr_( FloatRegister d, FloatRegister b);
1921 
1922   //  inline void mffgpr( FloatRegister d, Register b);
1923   //  inline void mftgpr( Register d, FloatRegister b);
1924   inline void cmpb(   Register a, Register s, Register b);
1925   inline void popcntb(Register a, Register s);
1926   inline void popcntw(Register a, Register s);
1927   inline void popcntd(Register a, Register s);
1928 
1929   inline void fneg(  FloatRegister d, FloatRegister b);
1930   inline void fneg_( FloatRegister d, FloatRegister b);
1931   inline void fabs(  FloatRegister d, FloatRegister b);
1932   inline void fabs_( FloatRegister d, FloatRegister b);
1933   inline void fnabs( FloatRegister d, FloatRegister b);
1934   inline void fnabs_(FloatRegister d, FloatRegister b);
1935 
1936   // PPC 1, section 4.6.5.1 Floating-Point Elementary Arithmetic Instructions
1937   inline void fadd(  FloatRegister d, FloatRegister a, FloatRegister b);
1938   inline void fadd_( FloatRegister d, FloatRegister a, FloatRegister b);
1939   inline void fadds( FloatRegister d, FloatRegister a, FloatRegister b);
1940   inline void fadds_(FloatRegister d, FloatRegister a, FloatRegister b);
1941   inline void fsub(  FloatRegister d, FloatRegister a, FloatRegister b);
1942   inline void fsub_( FloatRegister d, FloatRegister a, FloatRegister b);
1943   inline void fsubs( FloatRegister d, FloatRegister a, FloatRegister b);
1944   inline void fsubs_(FloatRegister d, FloatRegister a, FloatRegister b);
1945   inline void fmul(  FloatRegister d, FloatRegister a, FloatRegister c);
1946   inline void fmul_( FloatRegister d, FloatRegister a, FloatRegister c);
1947   inline void fmuls( FloatRegister d, FloatRegister a, FloatRegister c);
1948   inline void fmuls_(FloatRegister d, FloatRegister a, FloatRegister c);
1949   inline void fdiv(  FloatRegister d, FloatRegister a, FloatRegister b);
1950   inline void fdiv_( FloatRegister d, FloatRegister a, FloatRegister b);
1951   inline void fdivs( FloatRegister d, FloatRegister a, FloatRegister b);
1952   inline void fdivs_(FloatRegister d, FloatRegister a, FloatRegister b);
1953 
1954   // Fused multiply-accumulate instructions.
1955   // WARNING: Use only when rounding between the 2 parts is not desired.
1956   // Some floating point tck tests will fail if used incorrectly.
1957   inline void fmadd(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1958   inline void fmadd_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1959   inline void fmadds(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1960   inline void fmadds_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1961   inline void fmsub(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1962   inline void fmsub_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1963   inline void fmsubs(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1964   inline void fmsubs_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1965   inline void fnmadd(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1966   inline void fnmadd_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1967   inline void fnmadds( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1968   inline void fnmadds_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1969   inline void fnmsub(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1970   inline void fnmsub_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1971   inline void fnmsubs( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1972   inline void fnmsubs_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1973 
1974   // PPC 1, section 4.6.6 Floating-Point Rounding and Conversion Instructions
1975   inline void frsp(  FloatRegister d, FloatRegister b);
1976   inline void fctid( FloatRegister d, FloatRegister b);
1977   inline void fctidz(FloatRegister d, FloatRegister b);
1978   inline void fctiw( FloatRegister d, FloatRegister b);
1979   inline void fctiwz(FloatRegister d, FloatRegister b);
1980   inline void fcfid( FloatRegister d, FloatRegister b);
1981   inline void fcfids(FloatRegister d, FloatRegister b);
1982 
1983   // PPC 1, section 4.6.7 Floating-Point Compare Instructions
1984   inline void fcmpu( ConditionRegister crx, FloatRegister a, FloatRegister b);
1985 
1986   inline void fsqrt( FloatRegister d, FloatRegister b);
1987   inline void fsqrts(FloatRegister d, FloatRegister b);
1988 
1989   // Vector instructions for &gt;= Power6.
1990   inline void lvebx(    VectorRegister d, Register s1, Register s2);
1991   inline void lvehx(    VectorRegister d, Register s1, Register s2);
1992   inline void lvewx(    VectorRegister d, Register s1, Register s2);
1993   inline void lvx(      VectorRegister d, Register s1, Register s2);
1994   inline void lvxl(     VectorRegister d, Register s1, Register s2);
1995   inline void stvebx(   VectorRegister d, Register s1, Register s2);
1996   inline void stvehx(   VectorRegister d, Register s1, Register s2);
1997   inline void stvewx(   VectorRegister d, Register s1, Register s2);
1998   inline void stvx(     VectorRegister d, Register s1, Register s2);
1999   inline void stvxl(    VectorRegister d, Register s1, Register s2);
2000   inline void lvsl(     VectorRegister d, Register s1, Register s2);
2001   inline void lvsr(     VectorRegister d, Register s1, Register s2);
2002   inline void vpkpx(    VectorRegister d, VectorRegister a, VectorRegister b);
2003   inline void vpkshss(  VectorRegister d, VectorRegister a, VectorRegister b);
2004   inline void vpkswss(  VectorRegister d, VectorRegister a, VectorRegister b);
2005   inline void vpkshus(  VectorRegister d, VectorRegister a, VectorRegister b);
2006   inline void vpkswus(  VectorRegister d, VectorRegister a, VectorRegister b);
2007   inline void vpkuhum(  VectorRegister d, VectorRegister a, VectorRegister b);
2008   inline void vpkuwum(  VectorRegister d, VectorRegister a, VectorRegister b);
2009   inline void vpkuhus(  VectorRegister d, VectorRegister a, VectorRegister b);
2010   inline void vpkuwus(  VectorRegister d, VectorRegister a, VectorRegister b);
2011   inline void vupkhpx(  VectorRegister d, VectorRegister b);
2012   inline void vupkhsb(  VectorRegister d, VectorRegister b);
2013   inline void vupkhsh(  VectorRegister d, VectorRegister b);
2014   inline void vupklpx(  VectorRegister d, VectorRegister b);
2015   inline void vupklsb(  VectorRegister d, VectorRegister b);
2016   inline void vupklsh(  VectorRegister d, VectorRegister b);
2017   inline void vmrghb(   VectorRegister d, VectorRegister a, VectorRegister b);
2018   inline void vmrghw(   VectorRegister d, VectorRegister a, VectorRegister b);
2019   inline void vmrghh(   VectorRegister d, VectorRegister a, VectorRegister b);
2020   inline void vmrglb(   VectorRegister d, VectorRegister a, VectorRegister b);
2021   inline void vmrglw(   VectorRegister d, VectorRegister a, VectorRegister b);
2022   inline void vmrglh(   VectorRegister d, VectorRegister a, VectorRegister b);
2023   inline void vsplt(    VectorRegister d, int ui4,          VectorRegister b);
2024   inline void vsplth(   VectorRegister d, int ui3,          VectorRegister b);
2025   inline void vspltw(   VectorRegister d, int ui2,          VectorRegister b);
2026   inline void vspltisb( VectorRegister d, int si5);
2027   inline void vspltish( VectorRegister d, int si5);
2028   inline void vspltisw( VectorRegister d, int si5);
2029   inline void vperm(    VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2030   inline void vsel(     VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2031   inline void vsl(      VectorRegister d, VectorRegister a, VectorRegister b);
2032   inline void vsldoi(   VectorRegister d, VectorRegister a, VectorRegister b, int si4);
2033   inline void vslo(     VectorRegister d, VectorRegister a, VectorRegister b);
2034   inline void vsr(      VectorRegister d, VectorRegister a, VectorRegister b);
2035   inline void vsro(     VectorRegister d, VectorRegister a, VectorRegister b);
2036   inline void vaddcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2037   inline void vaddshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2038   inline void vaddsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2039   inline void vaddsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2040   inline void vaddubm(  VectorRegister d, VectorRegister a, VectorRegister b);
2041   inline void vadduwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2042   inline void vadduhm(  VectorRegister d, VectorRegister a, VectorRegister b);
<a name="9" id="anc9"></a><span class="new">2043   inline void vaddudm(  VectorRegister d, VectorRegister a, VectorRegister b);</span>
2044   inline void vaddubs(  VectorRegister d, VectorRegister a, VectorRegister b);
2045   inline void vadduws(  VectorRegister d, VectorRegister a, VectorRegister b);
2046   inline void vadduhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2047   inline void vsubcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2048   inline void vsubshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2049   inline void vsubsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2050   inline void vsubsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2051   inline void vsububm(  VectorRegister d, VectorRegister a, VectorRegister b);
2052   inline void vsubuwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2053   inline void vsubuhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2054   inline void vsububs(  VectorRegister d, VectorRegister a, VectorRegister b);
2055   inline void vsubuws(  VectorRegister d, VectorRegister a, VectorRegister b);
2056   inline void vsubuhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2057   inline void vmulesb(  VectorRegister d, VectorRegister a, VectorRegister b);
2058   inline void vmuleub(  VectorRegister d, VectorRegister a, VectorRegister b);
2059   inline void vmulesh(  VectorRegister d, VectorRegister a, VectorRegister b);
2060   inline void vmuleuh(  VectorRegister d, VectorRegister a, VectorRegister b);
2061   inline void vmulosb(  VectorRegister d, VectorRegister a, VectorRegister b);
2062   inline void vmuloub(  VectorRegister d, VectorRegister a, VectorRegister b);
2063   inline void vmulosh(  VectorRegister d, VectorRegister a, VectorRegister b);
2064   inline void vmulouh(  VectorRegister d, VectorRegister a, VectorRegister b);
2065   inline void vmhaddshs(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2066   inline void vmhraddshs(VectorRegister d,VectorRegister a, VectorRegister b, VectorRegister c);
2067   inline void vmladduhm(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2068   inline void vmsubuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2069   inline void vmsummbm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2070   inline void vmsumshm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2071   inline void vmsumshs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2072   inline void vmsumuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2073   inline void vmsumuhs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2074   inline void vsumsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2075   inline void vsum2sws( VectorRegister d, VectorRegister a, VectorRegister b);
2076   inline void vsum4sbs( VectorRegister d, VectorRegister a, VectorRegister b);
2077   inline void vsum4ubs( VectorRegister d, VectorRegister a, VectorRegister b);
2078   inline void vsum4shs( VectorRegister d, VectorRegister a, VectorRegister b);
2079   inline void vavgsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2080   inline void vavgsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2081   inline void vavgsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2082   inline void vavgub(   VectorRegister d, VectorRegister a, VectorRegister b);
2083   inline void vavguw(   VectorRegister d, VectorRegister a, VectorRegister b);
2084   inline void vavguh(   VectorRegister d, VectorRegister a, VectorRegister b);
2085   inline void vmaxsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2086   inline void vmaxsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2087   inline void vmaxsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2088   inline void vmaxub(   VectorRegister d, VectorRegister a, VectorRegister b);
2089   inline void vmaxuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2090   inline void vmaxuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2091   inline void vminsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2092   inline void vminsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2093   inline void vminsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2094   inline void vminub(   VectorRegister d, VectorRegister a, VectorRegister b);
2095   inline void vminuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2096   inline void vminuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2097   inline void vcmpequb( VectorRegister d, VectorRegister a, VectorRegister b);
2098   inline void vcmpequh( VectorRegister d, VectorRegister a, VectorRegister b);
2099   inline void vcmpequw( VectorRegister d, VectorRegister a, VectorRegister b);
2100   inline void vcmpgtsh( VectorRegister d, VectorRegister a, VectorRegister b);
2101   inline void vcmpgtsb( VectorRegister d, VectorRegister a, VectorRegister b);
2102   inline void vcmpgtsw( VectorRegister d, VectorRegister a, VectorRegister b);
2103   inline void vcmpgtub( VectorRegister d, VectorRegister a, VectorRegister b);
2104   inline void vcmpgtuh( VectorRegister d, VectorRegister a, VectorRegister b);
2105   inline void vcmpgtuw( VectorRegister d, VectorRegister a, VectorRegister b);
2106   inline void vcmpequb_(VectorRegister d, VectorRegister a, VectorRegister b);
2107   inline void vcmpequh_(VectorRegister d, VectorRegister a, VectorRegister b);
2108   inline void vcmpequw_(VectorRegister d, VectorRegister a, VectorRegister b);
2109   inline void vcmpgtsh_(VectorRegister d, VectorRegister a, VectorRegister b);
2110   inline void vcmpgtsb_(VectorRegister d, VectorRegister a, VectorRegister b);
2111   inline void vcmpgtsw_(VectorRegister d, VectorRegister a, VectorRegister b);
2112   inline void vcmpgtub_(VectorRegister d, VectorRegister a, VectorRegister b);
2113   inline void vcmpgtuh_(VectorRegister d, VectorRegister a, VectorRegister b);
2114   inline void vcmpgtuw_(VectorRegister d, VectorRegister a, VectorRegister b);
2115   inline void vand(     VectorRegister d, VectorRegister a, VectorRegister b);
2116   inline void vandc(    VectorRegister d, VectorRegister a, VectorRegister b);
2117   inline void vnor(     VectorRegister d, VectorRegister a, VectorRegister b);
2118   inline void vor(      VectorRegister d, VectorRegister a, VectorRegister b);
<a name="10" id="anc10"></a><span class="new">2119   inline void vmr(      VectorRegister d, VectorRegister a);</span>
2120   inline void vxor(     VectorRegister d, VectorRegister a, VectorRegister b);
2121   inline void vrld(     VectorRegister d, VectorRegister a, VectorRegister b);
2122   inline void vrlb(     VectorRegister d, VectorRegister a, VectorRegister b);
2123   inline void vrlw(     VectorRegister d, VectorRegister a, VectorRegister b);
2124   inline void vrlh(     VectorRegister d, VectorRegister a, VectorRegister b);
2125   inline void vslb(     VectorRegister d, VectorRegister a, VectorRegister b);
2126   inline void vskw(     VectorRegister d, VectorRegister a, VectorRegister b);
2127   inline void vslh(     VectorRegister d, VectorRegister a, VectorRegister b);
2128   inline void vsrb(     VectorRegister d, VectorRegister a, VectorRegister b);
2129   inline void vsrw(     VectorRegister d, VectorRegister a, VectorRegister b);
2130   inline void vsrh(     VectorRegister d, VectorRegister a, VectorRegister b);
2131   inline void vsrab(    VectorRegister d, VectorRegister a, VectorRegister b);
2132   inline void vsraw(    VectorRegister d, VectorRegister a, VectorRegister b);
2133   inline void vsrah(    VectorRegister d, VectorRegister a, VectorRegister b);
2134   // Vector Floating-Point not implemented yet
2135   inline void mtvscr(   VectorRegister b);
2136   inline void mfvscr(   VectorRegister d);
2137 
2138   // Vector-Scalar (VSX) instructions.
2139   inline void lxvd2x(   VectorSRegister d, Register a);
2140   inline void lxvd2x(   VectorSRegister d, Register a, Register b);
2141   inline void stxvd2x(  VectorSRegister d, Register a);
2142   inline void stxvd2x(  VectorSRegister d, Register a, Register b);
<a name="11" id="anc11"></a><span class="new">2143   inline void mtvrwz(   VectorRegister  d, Register a);</span>
<span class="new">2144   inline void mfvrwz(   Register        a, VectorRegister d);</span>
2145   inline void mtvrd(    VectorRegister  d, Register a);
2146   inline void mfvrd(    Register        a, VectorRegister d);
<a name="12" id="anc12"></a><span class="new">2147   inline void xxpermdi( VectorSRegister d, VectorSRegister a, VectorSRegister b, int dm);</span>
<span class="new">2148   inline void xxmrghw(  VectorSRegister d, VectorSRegister a, VectorSRegister b);</span>
<span class="new">2149   inline void xxmrglw(  VectorSRegister d, VectorSRegister a, VectorSRegister b);</span>
<span class="new">2150 </span>
<span class="new">2151   // VSX Extended Mnemonics</span>
<span class="new">2152   inline void xxspltd(  VectorSRegister d, VectorSRegister a, int x);</span>
<span class="new">2153   inline void xxmrghd(  VectorSRegister d, VectorSRegister a, VectorSRegister b);</span>
<span class="new">2154   inline void xxmrgld(  VectorSRegister d, VectorSRegister a, VectorSRegister b);</span>
<span class="new">2155   inline void xxswapd(  VectorSRegister d, VectorSRegister a);</span>
2156 
2157   // AES (introduced with Power 8)
2158   inline void vcipher(     VectorRegister d, VectorRegister a, VectorRegister b);
2159   inline void vcipherlast( VectorRegister d, VectorRegister a, VectorRegister b);
2160   inline void vncipher(    VectorRegister d, VectorRegister a, VectorRegister b);
2161   inline void vncipherlast(VectorRegister d, VectorRegister a, VectorRegister b);
2162   inline void vsbox(       VectorRegister d, VectorRegister a);
2163 
2164   // SHA (introduced with Power 8)
<a name="13" id="anc13"></a><span class="changed">2165   inline void vshasigmad(VectorRegister d, VectorRegister a, bool st, int six);</span>
<span class="changed">2166   inline void vshasigmaw(VectorRegister d, VectorRegister a, bool st, int six);</span>
2167 
2168   // Vector Binary Polynomial Multiplication (introduced with Power 8)
2169   inline void vpmsumb(  VectorRegister d, VectorRegister a, VectorRegister b);
2170   inline void vpmsumd(  VectorRegister d, VectorRegister a, VectorRegister b);
2171   inline void vpmsumh(  VectorRegister d, VectorRegister a, VectorRegister b);
2172   inline void vpmsumw(  VectorRegister d, VectorRegister a, VectorRegister b);
2173 
2174   // Vector Permute and Xor (introduced with Power 8)
2175   inline void vpermxor( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2176 
2177   // Transactional Memory instructions (introduced with Power 8)
2178   inline void tbegin_();    // R=0
2179   inline void tbeginrot_(); // R=1 Rollback-Only Transaction
2180   inline void tend_();    // A=0
2181   inline void tendall_(); // A=1
2182   inline void tabort_();
2183   inline void tabort_(Register a);
2184   inline void tabortwc_(int t, Register a, Register b);
2185   inline void tabortwci_(int t, Register a, int si);
2186   inline void tabortdc_(int t, Register a, Register b);
2187   inline void tabortdci_(int t, Register a, int si);
2188   inline void tsuspend_(); // tsr with L=0
2189   inline void tresume_();  // tsr with L=1
2190   inline void tcheck(int f);
2191 
2192   static bool is_tbegin(int x) {
2193     return TBEGIN_OPCODE == (x &amp; (0x3f &lt;&lt; OPCODE_SHIFT | 0x3ff &lt;&lt; 1));
2194   }
2195 
2196   // The following encoders use r0 as second operand. These instructions
2197   // read r0 as '0'.
2198   inline void lwzx( Register d, Register s2);
2199   inline void lwz(  Register d, int si16);
2200   inline void lwax( Register d, Register s2);
2201   inline void lwa(  Register d, int si16);
2202   inline void lwbrx(Register d, Register s2);
2203   inline void lhzx( Register d, Register s2);
2204   inline void lhz(  Register d, int si16);
2205   inline void lhax( Register d, Register s2);
2206   inline void lha(  Register d, int si16);
2207   inline void lhbrx(Register d, Register s2);
2208   inline void lbzx( Register d, Register s2);
2209   inline void lbz(  Register d, int si16);
2210   inline void ldx(  Register d, Register s2);
2211   inline void ld(   Register d, int si16);
<a name="14" id="anc14"></a><span class="new">2212   inline void ldbrx(Register d, Register s2);</span>
2213   inline void stwx( Register d, Register s2);
2214   inline void stw(  Register d, int si16);
2215   inline void sthx( Register d, Register s2);
2216   inline void sth(  Register d, int si16);
2217   inline void stbx( Register d, Register s2);
2218   inline void stb(  Register d, int si16);
2219   inline void stdx( Register d, Register s2);
2220   inline void std(  Register d, int si16);
2221 
2222   // PPC 2, section 3.2.1 Instruction Cache Instructions
2223   inline void icbi(    Register s2);
2224   // PPC 2, section 3.2.2 Data Cache Instructions
2225   //inlinevoid dcba(   Register s2); // Instruction for embedded processor only.
2226   inline void dcbz(    Register s2);
2227   inline void dcbst(   Register s2);
2228   inline void dcbf(    Register s2);
2229   // dcache read hint
2230   inline void dcbt(    Register s2);
2231   inline void dcbtct(  Register s2, int ct);
2232   inline void dcbtds(  Register s2, int ds);
2233   // dcache write hint
2234   inline void dcbtst(  Register s2);
2235   inline void dcbtstct(Register s2, int ct);
2236 
2237   // Atomics: use ra0mem to disallow R0 as base.
2238   inline void lbarx_unchecked(Register d, Register b, int eh1);
2239   inline void lharx_unchecked(Register d, Register b, int eh1);
2240   inline void lwarx_unchecked(Register d, Register b, int eh1);
2241   inline void ldarx_unchecked(Register d, Register b, int eh1);
2242   inline void lqarx_unchecked(Register d, Register b, int eh1);
2243   inline void lbarx( Register d, Register b, bool hint_exclusive_access);
2244   inline void lharx( Register d, Register b, bool hint_exclusive_access);
2245   inline void lwarx( Register d, Register b, bool hint_exclusive_access);
2246   inline void ldarx( Register d, Register b, bool hint_exclusive_access);
2247   inline void lqarx( Register d, Register b, bool hint_exclusive_access);
2248   inline void stbcx_(Register s, Register b);
2249   inline void sthcx_(Register s, Register b);
2250   inline void stwcx_(Register s, Register b);
2251   inline void stdcx_(Register s, Register b);
2252   inline void stqcx_(Register s, Register b);
2253   inline void lfs(   FloatRegister d, int si16);
2254   inline void lfsx(  FloatRegister d, Register b);
2255   inline void lfd(   FloatRegister d, int si16);
2256   inline void lfdx(  FloatRegister d, Register b);
2257   inline void stfs(  FloatRegister s, int si16);
2258   inline void stfsx( FloatRegister s, Register b);
2259   inline void stfd(  FloatRegister s, int si16);
2260   inline void stfdx( FloatRegister s, Register b);
2261   inline void lvebx( VectorRegister d, Register s2);
2262   inline void lvehx( VectorRegister d, Register s2);
2263   inline void lvewx( VectorRegister d, Register s2);
2264   inline void lvx(   VectorRegister d, Register s2);
2265   inline void lvxl(  VectorRegister d, Register s2);
2266   inline void stvebx(VectorRegister d, Register s2);
2267   inline void stvehx(VectorRegister d, Register s2);
2268   inline void stvewx(VectorRegister d, Register s2);
2269   inline void stvx(  VectorRegister d, Register s2);
2270   inline void stvxl( VectorRegister d, Register s2);
2271   inline void lvsl(  VectorRegister d, Register s2);
2272   inline void lvsr(  VectorRegister d, Register s2);
2273 
2274   // RegisterOrConstant versions.
2275   // These emitters choose between the versions using two registers and
2276   // those with register and immediate, depending on the content of roc.
2277   // If the constant is not encodable as immediate, instructions to
2278   // load the constant are emitted beforehand. Store instructions need a
2279   // tmp reg if the constant is not encodable as immediate.
2280   // Size unpredictable.
2281   void ld(  Register d, RegisterOrConstant roc, Register s1 = noreg);
2282   void lwa( Register d, RegisterOrConstant roc, Register s1 = noreg);
2283   void lwz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2284   void lha( Register d, RegisterOrConstant roc, Register s1 = noreg);
2285   void lhz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2286   void lbz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2287   void std( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2288   void stw( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2289   void sth( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2290   void stb( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2291   void add( Register d, RegisterOrConstant roc, Register s1);
2292   void subf(Register d, RegisterOrConstant roc, Register s1);
2293   void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);
2294   // Load pointer d from s1+roc.
2295   void ld_ptr(Register d, RegisterOrConstant roc, Register s1 = noreg) { ld(d, roc, s1); }
2296 
2297   // Emit several instructions to load a 64 bit constant. This issues a fixed
2298   // instruction pattern so that the constant can be patched later on.
2299   enum {
2300     load_const_size = 5 * BytesPerInstWord
2301   };
2302          void load_const(Register d, long a,            Register tmp = noreg);
2303   inline void load_const(Register d, void* a,           Register tmp = noreg);
2304   inline void load_const(Register d, Label&amp; L,          Register tmp = noreg);
2305   inline void load_const(Register d, AddressLiteral&amp; a, Register tmp = noreg);
2306   inline void load_const32(Register d, int i); // load signed int (patchable)
2307 
2308   // Load a 64 bit constant, optimized, not identifyable.
2309   // Tmp can be used to increase ILP. Set return_simm16_rest = true to get a
2310   // 16 bit immediate offset. This is useful if the offset can be encoded in
2311   // a succeeding instruction.
2312          int load_const_optimized(Register d, long a,  Register tmp = noreg, bool return_simm16_rest = false);
2313   inline int load_const_optimized(Register d, void* a, Register tmp = noreg, bool return_simm16_rest = false) {
2314     return load_const_optimized(d, (long)(unsigned long)a, tmp, return_simm16_rest);
2315   }
2316 
2317   // If return_simm16_rest, the return value needs to get added afterwards.
2318          int add_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false);
2319   inline int add_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2320     return add_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2321   }
2322 
2323   // If return_simm16_rest, the return value needs to get added afterwards.
2324   inline int sub_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false) {
2325     return add_const_optimized(d, s, -x, tmp, return_simm16_rest);
2326   }
2327   inline int sub_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2328     return sub_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2329   }
2330 
2331   // Creation
2332   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2333 #ifdef CHECK_DELAY
2334     delay_state = no_delay;
2335 #endif
2336   }
2337 
2338   // Testing
2339 #ifndef PRODUCT
2340   void test_asm();
2341 #endif
2342 };
2343 
2344 
2345 #endif // CPU_PPC_VM_ASSEMBLER_PPC_HPP
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="15" type="hidden" /></form></body></html>
