<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/cpu/ppc/vm/register_ppc.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2016 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_PPC_VM_REGISTER_PPC_HPP
  27 #define CPU_PPC_VM_REGISTER_PPC_HPP
  28 
  29 #include "asm/register.hpp"
  30 
  31 // forward declaration
  32 class Address;
  33 class VMRegImpl;
  34 typedef VMRegImpl* VMReg;
  35 
  36 //  PPC64 registers
  37 //
  38 //  See "64-bit PowerPC ELF ABI Supplement 1.7", IBM Corp. (2003-10-29).
  39 //  (http://math-atlas.sourceforge.net/devel/assembly/PPC-elf64abi-1.7.pdf)
  40 //
  41 //  r0        Register used in function prologs (volatile)
  42 //  r1        Stack pointer (nonvolatile)
  43 //  r2        TOC pointer (volatile)
  44 //  r3        Parameter and return value (volatile)
  45 //  r4-r10    Function parameters (volatile)
  46 //  r11       Register used in calls by pointer and as an environment pointer for languages which require one (volatile)
  47 //  r12       Register used for exception handling and glink code (volatile)
  48 //  r13       Reserved for use as system thread ID
  49 //  r14-r31   Local variables (nonvolatile)
  50 //
  51 //  f0        Scratch register (volatile)
  52 //  f1-f4     Floating point parameters and return value (volatile)
  53 //  f5-f13    Floating point parameters (volatile)
  54 //  f14-f31   Floating point values (nonvolatile)
  55 //
  56 //  LR        Link register for return address (volatile)
  57 //  CTR       Loop counter (volatile)
  58 //  XER       Fixed point exception register (volatile)
  59 //  FPSCR     Floating point status and control register (volatile)
  60 //
  61 //  CR0-CR1   Condition code fields (volatile)
  62 //  CR2-CR4   Condition code fields (nonvolatile)
  63 //  CR5-CR7   Condition code fields (volatile)
  64 //
  65 //  ----------------------------------------------
  66 //  On processors with the VMX feature:
  67 //  v0-v1     Volatile scratch registers
  68 //  v2-v13    Volatile vector parameters registers
  69 //  v14-v19   Volatile scratch registers
  70 //  v20-v31   Non-volatile registers
  71 //  vrsave    Non-volatile 32-bit register
  72 
  73 
  74 // Use Register as shortcut
  75 class RegisterImpl;
  76 typedef RegisterImpl* Register;
  77 
  78 inline Register as_Register(int encoding) {
  79   assert(encoding &gt;= -1 &amp;&amp; encoding &lt; 32, "bad register encoding");
  80   return (Register)(intptr_t)encoding;
  81 }
  82 
  83 // The implementation of integer registers for the Power architecture
  84 class RegisterImpl: public AbstractRegisterImpl {
  85  public:
  86   enum {
  87     number_of_registers = 32
  88   };
  89 
  90   // general construction
  91   inline friend Register as_Register(int encoding);
  92 
  93   // accessors
  94   int encoding() const { assert(is_valid(), "invalid register"); return value(); }
  95   inline VMReg as_VMReg();
  96   Register successor() const { return as_Register(encoding() + 1); }
  97 
  98   // testers
  99   bool is_valid()       const { return ( 0 &lt;= (value()&amp;0x7F) &amp;&amp; (value()&amp;0x7F) &lt;  number_of_registers); }
 100   bool is_volatile()    const { return ( 0 &lt;= (value()&amp;0x7F) &amp;&amp; (value()&amp;0x7F) &lt;= 13 ); }
 101   bool is_nonvolatile() const { return (14 &lt;= (value()&amp;0x7F) &amp;&amp; (value()&amp;0x7F) &lt;= 31 ); }
 102 
 103   const char* name() const;
 104 };
 105 
 106 // The integer registers of the PPC architecture
 107 CONSTANT_REGISTER_DECLARATION(Register, noreg, (-1));
 108 
 109 CONSTANT_REGISTER_DECLARATION(Register, R0,   (0));
 110 CONSTANT_REGISTER_DECLARATION(Register, R1,   (1));
 111 CONSTANT_REGISTER_DECLARATION(Register, R2,   (2));
 112 CONSTANT_REGISTER_DECLARATION(Register, R3,   (3));
 113 CONSTANT_REGISTER_DECLARATION(Register, R4,   (4));
 114 CONSTANT_REGISTER_DECLARATION(Register, R5,   (5));
 115 CONSTANT_REGISTER_DECLARATION(Register, R6,   (6));
 116 CONSTANT_REGISTER_DECLARATION(Register, R7,   (7));
 117 CONSTANT_REGISTER_DECLARATION(Register, R8,   (8));
 118 CONSTANT_REGISTER_DECLARATION(Register, R9,   (9));
 119 CONSTANT_REGISTER_DECLARATION(Register, R10, (10));
 120 CONSTANT_REGISTER_DECLARATION(Register, R11, (11));
 121 CONSTANT_REGISTER_DECLARATION(Register, R12, (12));
 122 CONSTANT_REGISTER_DECLARATION(Register, R13, (13));
 123 CONSTANT_REGISTER_DECLARATION(Register, R14, (14));
 124 CONSTANT_REGISTER_DECLARATION(Register, R15, (15));
 125 CONSTANT_REGISTER_DECLARATION(Register, R16, (16));
 126 CONSTANT_REGISTER_DECLARATION(Register, R17, (17));
 127 CONSTANT_REGISTER_DECLARATION(Register, R18, (18));
 128 CONSTANT_REGISTER_DECLARATION(Register, R19, (19));
 129 CONSTANT_REGISTER_DECLARATION(Register, R20, (20));
 130 CONSTANT_REGISTER_DECLARATION(Register, R21, (21));
 131 CONSTANT_REGISTER_DECLARATION(Register, R22, (22));
 132 CONSTANT_REGISTER_DECLARATION(Register, R23, (23));
 133 CONSTANT_REGISTER_DECLARATION(Register, R24, (24));
 134 CONSTANT_REGISTER_DECLARATION(Register, R25, (25));
 135 CONSTANT_REGISTER_DECLARATION(Register, R26, (26));
 136 CONSTANT_REGISTER_DECLARATION(Register, R27, (27));
 137 CONSTANT_REGISTER_DECLARATION(Register, R28, (28));
 138 CONSTANT_REGISTER_DECLARATION(Register, R29, (29));
 139 CONSTANT_REGISTER_DECLARATION(Register, R30, (30));
 140 CONSTANT_REGISTER_DECLARATION(Register, R31, (31));
 141 
 142 
 143 //
 144 // Because Power has many registers, #define'ing values for them is
 145 // beneficial in code size and is worth the cost of some of the
 146 // dangers of defines. If a particular file has a problem with these
 147 // defines then it's possible to turn them off in that file by
 148 // defining DONT_USE_REGISTER_DEFINES. Register_definition_ppc.cpp
 149 // does that so that it's able to provide real definitions of these
 150 // registers for use in debuggers and such.
 151 //
 152 
 153 #ifndef DONT_USE_REGISTER_DEFINES
 154 #define noreg ((Register)(noreg_RegisterEnumValue))
 155 
 156 #define R0 ((Register)(R0_RegisterEnumValue))
 157 #define R1 ((Register)(R1_RegisterEnumValue))
 158 #define R2 ((Register)(R2_RegisterEnumValue))
 159 #define R3 ((Register)(R3_RegisterEnumValue))
 160 #define R4 ((Register)(R4_RegisterEnumValue))
 161 #define R5 ((Register)(R5_RegisterEnumValue))
 162 #define R6 ((Register)(R6_RegisterEnumValue))
 163 #define R7 ((Register)(R7_RegisterEnumValue))
 164 #define R8 ((Register)(R8_RegisterEnumValue))
 165 #define R9 ((Register)(R9_RegisterEnumValue))
 166 #define R10 ((Register)(R10_RegisterEnumValue))
 167 #define R11 ((Register)(R11_RegisterEnumValue))
 168 #define R12 ((Register)(R12_RegisterEnumValue))
 169 #define R13 ((Register)(R13_RegisterEnumValue))
 170 #define R14 ((Register)(R14_RegisterEnumValue))
 171 #define R15 ((Register)(R15_RegisterEnumValue))
 172 #define R16 ((Register)(R16_RegisterEnumValue))
 173 #define R17 ((Register)(R17_RegisterEnumValue))
 174 #define R18 ((Register)(R18_RegisterEnumValue))
 175 #define R19 ((Register)(R19_RegisterEnumValue))
 176 #define R20 ((Register)(R20_RegisterEnumValue))
 177 #define R21 ((Register)(R21_RegisterEnumValue))
 178 #define R22 ((Register)(R22_RegisterEnumValue))
 179 #define R23 ((Register)(R23_RegisterEnumValue))
 180 #define R24 ((Register)(R24_RegisterEnumValue))
 181 #define R25 ((Register)(R25_RegisterEnumValue))
 182 #define R26 ((Register)(R26_RegisterEnumValue))
 183 #define R27 ((Register)(R27_RegisterEnumValue))
 184 #define R28 ((Register)(R28_RegisterEnumValue))
 185 #define R29 ((Register)(R29_RegisterEnumValue))
 186 #define R30 ((Register)(R30_RegisterEnumValue))
 187 #define R31 ((Register)(R31_RegisterEnumValue))
 188 #endif
 189 
 190 // Use ConditionRegister as shortcut
 191 class ConditionRegisterImpl;
 192 typedef ConditionRegisterImpl* ConditionRegister;
 193 
 194 inline ConditionRegister as_ConditionRegister(int encoding) {
 195   assert(encoding &gt;= 0 &amp;&amp; encoding &lt; 8, "bad condition register encoding");
 196   return (ConditionRegister)(intptr_t)encoding;
 197 }
 198 
 199 // The implementation of condition register(s) for the PPC architecture
 200 class ConditionRegisterImpl: public AbstractRegisterImpl {
 201  public:
 202   enum {
 203     number_of_registers = 8
 204   };
 205 
 206   // construction.
 207   inline friend ConditionRegister as_ConditionRegister(int encoding);
 208 
 209   // accessors
 210   int encoding() const { assert(is_valid(), "invalid register"); return value(); }
 211   inline VMReg as_VMReg();
 212 
 213   // testers
 214   bool is_valid()       const { return  (0 &lt;= value()        &amp;&amp;  value() &lt; number_of_registers); }
 215   bool is_nonvolatile() const { return  (2 &lt;= (value()&amp;0x7F) &amp;&amp; (value()&amp;0x7F) &lt;= 4 );  }
 216 
 217   const char* name() const;
 218 };
 219 
 220 // The (parts of the) condition register(s) of the PPC architecture
 221 // sys/ioctl.h on AIX defines CR0-CR3, so I name these CCR.
 222 CONSTANT_REGISTER_DECLARATION(ConditionRegister, CCR0,   (0));
 223 CONSTANT_REGISTER_DECLARATION(ConditionRegister, CCR1,   (1));
 224 CONSTANT_REGISTER_DECLARATION(ConditionRegister, CCR2,   (2));
 225 CONSTANT_REGISTER_DECLARATION(ConditionRegister, CCR3,   (3));
 226 CONSTANT_REGISTER_DECLARATION(ConditionRegister, CCR4,   (4));
 227 CONSTANT_REGISTER_DECLARATION(ConditionRegister, CCR5,   (5));
 228 CONSTANT_REGISTER_DECLARATION(ConditionRegister, CCR6,   (6));
 229 CONSTANT_REGISTER_DECLARATION(ConditionRegister, CCR7,   (7));
 230 
 231 #ifndef DONT_USE_REGISTER_DEFINES
 232 
 233 #define CCR0 ((ConditionRegister)(CCR0_ConditionRegisterEnumValue))
 234 #define CCR1 ((ConditionRegister)(CCR1_ConditionRegisterEnumValue))
 235 #define CCR2 ((ConditionRegister)(CCR2_ConditionRegisterEnumValue))
 236 #define CCR3 ((ConditionRegister)(CCR3_ConditionRegisterEnumValue))
 237 #define CCR4 ((ConditionRegister)(CCR4_ConditionRegisterEnumValue))
 238 #define CCR5 ((ConditionRegister)(CCR5_ConditionRegisterEnumValue))
 239 #define CCR6 ((ConditionRegister)(CCR6_ConditionRegisterEnumValue))
 240 #define CCR7 ((ConditionRegister)(CCR7_ConditionRegisterEnumValue))
 241 
 242 #endif // DONT_USE_REGISTER_DEFINES
 243 
 244 
 245 // Use FloatRegister as shortcut
 246 class FloatRegisterImpl;
 247 typedef FloatRegisterImpl* FloatRegister;
 248 
 249 inline FloatRegister as_FloatRegister(int encoding) {
 250   assert(encoding &gt;= -1 &amp;&amp; encoding &lt; 32, "bad float register encoding");
 251   return (FloatRegister)(intptr_t)encoding;
 252 }
 253 
 254 // The implementation of float registers for the PPC architecture
 255 class FloatRegisterImpl: public AbstractRegisterImpl {
 256  public:
 257   enum {
 258     number_of_registers = 32
 259   };
 260 
 261   // construction
 262   inline friend FloatRegister as_FloatRegister(int encoding);
 263 
 264   // accessors
 265   int           encoding() const { assert(is_valid(), "invalid register"); return value(); }
 266   inline VMReg  as_VMReg();
 267   FloatRegister successor() const { return as_FloatRegister(encoding() + 1); }
 268 
 269   // testers
 270   bool is_valid() const { return (0 &lt;= value() &amp;&amp; value() &lt; number_of_registers); }
 271 
 272   const char* name() const;
 273 };
 274 
 275 // The float registers of the PPC architecture
 276 CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg, (-1));
 277 
 278 CONSTANT_REGISTER_DECLARATION(FloatRegister, F0,  ( 0));
 279 CONSTANT_REGISTER_DECLARATION(FloatRegister, F1,  ( 1));
 280 CONSTANT_REGISTER_DECLARATION(FloatRegister, F2,  ( 2));
 281 CONSTANT_REGISTER_DECLARATION(FloatRegister, F3,  ( 3));
 282 CONSTANT_REGISTER_DECLARATION(FloatRegister, F4,  ( 4));
 283 CONSTANT_REGISTER_DECLARATION(FloatRegister, F5,  ( 5));
 284 CONSTANT_REGISTER_DECLARATION(FloatRegister, F6,  ( 6));
 285 CONSTANT_REGISTER_DECLARATION(FloatRegister, F7,  ( 7));
 286 CONSTANT_REGISTER_DECLARATION(FloatRegister, F8,  ( 8));
 287 CONSTANT_REGISTER_DECLARATION(FloatRegister, F9,  ( 9));
 288 CONSTANT_REGISTER_DECLARATION(FloatRegister, F10, (10));
 289 CONSTANT_REGISTER_DECLARATION(FloatRegister, F11, (11));
 290 CONSTANT_REGISTER_DECLARATION(FloatRegister, F12, (12));
 291 CONSTANT_REGISTER_DECLARATION(FloatRegister, F13, (13));
 292 CONSTANT_REGISTER_DECLARATION(FloatRegister, F14, (14));
 293 CONSTANT_REGISTER_DECLARATION(FloatRegister, F15, (15));
 294 CONSTANT_REGISTER_DECLARATION(FloatRegister, F16, (16));
 295 CONSTANT_REGISTER_DECLARATION(FloatRegister, F17, (17));
 296 CONSTANT_REGISTER_DECLARATION(FloatRegister, F18, (18));
 297 CONSTANT_REGISTER_DECLARATION(FloatRegister, F19, (19));
 298 CONSTANT_REGISTER_DECLARATION(FloatRegister, F20, (20));
 299 CONSTANT_REGISTER_DECLARATION(FloatRegister, F21, (21));
 300 CONSTANT_REGISTER_DECLARATION(FloatRegister, F22, (22));
 301 CONSTANT_REGISTER_DECLARATION(FloatRegister, F23, (23));
 302 CONSTANT_REGISTER_DECLARATION(FloatRegister, F24, (24));
 303 CONSTANT_REGISTER_DECLARATION(FloatRegister, F25, (25));
 304 CONSTANT_REGISTER_DECLARATION(FloatRegister, F26, (26));
 305 CONSTANT_REGISTER_DECLARATION(FloatRegister, F27, (27));
 306 CONSTANT_REGISTER_DECLARATION(FloatRegister, F28, (28));
 307 CONSTANT_REGISTER_DECLARATION(FloatRegister, F29, (29));
 308 CONSTANT_REGISTER_DECLARATION(FloatRegister, F30, (30));
 309 CONSTANT_REGISTER_DECLARATION(FloatRegister, F31, (31));
 310 
 311 #ifndef DONT_USE_REGISTER_DEFINES
 312 #define fnoreg ((FloatRegister)(fnoreg_FloatRegisterEnumValue))
 313 #define F0     ((FloatRegister)(    F0_FloatRegisterEnumValue))
 314 #define F1     ((FloatRegister)(    F1_FloatRegisterEnumValue))
 315 #define F2     ((FloatRegister)(    F2_FloatRegisterEnumValue))
 316 #define F3     ((FloatRegister)(    F3_FloatRegisterEnumValue))
 317 #define F4     ((FloatRegister)(    F4_FloatRegisterEnumValue))
 318 #define F5     ((FloatRegister)(    F5_FloatRegisterEnumValue))
 319 #define F6     ((FloatRegister)(    F6_FloatRegisterEnumValue))
 320 #define F7     ((FloatRegister)(    F7_FloatRegisterEnumValue))
 321 #define F8     ((FloatRegister)(    F8_FloatRegisterEnumValue))
 322 #define F9     ((FloatRegister)(    F9_FloatRegisterEnumValue))
 323 #define F10    ((FloatRegister)(   F10_FloatRegisterEnumValue))
 324 #define F11    ((FloatRegister)(   F11_FloatRegisterEnumValue))
 325 #define F12    ((FloatRegister)(   F12_FloatRegisterEnumValue))
 326 #define F13    ((FloatRegister)(   F13_FloatRegisterEnumValue))
 327 #define F14    ((FloatRegister)(   F14_FloatRegisterEnumValue))
 328 #define F15    ((FloatRegister)(   F15_FloatRegisterEnumValue))
 329 #define F16    ((FloatRegister)(   F16_FloatRegisterEnumValue))
 330 #define F17    ((FloatRegister)(   F17_FloatRegisterEnumValue))
 331 #define F18    ((FloatRegister)(   F18_FloatRegisterEnumValue))
 332 #define F19    ((FloatRegister)(   F19_FloatRegisterEnumValue))
 333 #define F20    ((FloatRegister)(   F20_FloatRegisterEnumValue))
 334 #define F21    ((FloatRegister)(   F21_FloatRegisterEnumValue))
 335 #define F22    ((FloatRegister)(   F22_FloatRegisterEnumValue))
 336 #define F23    ((FloatRegister)(   F23_FloatRegisterEnumValue))
 337 #define F24    ((FloatRegister)(   F24_FloatRegisterEnumValue))
 338 #define F25    ((FloatRegister)(   F25_FloatRegisterEnumValue))
 339 #define F26    ((FloatRegister)(   F26_FloatRegisterEnumValue))
 340 #define F27    ((FloatRegister)(   F27_FloatRegisterEnumValue))
 341 #define F28    ((FloatRegister)(   F28_FloatRegisterEnumValue))
 342 #define F29    ((FloatRegister)(   F29_FloatRegisterEnumValue))
 343 #define F30    ((FloatRegister)(   F30_FloatRegisterEnumValue))
 344 #define F31    ((FloatRegister)(   F31_FloatRegisterEnumValue))
 345 #endif // DONT_USE_REGISTER_DEFINES
 346 
 347 // Use SpecialRegister as shortcut
 348 class SpecialRegisterImpl;
 349 typedef SpecialRegisterImpl* SpecialRegister;
 350 
 351 inline SpecialRegister as_SpecialRegister(int encoding) {
 352   return (SpecialRegister)(intptr_t)encoding;
 353 }
 354 
 355 // The implementation of special registers for the Power architecture (LR, CTR and friends)
 356 class SpecialRegisterImpl: public AbstractRegisterImpl {
 357  public:
 358   enum {
 359     number_of_registers = 6
 360   };
 361 
 362   // construction
 363   inline friend SpecialRegister as_SpecialRegister(int encoding);
 364 
 365   // accessors
 366   int             encoding()  const { assert(is_valid(), "invalid register"); return value(); }
 367   inline VMReg    as_VMReg();
 368 
 369   // testers
 370   bool is_valid()       const { return 0 &lt;= value() &amp;&amp; value() &lt; number_of_registers; }
 371 
 372   const char* name() const;
 373 };
 374 
 375 // The special registers of the PPC architecture
 376 CONSTANT_REGISTER_DECLARATION(SpecialRegister, SR_XER,     (0));
 377 CONSTANT_REGISTER_DECLARATION(SpecialRegister, SR_LR,      (1));
 378 CONSTANT_REGISTER_DECLARATION(SpecialRegister, SR_CTR,     (2));
 379 CONSTANT_REGISTER_DECLARATION(SpecialRegister, SR_VRSAVE,  (3));
 380 CONSTANT_REGISTER_DECLARATION(SpecialRegister, SR_SPEFSCR, (4));
 381 CONSTANT_REGISTER_DECLARATION(SpecialRegister, SR_PPR,     (5));
 382 
 383 #ifndef DONT_USE_REGISTER_DEFINES
 384 #define SR_XER     ((SpecialRegister)(SR_XER_SpecialRegisterEnumValue))
 385 #define SR_LR      ((SpecialRegister)(SR_LR_SpecialRegisterEnumValue))
 386 #define SR_CTR     ((SpecialRegister)(SR_CTR_SpecialRegisterEnumValue))
 387 #define SR_VRSAVE  ((SpecialRegister)(SR_VRSAVE_SpecialRegisterEnumValue))
 388 #define SR_SPEFSCR ((SpecialRegister)(SR_SPEFSCR_SpecialRegisterEnumValue))
 389 #define SR_PPR     ((SpecialRegister)(SR_PPR_SpecialRegisterEnumValue))
 390 #endif // DONT_USE_REGISTER_DEFINES
 391 
 392 
 393 // Use VectorRegister as shortcut
 394 class VectorRegisterImpl;
 395 typedef VectorRegisterImpl* VectorRegister;
 396 
 397 inline VectorRegister as_VectorRegister(int encoding) {
 398   return (VectorRegister)(intptr_t)encoding;
 399 }
 400 
 401 // The implementation of vector registers for the Power architecture
 402 class VectorRegisterImpl: public AbstractRegisterImpl {
 403  public:
 404   enum {
 405     number_of_registers = 32
 406   };
 407 
 408   // construction
 409   inline friend VectorRegister as_VectorRegister(int encoding);
 410 
 411   // accessors
 412   int            encoding()  const { assert(is_valid(), "invalid register"); return value(); }
 413 
 414   // testers
 415   bool is_valid()       const { return   0 &lt;=  value()       &amp;&amp;  value() &lt; number_of_registers; }
 416 
 417   const char* name() const;
 418 };
 419 
 420 // The Vector registers of the Power architecture
 421 
 422 CONSTANT_REGISTER_DECLARATION(VectorRegister, vnoreg, (-1));
 423 
 424 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR0,  ( 0));
 425 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR1,  ( 1));
 426 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR2,  ( 2));
 427 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR3,  ( 3));
 428 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR4,  ( 4));
 429 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR5,  ( 5));
 430 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR6,  ( 6));
 431 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR7,  ( 7));
 432 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR8,  ( 8));
 433 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR9,  ( 9));
 434 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR10, (10));
 435 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR11, (11));
 436 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR12, (12));
 437 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR13, (13));
 438 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR14, (14));
 439 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR15, (15));
 440 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR16, (16));
 441 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR17, (17));
 442 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR18, (18));
 443 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR19, (19));
 444 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR20, (20));
 445 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR21, (21));
 446 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR22, (22));
 447 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR23, (23));
 448 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR24, (24));
 449 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR25, (25));
 450 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR26, (26));
 451 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR27, (27));
 452 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR28, (28));
 453 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR29, (29));
 454 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR30, (30));
 455 CONSTANT_REGISTER_DECLARATION(VectorRegister, VR31, (31));
 456 
 457 #ifndef DONT_USE_REGISTER_DEFINES
 458 #define vnoreg ((VectorRegister)(vnoreg_VectorRegisterEnumValue))
 459 #define VR0    ((VectorRegister)(   VR0_VectorRegisterEnumValue))
 460 #define VR1    ((VectorRegister)(   VR1_VectorRegisterEnumValue))
 461 #define VR2    ((VectorRegister)(   VR2_VectorRegisterEnumValue))
 462 #define VR3    ((VectorRegister)(   VR3_VectorRegisterEnumValue))
 463 #define VR4    ((VectorRegister)(   VR4_VectorRegisterEnumValue))
 464 #define VR5    ((VectorRegister)(   VR5_VectorRegisterEnumValue))
 465 #define VR6    ((VectorRegister)(   VR6_VectorRegisterEnumValue))
 466 #define VR7    ((VectorRegister)(   VR7_VectorRegisterEnumValue))
 467 #define VR8    ((VectorRegister)(   VR8_VectorRegisterEnumValue))
 468 #define VR9    ((VectorRegister)(   VR9_VectorRegisterEnumValue))
 469 #define VR10   ((VectorRegister)(  VR10_VectorRegisterEnumValue))
 470 #define VR11   ((VectorRegister)(  VR11_VectorRegisterEnumValue))
 471 #define VR12   ((VectorRegister)(  VR12_VectorRegisterEnumValue))
 472 #define VR13   ((VectorRegister)(  VR13_VectorRegisterEnumValue))
 473 #define VR14   ((VectorRegister)(  VR14_VectorRegisterEnumValue))
 474 #define VR15   ((VectorRegister)(  VR15_VectorRegisterEnumValue))
 475 #define VR16   ((VectorRegister)(  VR16_VectorRegisterEnumValue))
 476 #define VR17   ((VectorRegister)(  VR17_VectorRegisterEnumValue))
 477 #define VR18   ((VectorRegister)(  VR18_VectorRegisterEnumValue))
 478 #define VR19   ((VectorRegister)(  VR19_VectorRegisterEnumValue))
 479 #define VR20   ((VectorRegister)(  VR20_VectorRegisterEnumValue))
 480 #define VR21   ((VectorRegister)(  VR21_VectorRegisterEnumValue))
 481 #define VR22   ((VectorRegister)(  VR22_VectorRegisterEnumValue))
 482 #define VR23   ((VectorRegister)(  VR23_VectorRegisterEnumValue))
 483 #define VR24   ((VectorRegister)(  VR24_VectorRegisterEnumValue))
 484 #define VR25   ((VectorRegister)(  VR25_VectorRegisterEnumValue))
 485 #define VR26   ((VectorRegister)(  VR26_VectorRegisterEnumValue))
 486 #define VR27   ((VectorRegister)(  VR27_VectorRegisterEnumValue))
 487 #define VR28   ((VectorRegister)(  VR28_VectorRegisterEnumValue))
 488 #define VR29   ((VectorRegister)(  VR29_VectorRegisterEnumValue))
 489 #define VR30   ((VectorRegister)(  VR30_VectorRegisterEnumValue))
 490 #define VR31   ((VectorRegister)(  VR31_VectorRegisterEnumValue))
 491 #endif // DONT_USE_REGISTER_DEFINES
 492 
 493 
 494 // Use VectorSRegister as a shortcut.
 495 class VectorSRegisterImpl;
 496 typedef VectorSRegisterImpl* VectorSRegister;
 497 
 498 inline VectorSRegister as_VectorSRegister(int encoding) {
 499   return (VectorSRegister)(intptr_t)encoding;
 500 }
 501 
 502 // The implementation of Vector-Scalar (VSX) registers on POWER architecture.
 503 class VectorSRegisterImpl: public AbstractRegisterImpl {
 504  public:
 505   enum {
 506     number_of_registers = 32
 507   };
 508 
 509   // construction
 510   inline friend VectorSRegister as_VectorSRegister(int encoding);
 511 
 512   // accessors
 513   int encoding() const { assert(is_valid(), "invalid register"); return value(); }
 514 
 515   // testers
 516   bool is_valid() const { return 0 &lt;=  value() &amp;&amp;  value() &lt; number_of_registers; }
 517 
 518   const char* name() const;
 519 };
 520 
 521 // The Vector-Scalar (VSX) registers of the POWER architecture.
 522 
 523 CONSTANT_REGISTER_DECLARATION(VectorSRegister, vsnoreg, (-1));
 524 
 525 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR0,  ( 0));
 526 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR1,  ( 1));
 527 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR2,  ( 2));
 528 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR3,  ( 3));
 529 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR4,  ( 4));
 530 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR5,  ( 5));
 531 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR6,  ( 6));
 532 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR7,  ( 7));
 533 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR8,  ( 8));
 534 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR9,  ( 9));
 535 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR10, (10));
 536 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR11, (11));
 537 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR12, (12));
 538 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR13, (13));
 539 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR14, (14));
 540 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR15, (15));
 541 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR16, (16));
 542 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR17, (17));
 543 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR18, (18));
 544 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR19, (19));
 545 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR20, (20));
 546 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR21, (21));
 547 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR22, (22));
 548 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR23, (23));
 549 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR24, (24));
 550 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR25, (25));
 551 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR26, (26));
 552 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR27, (27));
 553 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR28, (28));
 554 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR29, (29));
 555 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR30, (30));
 556 CONSTANT_REGISTER_DECLARATION(VectorSRegister, VSR31, (31));
 557 
 558 #ifndef DONT_USE_REGISTER_DEFINES
 559 #define vsnoregi ((VectorSRegister)(vsnoreg_VectorSRegisterEnumValue))
 560 #define VSR0    ((VectorSRegister)(   VSR0_VectorSRegisterEnumValue))
 561 #define VSR1    ((VectorSRegister)(   VSR1_VectorSRegisterEnumValue))
 562 #define VSR2    ((VectorSRegister)(   VSR2_VectorSRegisterEnumValue))
 563 #define VSR3    ((VectorSRegister)(   VSR3_VectorSRegisterEnumValue))
 564 #define VSR4    ((VectorSRegister)(   VSR4_VectorSRegisterEnumValue))
 565 #define VSR5    ((VectorSRegister)(   VSR5_VectorSRegisterEnumValue))
 566 #define VSR6    ((VectorSRegister)(   VSR6_VectorSRegisterEnumValue))
 567 #define VSR7    ((VectorSRegister)(   VSR7_VectorSRegisterEnumValue))
 568 #define VSR8    ((VectorSRegister)(   VSR8_VectorSRegisterEnumValue))
 569 #define VSR9    ((VectorSRegister)(   VSR9_VectorSRegisterEnumValue))
 570 #define VSR10   ((VectorSRegister)(  VSR10_VectorSRegisterEnumValue))
 571 #define VSR11   ((VectorSRegister)(  VSR11_VectorSRegisterEnumValue))
 572 #define VSR12   ((VectorSRegister)(  VSR12_VectorSRegisterEnumValue))
 573 #define VSR13   ((VectorSRegister)(  VSR13_VectorSRegisterEnumValue))
 574 #define VSR14   ((VectorSRegister)(  VSR14_VectorSRegisterEnumValue))
 575 #define VSR15   ((VectorSRegister)(  VSR15_VectorSRegisterEnumValue))
 576 #define VSR16   ((VectorSRegister)(  VSR16_VectorSRegisterEnumValue))
 577 #define VSR17   ((VectorSRegister)(  VSR17_VectorSRegisterEnumValue))
 578 #define VSR18   ((VectorSRegister)(  VSR18_VectorSRegisterEnumValue))
 579 #define VSR19   ((VectorSRegister)(  VSR19_VectorSRegisterEnumValue))
 580 #define VSR20   ((VectorSRegister)(  VSR20_VectorSRegisterEnumValue))
 581 #define VSR21   ((VectorSRegister)(  VSR21_VectorSRegisterEnumValue))
 582 #define VSR22   ((VectorSRegister)(  VSR22_VectorSRegisterEnumValue))
 583 #define VSR23   ((VectorSRegister)(  VSR23_VectorSRegisterEnumValue))
 584 #define VSR24   ((VectorSRegister)(  VSR24_VectorSRegisterEnumValue))
 585 #define VSR25   ((VectorSRegister)(  VSR25_VectorSRegisterEnumValue))
 586 #define VSR26   ((VectorSRegister)(  VSR26_VectorSRegisterEnumValue))
 587 #define VSR27   ((VectorSRegister)(  VSR27_VectorSRegisterEnumValue))
 588 #define VSR28   ((VectorSRegister)(  VSR28_VectorSRegisterEnumValue))
 589 #define VSR29   ((VectorSRegister)(  VSR29_VectorSRegisterEnumValue))
 590 #define VSR30   ((VectorSRegister)(  VSR30_VectorSRegisterEnumValue))
 591 #define VSR31   ((VectorSRegister)(  VSR31_VectorSRegisterEnumValue))
 592 #endif // DONT_USE_REGISTER_DEFINES
 593 
 594 // Maximum number of incoming arguments that can be passed in i registers.
 595 const int PPC_ARGS_IN_REGS_NUM = 8;
 596 
 597 
 598 // Need to know the total number of registers of all sorts for SharedInfo.
 599 // Define a class that exports it.
 600 class ConcreteRegisterImpl : public AbstractRegisterImpl {
 601  public:
 602   enum {
 603     // This number must be large enough to cover REG_COUNT (defined by c2) registers.
 604     // There is no requirement that any ordering here matches any ordering c2 gives
 605     // it's optoregs.
 606     number_of_registers =
 607       ( RegisterImpl::number_of_registers +
 608         FloatRegisterImpl::number_of_registers )
 609       * 2                                          // register halves
 610       + ConditionRegisterImpl::number_of_registers // condition code registers
 611       + SpecialRegisterImpl::number_of_registers   // special registers
 612       + VectorRegisterImpl::number_of_registers    // vector registers
 613   };
 614 
 615   static const int max_gpr;
 616   static const int max_fpr;
 617   static const int max_cnd;
 618 };
 619 
 620 // Common register declarations used in assembler code.
 621 REGISTER_DECLARATION(Register,      R0_SCRATCH, R0);  // volatile
 622 REGISTER_DECLARATION(Register,      R1_SP,      R1);  // non-volatile
 623 REGISTER_DECLARATION(Register,      R2_TOC,     R2);  // volatile
 624 REGISTER_DECLARATION(Register,      R3_RET,     R3);  // volatile
 625 REGISTER_DECLARATION(Register,      R3_ARG1,    R3);  // volatile
 626 REGISTER_DECLARATION(Register,      R4_ARG2,    R4);  // volatile
 627 REGISTER_DECLARATION(Register,      R5_ARG3,    R5);  // volatile
 628 REGISTER_DECLARATION(Register,      R6_ARG4,    R6);  // volatile
 629 REGISTER_DECLARATION(Register,      R7_ARG5,    R7);  // volatile
 630 REGISTER_DECLARATION(Register,      R8_ARG6,    R8);  // volatile
 631 REGISTER_DECLARATION(Register,      R9_ARG7,    R9);  // volatile
 632 REGISTER_DECLARATION(Register,      R10_ARG8,   R10); // volatile
 633 REGISTER_DECLARATION(FloatRegister, F0_SCRATCH, F0);  // volatile
 634 REGISTER_DECLARATION(FloatRegister, F1_RET,     F1);  // volatile
 635 REGISTER_DECLARATION(FloatRegister, F1_ARG1,    F1);  // volatile
 636 REGISTER_DECLARATION(FloatRegister, F2_ARG2,    F2);  // volatile
 637 REGISTER_DECLARATION(FloatRegister, F3_ARG3,    F3);  // volatile
 638 REGISTER_DECLARATION(FloatRegister, F4_ARG4,    F4);  // volatile
 639 REGISTER_DECLARATION(FloatRegister, F5_ARG5,    F5);  // volatile
 640 REGISTER_DECLARATION(FloatRegister, F6_ARG6,    F6);  // volatile
 641 REGISTER_DECLARATION(FloatRegister, F7_ARG7,    F7);  // volatile
 642 REGISTER_DECLARATION(FloatRegister, F8_ARG8,    F8);  // volatile
 643 REGISTER_DECLARATION(FloatRegister, F9_ARG9,    F9);  // volatile
 644 REGISTER_DECLARATION(FloatRegister, F10_ARG10,  F10); // volatile
 645 REGISTER_DECLARATION(FloatRegister, F11_ARG11,  F11); // volatile
 646 REGISTER_DECLARATION(FloatRegister, F12_ARG12,  F12); // volatile
 647 REGISTER_DECLARATION(FloatRegister, F13_ARG13,  F13); // volatile
 648 
 649 #ifndef DONT_USE_REGISTER_DEFINES
 650 #define R0_SCRATCH         AS_REGISTER(Register, R0)
 651 #define R1_SP              AS_REGISTER(Register, R1)
 652 #define R2_TOC             AS_REGISTER(Register, R2)
 653 #define R3_RET             AS_REGISTER(Register, R3)
 654 #define R3_ARG1            AS_REGISTER(Register, R3)
 655 #define R4_ARG2            AS_REGISTER(Register, R4)
 656 #define R5_ARG3            AS_REGISTER(Register, R5)
 657 #define R6_ARG4            AS_REGISTER(Register, R6)
 658 #define R7_ARG5            AS_REGISTER(Register, R7)
 659 #define R8_ARG6            AS_REGISTER(Register, R8)
 660 #define R9_ARG7            AS_REGISTER(Register, R9)
 661 #define R10_ARG8           AS_REGISTER(Register, R10)
 662 #define F0_SCRATCH         AS_REGISTER(FloatRegister, F0)
 663 #define F1_RET             AS_REGISTER(FloatRegister, F1)
 664 #define F1_ARG1            AS_REGISTER(FloatRegister, F1)
 665 #define F2_ARG2            AS_REGISTER(FloatRegister, F2)
 666 #define F3_ARG3            AS_REGISTER(FloatRegister, F3)
 667 #define F4_ARG4            AS_REGISTER(FloatRegister, F4)
 668 #define F5_ARG5            AS_REGISTER(FloatRegister, F5)
 669 #define F6_ARG6            AS_REGISTER(FloatRegister, F6)
 670 #define F7_ARG7            AS_REGISTER(FloatRegister, F7)
 671 #define F8_ARG8            AS_REGISTER(FloatRegister, F8)
 672 #define F9_ARG9            AS_REGISTER(FloatRegister, F9)
 673 #define F10_ARG10          AS_REGISTER(FloatRegister, F10)
 674 #define F11_ARG11          AS_REGISTER(FloatRegister, F11)
 675 #define F12_ARG12          AS_REGISTER(FloatRegister, F12)
 676 #define F13_ARG13          AS_REGISTER(FloatRegister, F13)
 677 #endif
 678 
 679 // Register declarations to be used in frame manager assembly code.
 680 // Use only non-volatile registers in order to keep values across C-calls.
 681 REGISTER_DECLARATION(Register, R14_bcp,        R14);
 682 REGISTER_DECLARATION(Register, R15_esp,        R15);
 683 REGISTER_DECLARATION(FloatRegister, F15_ftos,  F15);
 684 REGISTER_DECLARATION(Register, R16_thread,     R16);      // address of current thread
 685 REGISTER_DECLARATION(Register, R17_tos,        R17);      // address of Java tos (prepushed).
 686 REGISTER_DECLARATION(Register, R18_locals,     R18);      // address of first param slot (receiver).
 687 REGISTER_DECLARATION(Register, R19_method,     R19);      // address of current method
 688 #ifndef DONT_USE_REGISTER_DEFINES
 689 #define R14_bcp           AS_REGISTER(Register, R14)
 690 #define R15_esp           AS_REGISTER(Register, R15)
 691 #define F15_ftos          AS_REGISTER(FloatRegister, F15)
 692 #define R16_thread        AS_REGISTER(Register, R16)
 693 #define R17_tos           AS_REGISTER(Register, R17)
 694 #define R18_locals        AS_REGISTER(Register, R18)
 695 #define R19_method        AS_REGISTER(Register, R19)
 696 #define R21_sender_SP     AS_REGISTER(Register, R21)
 697 #define R23_method_handle AS_REGISTER(Register, R23)
 698 #endif
 699 
 700 // Temporary registers to be used within frame manager. We can use
 701 // the non-volatiles because the call stub has saved them.
 702 // Use only non-volatile registers in order to keep values across C-calls.
 703 REGISTER_DECLARATION(Register, R21_tmp1, R21);
 704 REGISTER_DECLARATION(Register, R22_tmp2, R22);
 705 REGISTER_DECLARATION(Register, R23_tmp3, R23);
 706 REGISTER_DECLARATION(Register, R24_tmp4, R24);
 707 REGISTER_DECLARATION(Register, R25_tmp5, R25);
 708 REGISTER_DECLARATION(Register, R26_tmp6, R26);
 709 REGISTER_DECLARATION(Register, R27_tmp7, R27);
 710 REGISTER_DECLARATION(Register, R28_tmp8, R28);
 711 REGISTER_DECLARATION(Register, R29_tmp9, R29);
 712 REGISTER_DECLARATION(Register, R24_dispatch_addr,     R24);
 713 REGISTER_DECLARATION(Register, R25_templateTableBase, R25);
 714 REGISTER_DECLARATION(Register, R26_monitor,           R26);
 715 REGISTER_DECLARATION(Register, R27_constPoolCache,    R27);
 716 REGISTER_DECLARATION(Register, R28_mdx,               R28);
 717 
 718 REGISTER_DECLARATION(Register, R19_inline_cache_reg, R19);
 719 REGISTER_DECLARATION(Register, R29_TOC, R29);
 720 
 721 #ifndef DONT_USE_REGISTER_DEFINES
 722 #define R21_tmp1         AS_REGISTER(Register, R21)
 723 #define R22_tmp2         AS_REGISTER(Register, R22)
 724 #define R23_tmp3         AS_REGISTER(Register, R23)
 725 #define R24_tmp4         AS_REGISTER(Register, R24)
 726 #define R25_tmp5         AS_REGISTER(Register, R25)
 727 #define R26_tmp6         AS_REGISTER(Register, R26)
 728 #define R27_tmp7         AS_REGISTER(Register, R27)
 729 #define R28_tmp8         AS_REGISTER(Register, R28)
 730 #define R29_tmp9         AS_REGISTER(Register, R29)
 731 //    Lmonitors  : monitor pointer
 732 //    LcpoolCache: constant pool cache
 733 //    mdx: method data index
 734 #define R24_dispatch_addr     AS_REGISTER(Register, R24)
 735 #define R25_templateTableBase AS_REGISTER(Register, R25)
 736 #define R26_monitor           AS_REGISTER(Register, R26)
 737 #define R27_constPoolCache    AS_REGISTER(Register, R27)
 738 #define R28_mdx               AS_REGISTER(Register, R28)
 739 
 740 #define R19_inline_cache_reg AS_REGISTER(Register, R19)
 741 #define R29_TOC AS_REGISTER(Register, R29)
 742 #endif
 743 
 744 // Scratch registers are volatile.
 745 REGISTER_DECLARATION(Register, R11_scratch1, R11);
 746 REGISTER_DECLARATION(Register, R12_scratch2, R12);
 747 #ifndef DONT_USE_REGISTER_DEFINES
 748 #define R11_scratch1   AS_REGISTER(Register, R11)
 749 #define R12_scratch2   AS_REGISTER(Register, R12)
 750 #endif
 751 
 752 #endif // CPU_PPC_VM_REGISTER_PPC_HPP
</pre></body></html>
